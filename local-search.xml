<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux部署 若依后台管理系统</title>
    <link href="/2021/03/22/Linux%E9%83%A8%E7%BD%B2%20%E8%8B%A5%E4%BE%9D/"/>
    <url>/2021/03/22/Linux%E9%83%A8%E7%BD%B2%20%E8%8B%A5%E4%BE%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux部署-若依"><a href="#Linux部署-若依" class="headerlink" title="Linux部署 若依"></a>Linux部署 若依</h1><h2 id="1、若依前后端分离版本"><a href="#1、若依前后端分离版本" class="headerlink" title="1、若依前后端分离版本"></a>1、若依前后端分离版本</h2><ul><li><strong>源码地址</strong></li></ul><blockquote><p><a href="https://gitee.com/y_project/RuoYi-Vue">https://gitee.com/y_project/RuoYi-Vue</a></p></blockquote><ul><li><strong>参考文档</strong></li></ul><blockquote><p><a href="http://doc.ruoyi.vip/ruoyi-vue/document/hjbs.html">http://doc.ruoyi.vip/ruoyi-vue/document/hjbs.html</a></p></blockquote><blockquote><p>以下操作基于在本地dev环境下运行成功</p></blockquote><h3 id="springboot后端部署"><a href="#springboot后端部署" class="headerlink" title="springboot后端部署"></a>springboot后端部署</h3><ul><li><p><strong>后台环境</strong></p><p><img src="/images/ruoyi-vue/ruoyihoutaihuanjing.png"></p></li><li><p><strong>IP地址</strong></p><p><img src="/images/ruoyi-vue/ruoyispringbootip.png"></p></li></ul><ul><li><strong>修改配置</strong></li></ul><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">#创建数据库数据表并修改druid</span><br><span class="xml">spring:</span><br><span class="xml">    datasource:</span><br><span class="xml">        type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="xml">        driverClassName: com.mysql.cj.jdbc.Driver</span><br><span class="xml">        druid:</span><br><span class="xml">            # 主库数据源</span><br><span class="xml">            master:</span><br><span class="xml">                url: jdbc:mysql://192.168.195.129:3306/ry-vue?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8</span><br><span class="xml">                username: root</span><br><span class="xml">                password: root</span><br><br><br><br><br><span class="xml"># 文件路径 示例（ Windows配置D:/ruoyi/uploadPath，Linux配置 /home/ruoyi/uploadPath）</span><br><span class="xml">  profile: /home/ruoyi/uploadPath</span><br><br><br><br><span class="xml"># redis 配置</span><br><span class="xml">  redis:</span><br><span class="xml">    # 地址</span><br><span class="xml">    host: 192.168.195.129</span><br><span class="xml">    # 端口，默认为6379</span><br><span class="xml">    port: 6379</span><br><span class="xml">    # 数据库索引</span><br><span class="xml">    database: 0</span><br><br><br><span class="xml"><span class="hljs-comment">&lt;!-- 日志存放路径 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log.path&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/home/logs/ruoyi&quot;</span> /&gt;</span></span><br><span class="xml"></span><br><span class="xml"></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 控制台输出 --&gt;</span>  字符集</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;log.pattern&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></span><br><br><br><span class="xml"><span class="hljs-comment">&lt;!-- 系统日志输出 --&gt;</span>  <span class="hljs-comment">&lt;!-- 用户访问日志输出  --&gt;</span>   同 <span class="hljs-comment">&lt;!-- 控制台输出 --&gt;</span></span><br><br></code></pre></td></tr></table></figure><ul><li><strong>打jar 包</strong></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#上传到 Linux中 执行</span><br><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>ruoyi-admin.<span class="hljs-keyword">jar</span><br></code></pre></td></tr></table></figure><p><strong>出现</strong></p><p><img src="/images/ruoyi-vue/$Z0O3I1WEVPZJ7619IJF0JJ.png"></p><p><strong>即为后端部署成功</strong></p><ul><li><strong>后端部署坑</strong></li></ul><blockquote><p>虚拟机中 docker 安装了Tomcat 并默认自启动 </p><p>并且其启动端口为8080与若依默认端口冲突</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#关闭默认启动 Tomcat</span><br><span class="hljs-attribute">docker</span> update –-restart=no tomcat<span class="hljs-number">8</span><br><span class="hljs-comment">#停止启动Tomcat</span><br><span class="hljs-attribute">docker</span> stop tomcat<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="ruoyi-ui前端部署"><a href="#ruoyi-ui前端部署" class="headerlink" title="ruoyi-ui前端部署"></a>ruoyi-ui前端部署</h3><ul><li> <strong>打包前端</strong></li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 进入项目目录</span><br>cd ruoyi-ui<br><br><span class="hljs-meta"># 安装依赖</span><br>npm install<br><br><span class="hljs-meta"># 打包正式环境</span><br>npm run build:prod<br><br><span class="hljs-meta"># 打包预发布环境</span><br>npm run build:stage<br><br></code></pre></td></tr></table></figure><blockquote><p>打包完成后会产生dist 文件夹</p><p>将其上传至docker nginx    /usr/share/nginx/html 目录下映射的虚拟机目录  /mydata/nginx/html</p></blockquote><p><img src="/images/ruoyi-vue/Y5X@5X%25~GK2D.png"></p><ul><li><strong>修改配置</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#进入配置文件</span><br>cd <span class="hljs-regexp">/mydata/</span>nginx<span class="hljs-regexp">/conf/</span><br><br><span class="hljs-comment">#打开配置文件并修改</span><br>vim nginx.conf<br><br><span class="hljs-comment">#修改nginx配置文件</span><br>user  root;<br>worker_processes  <span class="hljs-number">1</span>;<br><br>error_log  <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>error.log warn;<br>pid        <span class="hljs-regexp">/var/</span>run/nginx.pid;<br><br><br>events &#123;<br>    worker_connections  <span class="hljs-number">1024</span>;<br>&#125;<br><br><br>http &#123;<br>    include       <span class="hljs-regexp">/etc/</span>nginx/mime.types;<br>    default_type  application/octet-stream;<br><br>    log_format  main  <span class="hljs-string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;<br><br>    access_log  <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>access.log  main;<br><br>    sendfile        on;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    keepalive_timeout  <span class="hljs-number">65</span>;<br><br>    <span class="hljs-comment">#gzip  on;</span><br><br><br>    server &#123;<br>        listen       <span class="hljs-number">80</span>;<br>        server_name  <span class="hljs-number">192.168</span>.<span class="hljs-number">195.129</span>;<br><br><br>        location / &#123;<br>            root   <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/dist;<br>            try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span><span class="hljs-regexp">/ /i</span>ndex.html;<br>            index  index.html index.htm;<br>        &#125;<br>       <br>        location <span class="hljs-regexp">/stage-api/</span>&#123;<br>proxy_set_header Host <span class="hljs-variable">$http_host</span>;<br>proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>proxy_set_header REMOTE-HOST <span class="hljs-variable">$remote_addr</span>;<br>proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>proxy_pass http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">195.129</span>:<span class="hljs-number">8080</span>/;<br>&#125;<br><br>        error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>        location = /<span class="hljs-number">50</span>x.html &#123;<br>            root   html;<br>        &#125;<br><br>     &#125;       <br><br>   <span class="hljs-comment">#include /etc/nginx/conf.d/*.conf;</span><br>&#125;<br><br><br>保存退出并重启nginx<br>:wq<br>docker restart nginx<br><br></code></pre></td></tr></table></figure><ul><li><strong>前段部署坑</strong></li></ul><blockquote><p>nginx配置文件中</p><p> location /stage-api/  才能成功  </p><p>使用官网 location /prod-api/ 文档不能成功</p></blockquote><blockquote><p>即使全部步骤成功后，验证码也加载不出来  &gt;&gt;&gt; 缓存的锅</p></blockquote><h3 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h3><p><img src="/images/ruoyi-vue/ruoyi-springboot182720.jpg"></p><p><img src="/images/ruoyi-vue/ruoyispringboot182758.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>项目部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Nginx</tag>
      
      <tag>Java</tag>
      
      <tag>Spring Boot</tag>
      
      <tag>Vue</tag>
      
      <tag>Linux</tag>
      
      <tag>RuoYi-Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud 笔记</title>
    <link href="/2021/03/22/SpringCloud%20%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/22/SpringCloud%20%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud-笔记"><a href="#SpringCloud-笔记" class="headerlink" title="SpringCloud 笔记"></a>SpringCloud 笔记</h1><h2 id="0-SpringCloud升级-部分组件停用"><a href="#0-SpringCloud升级-部分组件停用" class="headerlink" title="0,SpringCloud升级,部分组件停用:"></a>0,SpringCloud升级,部分组件停用:</h2><p>1,Eureka停用,可以使用zk作为服务注册中心</p><p>2,服务调用,Ribbon准备停更,代替为LoadBalance</p><p>3,Feign改为OpenFeign</p><p>4,Hystrix停更,改为resilence4j</p><p>​        或者阿里巴巴的sentienl</p><p>5.Zuul改为gateway</p><p>6,服务配置Config改为  Nacos</p><p>7,服务总线Bus改为Nacos</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建:"></a>环境搭建:</h1><h2 id="1-创建父工程-pom依赖"><a href="#1-创建父工程-pom依赖" class="headerlink" title="1,创建父工程,pom依赖"></a>1,创建父工程,pom依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">....<br></code></pre></td></tr></table></figure><h2 id="2-创建子模块-pay模块"><a href="#2-创建子模块-pay模块" class="headerlink" title="2,创建子模块,pay模块"></a>2,创建子模块,pay模块</h2><p><img src="/images/springcloud-20/sc%E7%9A%843.png"></p><h3 id="1-子模块名字"><a href="#1-子模块名字" class="headerlink" title="1,子模块名字:"></a>1,子模块名字:</h3><p>​        cloud_pay_8001</p><h3 id="2-pom依赖"><a href="#2-pom依赖" class="headerlink" title="2,pom依赖"></a>2,pom依赖</h3><h3 id="3-创建application-yml"><a href="#3-创建application-yml" class="headerlink" title="3,创建application.yml"></a>3,创建application.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">8001</span>   <br><span class="hljs-attr">spring:</span><br><span class="hljs-attr">application:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">cloud-payment-service</span><br><span class="hljs-attr">datasource:</span><br>    <span class="hljs-comment"># 当前数据源操作类型</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-comment"># mysql驱动类</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/db2019?useUnicode=true&amp;characterEncoding=</span><br>            <span class="hljs-string">UTF-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br><span class="hljs-attr">mybatis:</span><br>    <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath*:mapper/*.xml</span><br>   <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.eiletxie.springcloud.entities</span><br>   <span class="hljs-string">它一般对应我们的实体类所在的包，这个时候会自动取对应包中不包括包名的简单类名作为包括包名的别名。多个package之间可以用逗号或者分号等来进行分隔（value的值一定要是包的全）</span><br></code></pre></td></tr></table></figure><h3 id="4-主启动类"><a href="#4-主启动类" class="headerlink" title="4,主启动类"></a>4,主启动类</h3><p>​        ….</p><h3 id="5-业务类"><a href="#5-业务类" class="headerlink" title="5,业务类"></a>5,业务类</h3><h4 id="1-sql"><a href="#1-sql" class="headerlink" title="1,sql"></a>1,sql</h4><p><img src="/images/springcloud-20/sc%E7%9A%844.png"></p><h4 id="2-实体类"><a href="#2-实体类" class="headerlink" title="2,实体类"></a>2,实体类</h4><p><img src="/images/springcloud-20/sc%E7%9A%845.png"></p><h4 id="3-entity类"><a href="#3-entity类" class="headerlink" title="3,.entity类"></a>3,.entity类</h4><p><img src="/images/springcloud-20/sc%E7%9A%846.png"></p><h4 id="4-dao层"><a href="#4-dao层" class="headerlink" title="4,dao层:"></a>4,dao层:</h4><p><img src="/images/springcloud-20/sc%E7%9A%847.png"></p><h4 id="5-mapper配置文件类"><a href="#5-mapper配置文件类" class="headerlink" title="5,mapper配置文件类"></a>5,mapper配置文件类</h4><p>​                <strong>在resource下,创建mapper/PayMapper.xml</strong></p><p><img src="/images/springcloud-20/sc%E7%9A%848.png"></p><h4 id="6-写service和serviceImpl"><a href="#6-写service和serviceImpl" class="headerlink" title="6,写service和serviceImpl"></a>6,写service和serviceImpl</h4><p><img src="/images/springcloud-20/sc%E7%9A%849.png"></p><p><img src="/images/springcloud-20/sc%E7%9A%8410.png" alt="sc的9"></p><h4 id="7-controller"><a href="#7-controller" class="headerlink" title="7,controller"></a>7,controller</h4><p><img src="/images/springcloud-20/sc%E7%9A%8411.png"></p><p><img src="/images/springcloud-20/sc%E7%9A%8412.png"></p><h2 id="3-热部署"><a href="#3-热部署" class="headerlink" title="3,热部署:"></a>3,热部署:</h2><p><img src="/images/springcloud-20/sc%E7%9A%8413.png"></p><p><img src="/images/springcloud-20/sc%E7%9A%8414.png"></p><p>…..</p><p>…..</p><p>….</p><h2 id="4-order模块"><a href="#4-order模块" class="headerlink" title="4,order模块"></a>4,order模块</h2><p><img src="/images/springcloud-20/sc%E7%9A%843.png"></p><h3 id="1-pom"><a href="#1-pom" class="headerlink" title="1,pom"></a><strong>1,pom</strong></h3><h3 id="2-yml配置文件"><a href="#2-yml配置文件" class="headerlink" title="2,yml配置文件"></a><strong>2,yml配置文件</strong></h3><p><img src="/images/springcloud-20/order%E6%A8%A1%E5%9D%971.png"></p><h3 id="3-主启动类"><a href="#3-主启动类" class="headerlink" title="3,主启动类"></a><strong>3,主启动类</strong></h3><h3 id="4-复制pay模块的实体类-entity类"><a href="#4-复制pay模块的实体类-entity类" class="headerlink" title="4.复制pay模块的实体类,entity类"></a><strong>4.复制pay模块的实体类,entity类</strong></h3><h3 id="5-写controller类"><a href="#5-写controller类" class="headerlink" title="5,写controller类"></a><strong>5,写controller类</strong></h3><p>​        因为这里是消费者类,主要是消费,那么就没有service和dao,需要调用pay模块的方法</p><p>​        并且这里还没有微服务的远程调用,那么如果要调用另外一个模块,则需要使用基本的api调用</p><p>使用RestTemplate调用pay模块,</p><p>​    <img src="/images/springcloud-20/order%E6%A8%A1%E5%9D%972.png"></p><p><img src="/images/springcloud-20/order%E6%A8%A1%E5%9D%973.png"></p><p>​    将restTemplate注入到容器</p><p><img src="/images/springcloud-20/order%E6%A8%A1%E5%9D%974.png"></p><p>编写controller:</p><p><img src="/images/springcloud-20/order%E6%A8%A1%E5%9D%975.png"></p><h2 id="5-重构"><a href="#5-重构" class="headerlink" title="5,重构,"></a>5,重构,</h2><p>新建一个模块,将重复代码抽取到一个公共模块中</p><h3 id="1-创建commons模块"><a href="#1-创建commons模块" class="headerlink" title="1,创建commons模块"></a>1,创建commons模块</h3><h3 id="2-抽取公共pom"><a href="#2-抽取公共pom" class="headerlink" title="2,抽取公共pom"></a>2,抽取公共pom</h3><p><img src="/images/springcloud-20/commons%E6%A8%A1%E5%9D%97.png"></p><h3 id="3-entity和实体类放入commons中"><a href="#3-entity和实体类放入commons中" class="headerlink" title="3,entity和实体类放入commons中"></a>3,entity和实体类放入commons中</h3><p><img src="/images/springcloud-20/commons%E6%A8%A1%E5%9D%972.png"></p><h3 id="4-使用mavne-将commone模块打包-install"><a href="#4-使用mavne-将commone模块打包-install" class="headerlink" title="4,使用mavne,将commone模块打包(install),"></a>4,使用mavne,将commone模块打包(install),</h3><p>​        其他模块引入commons</p><h1 id="2-服务注册与发现"><a href="#2-服务注册与发现" class="headerlink" title="2,服务注册与发现"></a>2,服务注册与发现</h1><h2 id="6-Eureka"><a href="#6-Eureka" class="headerlink" title="6,Eureka:"></a>6,Eureka:</h2><p>前面我们没有服务注册中心,也可以服务间调用,为什么还要服务注册?</p><p>当服务很多时,单靠代码手动管理是很麻烦的,需要一个公共组件,统一管理多服务,包括服务是否正常运行,等</p><p>Eureka用于**==服务注册==<strong>,目前官网</strong>已经停止更新**</p><p>​    <img src="/images/springcloud-20/Eureka%E7%9A%841.png"></p><p><img src="/images/springcloud-20/Eureka%E7%9A%842.png"></p><p><img src="/images/springcloud-20/Eureka%E7%9A%843.png"></p><p> <img src="/images/springcloud-20/Eureka%E7%9A%844.png"></p><h3 id="单机版eureka"><a href="#单机版eureka" class="headerlink" title="单机版eureka:"></a><strong>单机版eureka:</strong></h3><h4 id="1-创建项目cloud-eureka-server-7001"><a href="#1-创建项目cloud-eureka-server-7001" class="headerlink" title="1,创建项目cloud_eureka_server_7001"></a><strong>1,创建项目cloud_eureka_server_7001</strong></h4><h4 id="2-引入pom依赖"><a href="#2-引入pom依赖" class="headerlink" title="2,引入pom依赖"></a><strong>2,引入pom依赖</strong></h4><p>​        eurka最新的依赖变了</p><p><img src="/images/springcloud-20/Eureka%E7%9A%845.png"></p><h4 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3,配置文件:"></a>3,配置文件:</h4><p><img src="/images/springcloud-20/Eureka%E7%9A%846.png"></p><h4 id="4-主启动类-1"><a href="#4-主启动类-1" class="headerlink" title="4,主启动类"></a>4,主启动类</h4><p><img src="/images/springcloud-20/Eureka%E7%9A%847.png"></p><h4 id="5-此时就可以启动当前项目了"><a href="#5-此时就可以启动当前项目了" class="headerlink" title="5,此时就可以启动当前项目了"></a><strong>5,此时就可以启动当前项目了</strong></h4><h4 id="6-其他服务注册到eureka"><a href="#6-其他服务注册到eureka" class="headerlink" title="6,其他服务注册到eureka:"></a><strong>6,其他服务注册到eureka:</strong></h4><p>比如此时pay模块加入eureka:</p><h5 id="1-主启动类上-加注解-表示当前是eureka客户端"><a href="#1-主启动类上-加注解-表示当前是eureka客户端" class="headerlink" title="1.主启动类上,加注解,表示当前是eureka客户端"></a>1.主启动类上,加注解,表示当前是eureka客户端</h5><p><img src="/images/springcloud-20/Eureka%E7%9A%8410.png"></p><h5 id="2-修改pom-引入"><a href="#2-修改pom-引入" class="headerlink" title="2,修改pom,引入"></a>2,修改pom,引入</h5><p><img src="/images/springcloud-20/Eureka%E7%9A%848.png"></p><h5 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3,修改配置文件:"></a>3,修改配置文件:</h5><p><img src="/images/springcloud-20/Eureka%E7%9A%849.png"></p><h5 id="4-pay模块重启-就可以注册到eureka中了"><a href="#4-pay模块重启-就可以注册到eureka中了" class="headerlink" title="4,pay模块重启,就可以注册到eureka中了"></a>4,pay模块重启,就可以注册到eureka中了</h5><p><strong>==order模块的注册是一样的==</strong></p><h3 id="集群版eureka"><a href="#集群版eureka" class="headerlink" title="集群版eureka:"></a>集群版eureka:</h3><h4 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理:"></a>集群原理:</h4><p><img src="/images/springcloud-20/Eureka%E7%9A%8411.png"></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>,就是pay模块启动时,注册自己,并且自身信息也放入eureka<br><span class="hljs-number">2.</span>order模块,首先也注册自己,放入信息,当要调用pay时,先从eureka拿到pay的调用地址<br><span class="hljs-number">3.</span>通过HttpClient调用<br> 并且还会缓存一份到本地,每<span class="hljs-number">30</span>秒更新一次<br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/Eureka%E7%9A%8412.png"></p><p><strong>集群构建原理:</strong></p><p>​        互相注册</p><p><img src="/images/springcloud-20/Eureka%E7%9A%8413.png"></p><h4 id="构建新erueka项目"><a href="#构建新erueka项目" class="headerlink" title="构建新erueka项目"></a><strong>构建新erueka项目</strong></h4><p>名字:cloud_eureka_server_7002</p><h5 id="1-pom文件"><a href="#1-pom文件" class="headerlink" title="1,pom文件:"></a>1,pom文件:</h5><p>​        粘贴7001的即可</p><h5 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2,配置文件:"></a>2,配置文件:</h5><p>​        在写配置文件前,修改一下主机的hosts文件</p><p><img src="/images/springcloud-20/Eureka%E7%9A%8414.png"></p><p>首先修改之前的7001的eureka项目,因为多个eureka需要互相注册</p><p><img src="/images/springcloud-20/Eureka%E7%9A%8415.png"></p><p>然后修改7002</p><p>​            <strong>7002也是一样的,只不过端口和地址改一下</strong></p><h5 id="3-主启动类-1"><a href="#3-主启动类-1" class="headerlink" title="3,主启动类:"></a>3,主启动类:</h5><p>​        复制7001的即可</p><h5 id="4-然后启动7001-7002即可"><a href="#4-然后启动7001-7002即可" class="headerlink" title="4,然后启动7001,7002即可"></a>4,然后启动7001,7002即可</h5><p><em><img src="/images/springcloud-20/Eureka%E7%9A%8416.png"></em></p><h4 id="将pay-order模块注册到eureka集群中"><a href="#将pay-order模块注册到eureka集群中" class="headerlink" title="将pay,order模块注册到eureka集群中:"></a>将pay,order模块注册到eureka集群中:</h4><h5 id="1-只需要修改配置文件即可"><a href="#1-只需要修改配置文件即可" class="headerlink" title="1,只需要修改配置文件即可:"></a>1,只需要修改配置文件即可:</h5><p><img src="/images/springcloud-20/Eureka%E7%9A%8417.png"></p><h5 id="2-两个模块都修改上面的都一样即可"><a href="#2-两个模块都修改上面的都一样即可" class="headerlink" title="2,两个模块都修改上面的都一样即可"></a>2,两个模块都修改上面的都一样即可</h5><p>​            然后启动两个模块</p><p>​            要先启动7001,7002,然后是pay模块8001,然后是order(80)</p><h3 id="3-将pay模块也配置为集群模式"><a href="#3-将pay模块也配置为集群模式" class="headerlink" title="3,将pay模块也配置为集群模式:"></a>3,将pay模块也配置为集群模式:</h3><h4 id="0-创建新模块-8002"><a href="#0-创建新模块-8002" class="headerlink" title="0,创建新模块,8002"></a>0,创建新模块,8002</h4><p>​    名称: cloud_pay_8002</p><h4 id="1-pom文件-复制8001的"><a href="#1-pom文件-复制8001的" class="headerlink" title="1,pom文件,复制8001的"></a>1,pom文件,复制8001的</h4><h4 id="2-pom文件复制8001的"><a href="#2-pom文件复制8001的" class="headerlink" title="2,pom文件复制8001的"></a>2,pom文件复制8001的</h4><h4 id="3-配置文件复制8001的"><a href="#3-配置文件复制8001的" class="headerlink" title="3,配置文件复制8001的"></a>3,配置文件复制8001的</h4><p>​        端口修改一下,改为8002</p><p>​        服务名称不用改,用一样的</p><h4 id="4-主启动类-复制8001的"><a href="#4-主启动类-复制8001的" class="headerlink" title="4.主启动类,复制8001的"></a>4.主启动类,复制8001的</h4><h4 id="5-mapper-service-controller都复制一份"><a href="#5-mapper-service-controller都复制一份" class="headerlink" title="5,mapper,service,controller都复制一份"></a>5,mapper,service,controller都复制一份</h4><p>​        然后就启动服务即可</p><p>​        此时访问order模块,发现并没有负载均衡到两个pay,模块中,而是只访问8001</p><p>​        虽然我们是使用RestTemplate访问的微服务,但是也可以负载均衡的</p><p>​        <img src="/images/springcloud-20/Eureka%E7%9A%8418.png"></p><p><strong>注意这样还不可以,需要让RestTemplate开启负载均衡注解,还可以指定负载均衡算法,默认轮询</strong></p><p><img src="/images/springcloud-20/Eureka%E7%9A%8419.png"></p><h3 id="4-修改服务主机名和ip在eureka的web上显示"><a href="#4-修改服务主机名和ip在eureka的web上显示" class="headerlink" title="4,修改服务主机名和ip在eureka的web上显示"></a>4,修改服务主机名和ip在eureka的web上显示</h3><p>比如修改pay模块</p><h4 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1,修改配置文件:"></a>1,修改配置文件:</h4><p><img src="/images/springcloud-20/Eureka%E7%9A%8420.png"></p><h3 id="5-eureka服务发现"><a href="#5-eureka服务发现" class="headerlink" title="5,eureka服务发现:"></a>5,eureka服务发现:</h3><p><img src="/images/springcloud-20/Eureka%E7%9A%8421.png"></p><p>以pay模块为例</p><h4 id="1-首先添加一个注解-在controller中"><a href="#1-首先添加一个注解-在controller中" class="headerlink" title="1,首先添加一个注解,在controller中"></a>1,首先添加一个注解,在controller中</h4><p><img src="/images/springcloud-20/Eureka%E7%9A%8422.png"></p><p><img src="/images/springcloud-20/Eureka%E7%9A%8423.png"></p><h4 id="2-在主启动类上添加一个注解"><a href="#2-在主启动类上添加一个注解" class="headerlink" title="2,在主启动类上添加一个注解"></a>2,在主启动类上添加一个注解</h4><p><img src="/images/springcloud-20/Eureka%E7%9A%8424.png"></p><p><strong>然后重启8001.访问/payment/discover</strong>y</p><h3 id="6-Eureka自我保护"><a href="#6-Eureka自我保护" class="headerlink" title="6,Eureka自我保护:"></a>6,Eureka自我保护:</h3><p><img src="/images/springcloud-20/Eureka%E7%9A%8426.png"></p><p><img src="/images/springcloud-20/Eureka%E7%9A%8427.png"></p><p><img src="/images/springcloud-20/Eureka%E7%9A%8425.png"></p><p><img src="/images/springcloud-20/Eureka%E7%9A%8428.png"></p><p><strong>eureka服务端配置:</strong></p><p><img src="/images/springcloud-20/Eureka%E7%9A%8429.png"></p><p><img src="/images/springcloud-20/Eureka%E7%9A%8430.png"></p><p>​            <strong>设置接受心跳时间间隔</strong></p><p><strong>客户端(比如pay模块):</strong></p><p><img src="/images/springcloud-20/Eureka%E7%9A%8431.png"></p><p><strong>此时启动erueka和pay.此时如果直接关闭了pay,那么erueka会直接删除其注册信息</strong></p><h2 id="7-Zookeeper服务注册与发现"><a href="#7-Zookeeper服务注册与发现" class="headerlink" title="7,Zookeeper服务注册与发现:"></a>7,Zookeeper服务注册与发现:</h2><h3 id="1-启动zk-到linux上"><a href="#1-启动zk-到linux上" class="headerlink" title="1,启动zk,到linux上"></a>1,启动zk,到linux上</h3><h3 id="2-创建新的pay模块"><a href="#2-创建新的pay模块" class="headerlink" title="2,创建新的pay模块,"></a>2,创建新的pay模块,</h3><p>单独用于注册到zk中  </p><p>名字 : cloud_pay_8003</p><h4 id="1-pom依赖"><a href="#1-pom依赖" class="headerlink" title="1,pom依赖"></a>1,pom依赖</h4><h4 id="2-配置文件-1"><a href="#2-配置文件-1" class="headerlink" title="2,配置文件"></a>2,配置文件</h4><p><img src="/images/springcloud-20/zookeeper%E7%9A%843.png"></p><h4 id="3-主启动类-2"><a href="#3-主启动类-2" class="headerlink" title="3,主启动类"></a>3,主启动类</h4><p><img src="/images/springcloud-20/zookeeper%E7%9A%841.png"></p><h4 id="4-controller"><a href="#4-controller" class="headerlink" title="4,controller"></a>4,controller</h4><p><img src="/images/springcloud-20/zookeeper%E7%9A%842.png"></p><h4 id="5-然后就可以启动"><a href="#5-然后就可以启动" class="headerlink" title="5,然后就可以启动"></a>5,然后就可以启动</h4><p><strong>此时启动,会报错,因为jar包与我们的zk版本不匹配</strong></p><p>解决:<br>        修改pom文件,改为与我们zk版本匹配的jar包</p><p><img src="/images/springcloud-20/zookeeper%E7%9A%844.png"></p><p><strong>此时8003就注册到zk中了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">我们在zk上注册的node是临时节点,当我们的服务一定时间内没有发送心跳<br>  那么zk就会`将这个服务的node删除了<br></code></pre></td></tr></table></figure><p><strong>这里测试,就不写service与dao什么的了</strong></p><h3 id="3-创建order消费模块注册到zk"><a href="#3-创建order消费模块注册到zk" class="headerlink" title="3,创建order消费模块注册到zk"></a>3,创建order消费模块注册到zk</h3><h4 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1,创建项目"></a>1,创建项目</h4><p>名字: cloud_order_zk_80</p><h4 id="2-pom"><a href="#2-pom" class="headerlink" title="2,pom"></a>2,pom</h4><h4 id="3-配置文件-1"><a href="#3-配置文件-1" class="headerlink" title="3,配置文件"></a>3,配置文件</h4><p><img src="/images/springcloud-20/zookeeper%E7%9A%845.png"></p><h4 id="4主启动类"><a href="#4主启动类" class="headerlink" title="4主启动类:"></a>4主启动类:</h4><p><img src="/images/springcloud-20/zookeeper%E7%9A%841.png"></p><h4 id="5-RestTemolate"><a href="#5-RestTemolate" class="headerlink" title="5,RestTemolate"></a>5,RestTemolate</h4><p><img src="/images/springcloud-20/zookeeper%E7%9A%846.png" alt="注意,这里使用RestTemolate,要先注册它"></p><h4 id="6-controller"><a href="#6-controller" class="headerlink" title="6,controller"></a>6,controller</h4><p><img src="/images/springcloud-20/zookeeper%E7%9A%847.png"></p><p><strong>然后启动即可注册到zk</strong></p><h4 id="8-集群版zk注册"><a href="#8-集群版zk注册" class="headerlink" title="8,集群版zk注册:"></a>8,集群版zk注册:</h4><p>只需要修改配置文件:</p><p><img src="/images/springcloud-20/zookeeper%E7%9A%845.png"></p><p>这个connect-string指定多个zk地址即可</p><p>connect-string: 1.2.3.4,2.3.4.5</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="8-Consul"><a href="#8-Consul" class="headerlink" title="8,Consul:"></a>8,Consul:</h2><p><img src="/images/springcloud-20/consul%E7%9A%841.png"></p><p><img src="/images/springcloud-20/consul%E7%9A%842.png"></p><h3 id="1-按照consul"><a href="#1-按照consul" class="headerlink" title="1,按照consul"></a>1,按照consul</h3><p>需要下载一个安装包</p><p><img src="/images/springcloud-20/consul%E7%9A%843.png"></p><p>启动是一个命令行界面,需要输入consul agen-dev启动</p><h3 id="2-创建新的pay模块-8006"><a href="#2-创建新的pay模块-8006" class="headerlink" title="2,创建新的pay模块,8006"></a>2,创建新的pay模块,8006</h3><h4 id="1-项目名字"><a href="#1-项目名字" class="headerlink" title="1,项目名字"></a>1,项目名字</h4><p>cloud_consule_pay_8006</p><h4 id="2-pom依赖-1"><a href="#2-pom依赖-1" class="headerlink" title="2,pom依赖"></a>2,pom依赖</h4><h4 id="3-配置文件-2"><a href="#3-配置文件-2" class="headerlink" title="3,配置文件"></a>3,配置文件</h4><p><img src="/images/springcloud-20/consul%E7%9A%844.png"></p><h4 id="4-主启动类-2"><a href="#4-主启动类-2" class="headerlink" title="4,主启动类"></a>4,主启动类</h4><p><img src="/images/springcloud-20/consul%E7%9A%845.png"></p><h4 id="5-controller"><a href="#5-controller" class="headerlink" title="5,controller"></a>5,controller</h4><p><img src="/images/springcloud-20/consul%E7%9A%846.png"></p><h4 id="6-启动服务"><a href="#6-启动服务" class="headerlink" title="6,启动服务"></a>6,启动服务</h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h3 id="3-创建新order模块"><a href="#3-创建新order模块" class="headerlink" title="3,创建新order模块"></a>3,创建新order模块</h3><p>cloud-consul-order-80</p><h4 id="1-pom文件-1"><a href="#1-pom文件-1" class="headerlink" title="1,pom文件"></a>1,pom文件</h4><h4 id="2-配置文件-2"><a href="#2-配置文件-2" class="headerlink" title="2,配置文件"></a>2,配置文件</h4><p><img src="/images/springcloud-20/consul%E7%9A%847.png"></p><h4 id="3-主启动类-3"><a href="#3-主启动类-3" class="headerlink" title="3,主启动类"></a>3,主启动类</h4><p><img src="/images/springcloud-20/consul%E7%9A%845.png"></p><h4 id="4-RestTemplate注册"><a href="#4-RestTemplate注册" class="headerlink" title="4,RestTemplate注册"></a>4,RestTemplate注册</h4><p>配置类注册</p><h4 id="5-controller-1"><a href="#5-controller-1" class="headerlink" title="5,controller"></a>5,controller</h4><p><img src="/images/springcloud-20/consul%E7%9A%848.png"></p><h4 id="6-启动服务-测试"><a href="#6-启动服务-测试" class="headerlink" title="6,启动服务,测试"></a>6,启动服务,测试</h4><h2 id="9-三个注册中心的异同"><a href="#9-三个注册中心的异同" class="headerlink" title="9,三个注册中心的异同:"></a>9,三个注册中心的异同:</h2><p><img src="/images/springcloud-20/consul%E7%9A%849.png"></p><p><img src="/images/springcloud-20/consul%E7%9A%8410.png"></p><p><img src="/images/springcloud-20/consul%E7%9A%8411.png"></p><h1 id="3-服务调用"><a href="#3-服务调用" class="headerlink" title="3,服务调用"></a>3,服务调用</h1><h2 id="10-Ribbon负载均衡"><a href="#10-Ribbon负载均衡" class="headerlink" title="10,Ribbon负载均衡:"></a>10,Ribbon负载均衡:</h2><p><img src="/images/springcloud-20/Ribbon.png"></p><p><strong>Ribbon目前也进入维护,基本上不准备更新了</strong></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%842.png"></p><p><strong>进程内LB(本地负载均衡)</strong></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%845.png"></p><p><strong>集中式LB(服务端负载均衡)</strong></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%844.png"></p><p><strong>区别</strong></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%843.png"></p><p><strong>Ribbon就是负载均衡+RestTemplate</strong></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%846.png"></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%847.png"></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%848.png"></p><h3 id="使用Ribbon"><a href="#使用Ribbon" class="headerlink" title="使用Ribbon:"></a>使用Ribbon:</h3><h4 id="1-默认我们使用eureka的新版本时-它默认集成了ribbon"><a href="#1-默认我们使用eureka的新版本时-它默认集成了ribbon" class="headerlink" title="1,默认我们使用eureka的新版本时,它默认集成了ribbon:"></a>1,默认我们使用eureka的新版本时,它默认集成了ribbon:</h4><p><img src="/images/springcloud-20/Ribbon%E7%9A%849.png"></p><p><strong>==这个starter中集成了reibbon了==</strong></p><h4 id="2-我们也可以手动引入ribbon"><a href="#2-我们也可以手动引入ribbon" class="headerlink" title="2,我们也可以手动引入ribbon"></a>2,我们也可以手动引入ribbon</h4><p><strong>放到order模块中,因为只有order访问pay时需要负载均衡</strong></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%8410.png"></p><h4 id="3-RestTemplate类"><a href="#3-RestTemplate类" class="headerlink" title="3,RestTemplate类:"></a>3,RestTemplate类:</h4><p><img src="/images/springcloud-20/Ribbon%E7%9A%8411.png"></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%8412.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">RestTemplate的:<br>xxxForObject()方法,返回的是响应体中的数据<br>    xxxForEntity()方法.返回的是entity对象,这个对象不仅仅包含响应体数据,还包含响应体信息(状态码等)<br></code></pre></td></tr></table></figure><h4 id="Ribbon常用负载均衡算法"><a href="#Ribbon常用负载均衡算法" class="headerlink" title="Ribbon常用负载均衡算法:"></a>Ribbon常用负载均衡算法:</h4><p><strong>IRule接口,Riboon使用该接口,根据特定算法从所有服务中,选择一个服务,</strong></p><p><strong>Rule接口有7个实现类,每个实现类代表一个负载均衡算法</strong></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%8414.png"></p><h4 id="使用Ribbon-1"><a href="#使用Ribbon-1" class="headerlink" title="使用Ribbon:"></a>使用Ribbon:</h4><p><strong>==这里使用eureka的那一套服务==</strong></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%8415.png"></p><p><strong>==也就是不能放在主启动类所在的包及子包下==</strong></p><h5 id="1-修改order模块"><a href="#1-修改order模块" class="headerlink" title="1,修改order模块"></a>1,修改order模块</h5><h5 id="2-额外创建一个包"><a href="#2-额外创建一个包" class="headerlink" title="2,额外创建一个包"></a>2,额外创建一个包</h5><p><img src="/images/springcloud-20/Ribbon%E7%9A%8416.png"></p><h5 id="3-创建配置类-指定负载均衡算法"><a href="#3-创建配置类-指定负载均衡算法" class="headerlink" title="3,创建配置类,指定负载均衡算法"></a>3,创建配置类,指定负载均衡算法</h5><p><img src="/images/springcloud-20/Ribbon%E7%9A%8417.png"></p><h5 id="4-在主启动类上加一个注解"><a href="#4-在主启动类上加一个注解" class="headerlink" title="4,在主启动类上加一个注解"></a>4,在主启动类上加一个注解</h5><p><img src="/images/springcloud-20/Ribbon%E7%9A%8418.png"></p><p><strong>表示,访问CLOUD_pAYMENT_SERVICE的服务时,使用我们自定义的负载均衡算法</strong></p><h4 id="自定义负载均衡算法"><a href="#自定义负载均衡算法" class="headerlink" title="自定义负载均衡算法:"></a>自定义负载均衡算法:</h4><h5 id="1-ribbon的轮询算法原理"><a href="#1-ribbon的轮询算法原理" class="headerlink" title="1,ribbon的轮询算法原理"></a>1,ribbon的轮询算法原理</h5><p><img src="/images/springcloud-20/Ribbon%E7%9A%8419.png"></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%8421.png"></p><h5 id="2-自定义负载均衡算法"><a href="#2-自定义负载均衡算法" class="headerlink" title="2,自定义负载均衡算法:"></a>2,自定义负载均衡算法:</h5><p><strong>1,给</strong>pay模块(8001,8002),的controller方法添加一个方法,返回当前节点端口</p><p><img src="/images/springcloud-20/Ribbon%E7%9A%8423.png"></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%8422.png"></p><p><strong>2,修改order模块</strong></p><p>去掉@LoadBalanced</p><p><img src="/images/springcloud-20/Ribbon%E7%9A%8424.png"></p><h5 id="3-自定义接口"><a href="#3-自定义接口" class="headerlink" title="3,自定义接口"></a>3,自定义接口</h5><p><img src="/images/springcloud-20/Ribbon%E7%9A%8429.png"></p><p>​                    ==具体的算法在实现类中实现==</p><h5 id="4-接口实现类"><a href="#4-接口实现类" class="headerlink" title="4,接口实现类"></a>4,接口实现类</h5><p><img src="/images/springcloud-20/Ribbon%E7%9A%8425.png"></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%8426.png"></p><h5 id="5-修改controller"><a href="#5-修改controller" class="headerlink" title="5,修改controller:"></a>5,修改controller:</h5><p><img src="/images/springcloud-20/Ribbon%E7%9A%8427.png"></p><p><img src="/images/springcloud-20/Ribbon%E7%9A%8428.png"></p><h5 id="6-启动服务-测试即可"><a href="#6-启动服务-测试即可" class="headerlink" title="6,启动服务,测试即可"></a>6,启动服务,测试即可</h5><h2 id="11-OpenFeign"><a href="#11-OpenFeign" class="headerlink" title="11,OpenFeign"></a>11,OpenFeign</h2><p><img src="/images/springcloud-20/Feign%E7%9A%841.png"></p><p><strong>是一个声明式的web客户端,只需要创建一个接口,添加注解即可完成微服务之间的调用</strong></p><p><img src="/images/springcloud-20/Feign%E7%9A%842.png"></p><p>==就是A要调用B,Feign就是在A中创建一个一模一样的B对外提供服务的的接口,我们调用这个接口,就可以服务到B==</p><h3 id="Feign与OpenFeign区别"><a href="#Feign与OpenFeign区别" class="headerlink" title="Feign与OpenFeign区别"></a><strong>Feign与OpenFeign区别</strong></h3><p><img src="/images/springcloud-20/Feign%E7%9A%843.png"></p><h3 id="使用OpenFeign"><a href="#使用OpenFeign" class="headerlink" title="使用OpenFeign"></a>使用OpenFeign</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">之前的服务间调用,我们使用的是ribbon+RestTemplate<br>现在改为使用Feign<br></code></pre></td></tr></table></figure><h4 id="1-新建一个order项目-用于feign测试"><a href="#1-新建一个order项目-用于feign测试" class="headerlink" title="1,新建一个order项目,用于feign测试"></a>1,新建一个order项目,用于feign测试</h4><p>名字cloud_order_feign-80</p><h4 id="2-pom文件"><a href="#2-pom文件" class="headerlink" title="2,pom文件"></a>2,pom文件</h4><h4 id="3-配置文件-3"><a href="#3-配置文件-3" class="headerlink" title="3,配置文件"></a>3,配置文件</h4><p><img src="/images/springcloud-20/Feign%E7%9A%844.png"></p><h4 id="4-主启动类-3"><a href="#4-主启动类-3" class="headerlink" title="4,主启动类"></a>4,主启动类</h4><p><img src="/images/springcloud-20/Feign%E7%9A%845.png"></p><h4 id="5-fegin需要调用的其他的服务的接口"><a href="#5-fegin需要调用的其他的服务的接口" class="headerlink" title="5,fegin需要调用的其他的服务的接口"></a>5,fegin需要调用的其他的服务的接口</h4><p><img src="/images/springcloud-20/Feign%E7%9A%846.png"></p><h4 id="6-controller-1"><a href="#6-controller-1" class="headerlink" title="6,controller"></a>6,controller</h4><p><img src="/images/springcloud-20/Feign%E7%9A%847.png"></p><h4 id="7测试"><a href="#7测试" class="headerlink" title="7测试:"></a>7测试:</h4><p>启动两个erueka(7001,7002)</p><p>启动两个pay(8001,8002)</p><p>启动当前的order模块</p><p><strong>Feign默认使用ribbon实现负载均衡</strong></p><h3 id="OpenFeign超时机制"><a href="#OpenFeign超时机制" class="headerlink" title="OpenFeign超时机制:"></a>OpenFeign超时机制:</h3><p>==OpenFeign默认等待时间是1秒,超过1秒,直接报错==</p><h4 id="1-设置超时时间-修改配置文件"><a href="#1-设置超时时间-修改配置文件" class="headerlink" title="1,设置超时时间,修改配置文件:"></a>1,设置超时时间,修改配置文件:</h4><p><strong>因为OpenFeign的底层是ribbon进行负载均衡,所以它的超时时间是由ribbon控制</strong></p><p><img src="/images/springcloud-20/Feign%E7%9A%848.png"></p><h3 id="OpenFeign日志"><a href="#OpenFeign日志" class="headerlink" title="OpenFeign日志:"></a>OpenFeign日志:</h3><p><img src="/images/springcloud-20/Feign%E7%9A%849.png"></p><p><strong>OpenFeign的日志级别有:</strong><br><img src="/images/springcloud-20/Feign%E7%9A%8410.png"></p><h4 id="1-使用OpenFeign的日志"><a href="#1-使用OpenFeign的日志" class="headerlink" title="1,使用OpenFeign的日志:"></a>1,使用OpenFeign的日志:</h4><p><strong>实现在配置类中添加OpenFeign的日志类</strong></p><p><img src="/images/springcloud-20/Feign%E7%9A%8411.png"></p><h4 id="2-为指定类设置日志级别"><a href="#2-为指定类设置日志级别" class="headerlink" title="2,为指定类设置日志级别:"></a>2,为指定类设置日志级别:</h4><p><img src="/images/springcloud-20/Feign%E7%9A%8413.png"></p><p><strong>配置文件中:</strong></p><p><img src="/images/springcloud-20/Feign%E7%9A%8412.png"></p><h4 id="3-启动服务即可"><a href="#3-启动服务即可" class="headerlink" title="3,启动服务即可"></a>3,启动服务即可</h4><h1 id="4-服务降级"><a href="#4-服务降级" class="headerlink" title="4,服务降级:"></a>4,服务降级:</h1><h2 id="12-Hystrix服务降级"><a href="#12-Hystrix服务降级" class="headerlink" title="12,Hystrix服务降级"></a>12,Hystrix服务降级</h2><p><img src="/images/springcloud-20/Hystrix%E7%9A%842.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%843.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%844.png"></p><h3 id="hystrix中的重要概念"><a href="#hystrix中的重要概念" class="headerlink" title="hystrix中的重要概念:"></a>hystrix中的重要概念:</h3><h4 id="1-服务降级"><a href="#1-服务降级" class="headerlink" title="1,服务降级"></a>1,服务降级</h4><p><strong>比如当某个服务繁忙,不能让客户端的请求一直等待,应该立刻返回给客户端一个备选方案</strong></p><h4 id="2-服务熔断"><a href="#2-服务熔断" class="headerlink" title="2,服务熔断"></a>2,服务熔断</h4><p><strong>当某个服务出现问题,卡死了,不能让用户一直等待,需要关闭所有对此服务的访问</strong></p><p>​            <strong>然后调用服务降级</strong></p><h4 id="3-服务限流"><a href="#3-服务限流" class="headerlink" title="3,服务限流"></a>3,服务限流</h4><p><strong>限流,比如秒杀场景,不能访问用户瞬间都访问服务器,限制一次只可以有多少请求</strong></p><h3 id="使用hystrix-服务降级"><a href="#使用hystrix-服务降级" class="headerlink" title="使用hystrix,服务降级:"></a>使用hystrix,服务降级:</h3><h4 id="1-创建带降级机制的pay模块"><a href="#1-创建带降级机制的pay模块" class="headerlink" title="1,创建带降级机制的pay模块 :"></a>1,创建带降级机制的pay模块 :</h4><p>名字: cloud-hystrix-pay-8007</p><h5 id="2-pom文件-1"><a href="#2-pom文件-1" class="headerlink" title="2,pom文件"></a>2,pom文件</h5><h5 id="3-配置文件-4"><a href="#3-配置文件-4" class="headerlink" title="3,配置文件"></a>3,配置文件</h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%845.png"></p><h5 id="4-主启动类-4"><a href="#4-主启动类-4" class="headerlink" title="4,主启动类"></a>4,主启动类</h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%848.png"></p><h5 id="5-service"><a href="#5-service" class="headerlink" title="5,service"></a>5,service</h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%846.png"></p><h5 id="6controller"><a href="#6controller" class="headerlink" title="6controller"></a>6controller</h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%847.png"></p><h5 id="7-先测试"><a href="#7-先测试" class="headerlink" title="7,先测试:"></a>7,先测试:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">此时使用压测工具,并发<span class="hljs-number">20000</span>个请求,请求会延迟的那个方法,<br>压测中,发现,另外一个方法并没有被压测,但是我们访问它时,却需要等待<br>这就是因为被压测的方法它占用了服务器大部分资源,导致其他请求也变慢了<br></code></pre></td></tr></table></figure><h5 id="8-先不加入hystrix"><a href="#8-先不加入hystrix" class="headerlink" title="8,先不加入hystrix,"></a>8,先不加入hystrix,</h5><h4 id="2-创建带降级的order模块"><a href="#2-创建带降级的order模块" class="headerlink" title="2,创建带降级的order模块:"></a>2,创建带降级的order模块:</h4><h5 id="1-名字-cloud-hystrix-order-80"><a href="#1-名字-cloud-hystrix-order-80" class="headerlink" title="1,名字:  cloud-hystrix-order-80"></a>1,名字:  cloud-hystrix-order-80</h5><h5 id="2-pom-1"><a href="#2-pom-1" class="headerlink" title="2,pom"></a>2,pom</h5><h5 id="3-配置文件-5"><a href="#3-配置文件-5" class="headerlink" title="3,配置文件"></a>3,配置文件</h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%849.png"></p><h5 id="4-主启动类-5"><a href="#4-主启动类-5" class="headerlink" title="4,主启动类"></a>4,主启动类</h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%8411.png"></p><h5 id="5-远程调用pay模块的接口"><a href="#5-远程调用pay模块的接口" class="headerlink" title="5,远程调用pay模块的接口:"></a>5,远程调用pay模块的接口:</h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%8412.png"></p><h5 id="6-controller-2"><a href="#6-controller-2" class="headerlink" title="6,controller:"></a>6,controller:</h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%8413.png"></p><h5 id="7-测试"><a href="#7-测试" class="headerlink" title="7,测试"></a>7,测试</h5><p>​            启动order模块,访问pay</p><p>​            再次压测2万并发,发现order访问也变慢了</p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8414.png"></p><p><strong>解决:</strong></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8415.png"></p><h5 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/images/springcloud-20/Hystrix%E7%9A%8416.png"></h5><h4 id="3-配置服务降级"><a href="#3-配置服务降级" class="headerlink" title="3,配置服务降级:"></a>3,配置服务降级:</h4><h5 id="1-修改pay模块"><a href="#1-修改pay模块" class="headerlink" title="1,修改pay模块"></a>1,修改pay模块</h5><h6 id="1-为service的指定方法-会延迟的方法-添加-HystrixCommand注解"><a href="#1-为service的指定方法-会延迟的方法-添加-HystrixCommand注解" class="headerlink" title="1,为service的指定方法(会延迟的方法)添加@HystrixCommand注解"></a>1,为service的指定方法(会延迟的方法)添加@HystrixCommand注解</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8417.png"></p><h6 id="2-主启动类上-添加激活hystrix的注解"><a href="#2-主启动类上-添加激活hystrix的注解" class="headerlink" title="2,主启动类上,添加激活hystrix的注解"></a>2,主启动类上,添加激活hystrix的注解</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8418.png"></p><h6 id="3-触发异常"><a href="#3-触发异常" class="headerlink" title="3,触发异常"></a>3,触发异常</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8419.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8420.png"><strong>可以看到,也触发了降级</strong></p><h5 id="2-修改order模块-进行服务降级"><a href="#2-修改order模块-进行服务降级" class="headerlink" title="2,修改order模块,进行服务降级"></a>2,修改order模块,进行服务降级</h5><p>一般服务降级,都是放在客户端(order模块),</p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8421.png"></p><h6 id="1-修改配置文件-1"><a href="#1-修改配置文件-1" class="headerlink" title="1,修改配置文件:"></a>1,修改配置文件:</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8422.png"></p><h6 id="2-主启动类添加直接-启用hystrix"><a href="#2-主启动类添加直接-启用hystrix" class="headerlink" title="2,主启动类添加直接,启用hystrix:"></a><strong>2,主启动类添加直接,启用hystrix:</strong></h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8423.png"></p><p>​    </p><h6 id="3-修改controller-添加降级方法什么的"><a href="#3-修改controller-添加降级方法什么的" class="headerlink" title="3,修改controller,添加降级方法什么的"></a>3,修改controller,添加降级方法什么的</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8424.png"></p><h6 id="4-测试"><a href="#4-测试" class="headerlink" title="4,测试"></a>4,测试</h6><p>启动pay模块,order模块,</p><p><strong>注意:,这里pay模块和order模块都开启了服务降级</strong></p><p>​            但是order这里,设置了1.5秒就降级,所以访问时,一定会降级</p><h5 id="4-重构"><a href="#4-重构" class="headerlink" title="4,重构:"></a>4,重构:</h5><p><strong>上面出现的问题:</strong><br>        1,降级方法与业务方法写在了一块,耦合度高</p><p>​        2.每个业务方法都写了一个降级方法,重复代码多</p><h5 id="解决重复代码的问题"><a href="#解决重复代码的问题" class="headerlink" title="解决重复代码的问题:"></a><strong>解决重复代码的问题</strong>:</h5><p><strong>配置一个全局的降级方法,所有方法都可以走这个降级方法,至于某些特殊创建,再单独创建方法</strong></p><h6 id="1-创建一个全局方法"><a href="#1-创建一个全局方法" class="headerlink" title="1,创建一个全局方法"></a>1,创建一个全局方法</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8426.png"></p><h6 id="2-使用注解指定其为全局降级方法-默认降级方法"><a href="#2-使用注解指定其为全局降级方法-默认降级方法" class="headerlink" title="2,使用注解指定其为全局降级方法(默认降级方法)"></a>2,使用注解指定其为全局降级方法(默认降级方法)</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8427.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8425.png"></p><h6 id="3-业务方法使用默认降级方法"><a href="#3-业务方法使用默认降级方法" class="headerlink" title="3,业务方法使用默认降级方法:"></a>3,业务方法使用默认降级方法:</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8428.png"></p><h6 id="4-测试-1"><a href="#4-测试-1" class="headerlink" title="4,测试:"></a>4,测试:</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8429.png"></p><h5 id="解决代码耦合度的问题"><a href="#解决代码耦合度的问题" class="headerlink" title="解决代码耦合度的问题:"></a>解决代码耦合度的问题:</h5><p>修改order模块,这里开始,pay模块就不服务降级了,服务降级写在order模块即可</p><h6 id="1-Payservice接口是远程调用pay模块的-我们这里创建一个类实现service接口-在实现类中统一处理异常"><a href="#1-Payservice接口是远程调用pay模块的-我们这里创建一个类实现service接口-在实现类中统一处理异常" class="headerlink" title="1,Payservice接口是远程调用pay模块的,我们这里创建一个类实现service接口,在实现类中统一处理异常"></a>1,Payservice接口是远程调用pay模块的,我们这里创建一个类实现service接口,在实现类中统一处理异常</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8430.png"></p><h6 id="2-修改配置文件-添加"><a href="#2-修改配置文件-添加" class="headerlink" title="2,修改配置文件:添加:"></a>2,修改配置文件:添加:</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8431.png"></p><h6 id="3-让PayService的实现类生效"><a href="#3-让PayService的实现类生效" class="headerlink" title="3,让PayService的实现类生效:"></a>3,让PayService的实现类生效:</h6><p><img src="/images/springcloud-20/Hystrix%E7%9A%8432.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">它的运行逻辑是:<br>当请求过来,首先还是通过Feign远程调用pay模块对应的方法<br>    但是如果pay模块报错,调用失败,那么就会调用PayMentFalbackService类的<br>    当前同名的方法,作为降级方法<br></code></pre></td></tr></table></figure><h6 id="4-启动测试"><a href="#4-启动测试" class="headerlink" title="4,启动测试"></a>4,启动测试</h6><p>启动order和pay正常访问–ok</p><p>==此时将pay服务关闭,order再次访问==</p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8433.png"></p><p>可以看到,并没有报500错误,而是降级访问==实现类==的同名方法</p><p>这样,即使服务器挂了,用户要不要一直等待,或者报错</p><p>问题:</p><p>​        <strong>这样虽然解决了代码耦合度问题,但是又出现了过多重复代码的问题,每个方法都有一个降级方法</strong></p><h3 id="使用服务熔断"><a href="#使用服务熔断" class="headerlink" title="使用服务熔断:"></a>使用服务熔断:</h3><p><img src="/images/springcloud-20/Hystrix%E7%9A%8434.png"></p><p><strong>比如并发达到1000,我们就拒绝其他用户访问,在有用户访问,就访问降级方法</strong></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8435.png"></p><h4 id="1-修改前面的pay模块"><a href="#1-修改前面的pay模块" class="headerlink" title="1,修改前面的pay模块"></a>1,修改前面的pay模块</h4><h5 id="1-修改Payservice接口-添加服务熔断相关的方法"><a href="#1-修改Payservice接口-添加服务熔断相关的方法" class="headerlink" title="1,修改Payservice接口,添加服务熔断相关的方法:"></a><strong>1,修改Payservice接口,添加服务熔断相关的方法:</strong></h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%8437.png"></p><p>这里属性整体意思是:<br>            10秒之内(窗口,会移动),如果并发==超过==10个,或者10个并发中,失败了6个,就开启熔断器</p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8443.png" alt="image-20200414152637247"></p><p>IdUtil是Hutool包下的类,这个Hutool就是整合了所有的常用方法,比如UUID,反射,IO流等工具方法什么的都整合了</p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8436.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">断路器的打开和关闭,是按照一下<span class="hljs-number">5</span>步决定的<br>  <span class="hljs-number">1</span>,并发此时是否达到我们指定的阈值<br>  <span class="hljs-number">2</span>,错误百分比,比如我们配置了<span class="hljs-number">60</span>%,那么如果并发请求中,<span class="hljs-number">10</span>次有<span class="hljs-number">6</span>次是失败的,就开启断路器<br>  <span class="hljs-number">3</span>,上面的条件符合,断路器改变状态为open(开启)<br>  <span class="hljs-number">4</span>,这个服务的断路器开启,所有请求无法访问<br>  <span class="hljs-number">5</span>,在我们的时间窗口期,期间,尝试让一些请求通过(半开状态),如果请求还是失败,证明断路器还是开启状态,服务没有恢复<br>  如果请求成功了,证明服务已经恢复,断路器状态变为close关闭状态<br></code></pre></td></tr></table></figure><h5 id="2-修改controller"><a href="#2-修改controller" class="headerlink" title="2,修改controller"></a>2,修改controller</h5><p>添加一个测试方法;</p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8439.png"></p><h5 id="3-测试"><a href="#3-测试" class="headerlink" title="3,测试:"></a>3,测试:</h5><p>启动pay,order模块</p><p>==多次访问,并且错误率超过60%:==</p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8440.png"></p><p>此时服务熔断,此时即使访问正确的也会报错:</p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8441.png"></p><p><strong>但是,当过了几秒后,又恢复了</strong></p><p>​                因为在10秒窗口期内,它自己会尝试接收部分请求,发现服务可以正常调用,慢慢的当错误率低于60%,取消熔断</p><h3 id="Hystrix所有可配置的属性"><a href="#Hystrix所有可配置的属性" class="headerlink" title="Hystrix所有可配置的属性:"></a>Hystrix所有可配置的属性:</h3><p><strong>全部在这个方法中记录,以成员变量的形式记录,</strong></p><p>​        以后需要什么属性,查看这个类即可</p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8438.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p><img src="/images/springcloud-20/Hystrix%E7%9A%8442.png"></p><p><strong>==当断路器开启后:==</strong></p><p>​    <img src="/images/springcloud-20/Hystrix%E7%9A%8444.png"></p><p><strong>==其他参数:==</strong></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8445.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8446.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8447.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8448.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8449.png"></p><p><strong>熔断整体流程:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>请求进来,首先查询缓存,如果缓存有,直接返回<br>  如果缓存没有,---&gt;<span class="hljs-number">2</span><br><span class="hljs-number">2</span>,查看断路器是否开启,如果开启的,Hystrix直接将请求转发到降级返回,然后返回<br>  如果断路器是关闭的,<br>判断线程池等资源是否已经满了,如果已经满了<br>  也会走降级方法<br>  如果资源没有满,判断我们使用的什么类型的Hystrix,决定调用构造方法还是run方法<br>        然后处理请求<br>        然后Hystrix将本次请求的结果信息汇报给断路器,因为断路器此时可能是开启的<br>          (因为断路器开启也是可以接收请求的)<br>        断路器收到信息,判断是否符合开启或关闭断路器的条件,<br>如果本次请求处理失败,又会进入降级方法<br>        如果处理成功,判断处理是否超时,如果超时了,也进入降级方法<br>        最后,没有超时,则本次请求处理成功,将结果返回给controller<br>         <br> <br></code></pre></td></tr></table></figure><h3 id="Hystrix服务监控"><a href="#Hystrix服务监控" class="headerlink" title="Hystrix服务监控:"></a>Hystrix服务监控:</h3><h4 id="HystrixDashboard"><a href="#HystrixDashboard" class="headerlink" title="HystrixDashboard"></a>HystrixDashboard</h4><p><img src="/images/springcloud-20/Hystrix%E7%9A%8451.png"></p><h4 id="2-使用HystrixDashboard"><a href="#2-使用HystrixDashboard" class="headerlink" title="2,使用HystrixDashboard:"></a>2,使用HystrixDashboard:</h4><h5 id="1-创建项目-1"><a href="#1-创建项目-1" class="headerlink" title="1,创建项目:"></a>1,创建项目:</h5><p>名字: cloud_hystrixdashboard_9001</p><h5 id="2-pom文件-2"><a href="#2-pom文件-2" class="headerlink" title="2,pom文件"></a>2,pom文件</h5><h5 id="3-配置文件-6"><a href="#3-配置文件-6" class="headerlink" title="3,配置文件"></a>3,配置文件</h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%8452.png"></p><h5 id="4-主启动类-6"><a href="#4-主启动类-6" class="headerlink" title="4,主启动类"></a>4,主启动类</h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%8453.png"></p><h5 id="5-修改所有pay模块-8001-8002-8003…"><a href="#5-修改所有pay模块-8001-8002-8003…" class="headerlink" title="5,修改所有pay模块(8001,8002,8003…)"></a>5,修改所有pay模块(8001,8002,8003…)</h5><p><strong>他们都添加一个pom依赖:</strong></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8454.png"></p><p>之前的pom文件中都添加过了,==这个是springboot的监控组件==</p><h5 id="6-启动9001即可"><a href="#6-启动9001即可" class="headerlink" title="6,启动9001即可"></a>6,启动9001即可</h5><p>​            访问: <strong>localhost:9001/hystrix</strong></p><h5 id="7-注意-此时仅仅是可以访问HystrixDashboard-并不代表已经监控了8001-8002"><a href="#7-注意-此时仅仅是可以访问HystrixDashboard-并不代表已经监控了8001-8002" class="headerlink" title="7,注意,此时仅仅是可以访问HystrixDashboard,并不代表已经监控了8001,8002"></a>7,注意,此时仅仅是可以访问HystrixDashboard,并不代表已经监控了8001,8002</h5><p>​                            如果要监控,还需要配置:(8001为例)</p><p>==8001的主启动类添加:==</p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8455.png"></p><p><strong>其他8002,8003都是一样的</strong></p><h5 id="8-到此-可以启动服务"><a href="#8-到此-可以启动服务" class="headerlink" title="8,到此,可以启动服务"></a>8,到此,可以启动服务</h5><p>启动7001,8001,9001</p><p><strong>然后在web界面,指定9001要监控8001:</strong></p><h5 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="/images/springcloud-20/Hystrix%E7%9A%8456.png"></h5><p><img src="/images/springcloud-20/Hystrix%E7%9A%8457.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8459.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8458.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8460.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8461.png"></p><p><img src="/images/springcloud-20/Hystrix%E7%9A%8462.png"></p><h1 id="5-服务网关"><a href="#5-服务网关" class="headerlink" title="5,服务网关:"></a>5,服务网关:</h1><p>zuul停更了,</p><h2 id="13-GateWay"><a href="#13-GateWay" class="headerlink" title="13,GateWay"></a>13,GateWay</h2><p><img src="/images/springcloud-20/gateway%E7%9A%841.png"></p><p><img src="/images/springcloud-20/gateway%E7%9A%842.png"></p><p><strong>gateway之所以性能号,因为底层使用WebFlux,而webFlux底层使用netty通信(NIO)</strong></p><p><img src="/images/springcloud-20/gateway%E7%9A%843.png"></p><h3 id="GateWay的特性"><a href="#GateWay的特性" class="headerlink" title="GateWay的特性:"></a>GateWay的特性:</h3><p><img src="/images/springcloud-20/gateway%E7%9A%844.png"></p><h3 id="GateWay与zuul的区别"><a href="#GateWay与zuul的区别" class="headerlink" title="GateWay与zuul的区别:"></a>GateWay与zuul的区别:</h3><p><img src="/images/springcloud-20/gateway%E7%9A%845.png"></p><h3 id="zuul1-x的模型"><a href="#zuul1-x的模型" class="headerlink" title="zuul1.x的模型:"></a>zuul1.x的模型:</h3><p><img src="/images/springcloud-20/gateway%E7%9A%846.png"></p><p><img src="/images/springcloud-20/gateway%E7%9A%847.png"></p><h3 id="什么是webflux"><a href="#什么是webflux" class="headerlink" title="什么是webflux:"></a>什么是webflux:</h3><p><strong>是一个非阻塞的web框架,类似springmvc这样的</strong></p><p><img src="/images/springcloud-20/gateway%E7%9A%848.png"></p><h3 id="GateWay的一些概念"><a href="#GateWay的一些概念" class="headerlink" title="GateWay的一些概念:"></a>GateWay的一些概念:</h3><h4 id="1-路由"><a href="#1-路由" class="headerlink" title="1,路由:"></a>1,路由:</h4><p><img src="/images/springcloud-20/gateway%E7%9A%849.png"></p><p>就是根据某些规则,将请求发送到指定服务上</p><h4 id="2-断言"><a href="#2-断言" class="headerlink" title="2,断言:"></a>2,断言:</h4><p><img src="/images/springcloud-20/gateway%E7%9A%8410.png"></p><p>就是判断,如果符合条件就是xxxx,反之yyyy</p><h4 id="3-过滤"><a href="#3-过滤" class="headerlink" title="3,过滤:"></a>3,过滤:</h4><p><img src="/images/springcloud-20/gateway%E7%9A%8411.png"></p><p>​    <strong>路由前后,过滤请求</strong></p><h3 id="GateWay的工作原理"><a href="#GateWay的工作原理" class="headerlink" title="GateWay的工作原理:"></a>GateWay的工作原理:</h3><p><img src="/images/springcloud-20/gateway%E7%9A%8412.png"></p><p><img src="/images/springcloud-20/gateway%E7%9A%8413.png"></p><h3 id="使用GateWay"><a href="#使用GateWay" class="headerlink" title="使用GateWay:"></a>使用GateWay:</h3><p>想要新建一个GateWay的项目</p><p>名字:     cloud_gateway_9527</p><h4 id="1-pom-1"><a href="#1-pom-1" class="headerlink" title="1,pom"></a>1,pom</h4><h4 id="2-配置文件-3"><a href="#2-配置文件-3" class="headerlink" title="2,配置文件"></a>2,配置文件</h4><p><img src="/images/springcloud-20/gateway%E7%9A%8414.png"></p><h4 id="3-主启动类-4"><a href="#3-主启动类-4" class="headerlink" title="3,主启动类"></a>3,主启动类</h4><p><img src="/images/springcloud-20/gateway%E7%9A%8415.png"></p><h4 id="4-针对pay模块-设置路由"><a href="#4-针对pay模块-设置路由" class="headerlink" title="4,针对pay模块,设置路由:"></a>4,针对pay模块,设置路由:</h4><p><img src="/images/springcloud-20/gateway%E7%9A%8416.png"></p><p><img src="/images/springcloud-20/gateway%E7%9A%8418.png"></p><p><strong>==修改GateWay模块(9527)的配置文件==:</strong></p><p><img src="/images/springcloud-20/gateway%E7%9A%8417.png"></p><p>这里表示,</p><p>​            当访问localhost:9527/payment/get/1时,     </p><p>​            路由到localhost:8001/payment/get/1</p><h4 id="5-开始测试"><a href="#5-开始测试" class="headerlink" title="5,开始测试"></a>5,开始测试</h4><p><strong>启动7001,8001,9527</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">如果启动GateWay报错<br>  可能是GateWay模块引入了web和监控的starter依赖,需要移除<br></code></pre></td></tr></table></figure><p>访问:</p><p>​        localhost:9527/payment/get/1</p><p><img src="/images/springcloud-20/gateway%E7%9A%8419.png"></p><h4 id="6-GateWay的网关配置"><a href="#6-GateWay的网关配置" class="headerlink" title="6,GateWay的网关配置,"></a>6,GateWay的网关配置,</h4><p>​        <strong>GateWay的网关配置,除了支持配置文件,还支持硬编码方式</strong></p><h4 id="7使用硬编码配置GateWay"><a href="#7使用硬编码配置GateWay" class="headerlink" title="7使用硬编码配置GateWay:"></a>7使用硬编码配置GateWay:</h4><h5 id="创建配置类"><a href="#创建配置类" class="headerlink" title="创建配置类:"></a>创建配置类:</h5><p><img src="/images/springcloud-20/gateway%E7%9A%8420.png"></p><h4 id="8-然后重启服务即可"><a href="#8-然后重启服务即可" class="headerlink" title="8,然后重启服务即可"></a>8,然后重启服务即可</h4><h3 id="重构"><a href="#重构" class="headerlink" title="重构:"></a>重构:</h3><p>上面的配置虽然首先了网关,但是是在配置文件中写死了要路由的地址</p><p>现在需要修改,不指定地址,而是根据微服务名字进行路由,我们可以在注册中心获取某组微服务的地址</p><p>需要:</p><p>​        1个eureka,2个pay模块</p><h4 id="修改GateWay模块的配置文件"><a href="#修改GateWay模块的配置文件" class="headerlink" title="修改GateWay模块的配置文件:"></a>修改GateWay模块的配置文件:</h4><p><img src="/images/springcloud-20/gateway%E7%9A%8421.png"></p><h4 id="然后就可以启动微服务-测试"><a href="#然后就可以启动微服务-测试" class="headerlink" title="然后就可以启动微服务.测试"></a>然后就可以启动微服务.测试</h4><h3 id="Pridicate断言"><a href="#Pridicate断言" class="headerlink" title="Pridicate断言:"></a>Pridicate断言:</h3><p><img src="/images/springcloud-20/gateway%E7%9A%8424.png"></p><p><strong>我们之前在配置文件中配置了断言:</strong></p><p><img src="/images/springcloud-20/gateway%E7%9A%8422.png"></p><p><strong>这个断言表示,如果外部访问路径是指定路径,就路由到指定微服务上</strong></p><p>可以看到,这里有一个Path,这个是断言的一种,==断言的类型==:</p><p><img src="/images/springcloud-20/gateway%E7%9A%8423.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">After:<br>可以指定,只有在指定时间后,才可以路由到指定微服务<br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/gateway%E7%9A%8426.png"></p><p>​                这里表示,只有在==2020年的2月21的15点51分37秒==之后,访问==才可以路由==</p><p>​                在此之前的访问,都会报404</p><p>如何获取当前时区?**</p><p><img src="/images/springcloud-20/gateway%E7%9A%8425.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">before:<br>与after类似,他说在指定时间之前的才可以访问<br>between:<br>需要指定两个时间,在他们之间的时间才可以访问<br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/gateway%E7%9A%8427.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">cookie:<br>只有包含某些指定cookie(key,value),的请求才可以路由<br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/gateway%E7%9A%8428.png"></p><p><img src="/images/springcloud-20/gateway%E7%9A%8429.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Header:<br>只有包含指定请求头的请求,才可以路由<br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/gateway%E7%9A%8431.png"></p><p><img src="/images/springcloud-20/gateway%E7%9A%8432.png"></p><p>测试:<br><img src="/images/springcloud-20/gateway%E7%9A%8433.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">host:<br>只有指定主机的才可以访问,<br>比如我们当前的网站的域名是www.aa.com<br>    那么这里就可以设置,只有用户是www.aa.com的请求,才进行路由<br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/gateway%E7%9A%8434.png"></p><p><img src="/images/springcloud-20/gateway%E7%9A%8435.png" alt="gateway的34"></p><p><img src="/images/springcloud-20/gateway%E7%9A%8436.png"></p><p><img src="/images/springcloud-20/gateway%E7%9A%8437.png"></p><p>可以看到,如果带了域名访问,就可以,但是直接访问ip地址.就报错了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">method:<br>只有指定请求才可以路由,比如get请求...<br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/gateway%E7%9A%8438.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">path:<br>只有访问指定路径,才进行路由<br>     比如访问,/abc才路由<br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/gateway%E7%9A%8439.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Query:<br>必须带有请求参数才可以访问<br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/gateway%E7%9A%8440.png"></p><h3 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器:"></a>Filter过滤器:</h3><p><img src="/images/springcloud-20/gateway%E7%9A%8441.png"></p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期:"></a>生命周期:</h4><p><strong>在请求进入路由之前,和处理请求完成,再次到达路由之前</strong></p><h4 id="种类"><a href="#种类" class="headerlink" title="种类:"></a>种类:</h4><p><img src="/images/springcloud-20/gateway%E7%9A%8442.png"></p><p>GateWayFilter,单一的过滤器</p><p><strong>与断言类似,比如闲置,请求头,只有特定的请求头才放行,反之就过滤</strong>:</p><p><img src="/images/springcloud-20/gateway%E7%9A%8443.png"></p><p>GlobalFilter,全局过滤器:</p><h4 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器:"></a><strong>自定义过滤器:</strong></h4><p>实现两个接口</p><p><img src="/images/springcloud-20/gateway%E7%9A%8444.png"></p><p>​    <strong>然后启动服务,即可,因为过滤器通过@COmponet已经加入到容器了</strong></p><p><img src="/images/springcloud-20/gateway%E7%9A%8446.png"></p><p><img src="/images/springcloud-20/gateway%E7%9A%8445.png"></p><h1 id="6-服务配置"><a href="#6-服务配置" class="headerlink" title="6,服务配置:"></a>6,服务配置:</h1><h2 id="Spring-Config分布式配置中心"><a href="#Spring-Config分布式配置中心" class="headerlink" title="Spring Config分布式配置中心:"></a>Spring Config分布式配置中心:</h2><p>==微服务面临的问题==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">可以看到,每个微服务都需要一个配置文件,并且,如果有几个微服务都需要连接数据库<br>那么就需要配<span class="hljs-number">4</span>次数据库相关配置,并且当数据库发生改动,那么需要同时修改<span class="hljs-number">4</span>个微服务的配置文件才可以<br></code></pre></td></tr></table></figure><p>所以有了springconfig配置中心</p><p><img src="/images/springcloud-20/springconfig%E7%9A%841.png"></p><p><img src="/images/springcloud-20/springconfig%E7%9A%842.png"></p><p><img src="/images/springcloud-20/springconfig%E7%9A%843.png"></p><p><img src="/images/springcloud-20/springconfig%E7%9A%844.png"></p><h3 id="使用配置中心"><a href="#使用配置中心" class="headerlink" title="使用配置中心:"></a>使用配置中心:</h3><h4 id="0-使用github作为配置中心的仓库"><a href="#0-使用github作为配置中心的仓库" class="headerlink" title="0,使用github作为配置中心的仓库:"></a>0,使用github作为配置中心的仓库:</h4><p><strong>初始化git环境:</strong></p><p><img src="/images/springcloud-20/springconfig%E7%9A%845.png"></p><h4 id="1-新建config模块"><a href="#1-新建config模块" class="headerlink" title="1,新建config模块:"></a>1,新建config模块:</h4><p>名字:   cloud-config-3344</p><h4 id="2-pom-2"><a href="#2-pom-2" class="headerlink" title="2,pom"></a>2,pom</h4><h4 id="3-配置文件-7"><a href="#3-配置文件-7" class="headerlink" title="3,配置文件"></a>3,配置文件</h4><p><img src="/images/springcloud-20/springconfig%E7%9A%846.png"></p><h4 id="4-主启动类-7"><a href="#4-主启动类-7" class="headerlink" title="4,主启动类"></a>4,主启动类</h4><p><img src="/images/springcloud-20/springconfig%E7%9A%847.png"></p><h4 id="5-修改hosts"><a href="#5-修改hosts" class="headerlink" title="5,修改hosts:"></a>5,修改hosts:</h4><p><img src="/images/springcloud-20/springconfig%E7%9A%848.png"></p><h4 id="6-配置完成"><a href="#6-配置完成" class="headerlink" title="6,配置完成"></a>6,配置完成</h4><p>测试,3344是否可以从github上获取配置</p><p>启动3344    (要先启动eureka)</p><p><img src="/images/springcloud-20/springconfig%E7%9A%849.png"></p><p>它实际上就是,读取到配置文件中的GitHub的地址,然后拼接上/master/config-dev.yml</p><h4 id="7-读取配置文件的规则"><a href="#7-读取配置文件的规则" class="headerlink" title="7,读取配置文件的规则:"></a>7,读取配置文件的规则:</h4><p><img src="/images/springcloud-20/springconfig%E7%9A%8410.png"></p><p>==2,==</p><p><img src="/images/springcloud-20/springconfig%E7%9A%8411.png"></p><p><strong>这里默认会读取master分支,因为我们配置文件中配置了</strong></p><p><img src="/images/springcloud-20/springconfig%E7%9A%8412.png"></p><p>==3==</p><p><img src="/images/springcloud-20/springconfig%E7%9A%8413.png"></p><p>注意,这个方式读取到的配置是==json格式==的</p><p><strong>所有规则:</strong></p><p><img src="/images/springcloud-20/springconfig%E7%9A%8414.png"></p><h3 id="2-创建配置中心客户端"><a href="#2-创建配置中心客户端" class="headerlink" title="2,创建配置中心客户端:"></a>2,创建配置中心客户端:</h3><h4 id="1-创建config客户端项目"><a href="#1-创建config客户端项目" class="headerlink" title="1,创建config客户端项目"></a>1,创建config客户端项目</h4><p>名字:     cloud-config-client-3355</p><h4 id="2-pom-3"><a href="#2-pom-3" class="headerlink" title="2,pom"></a>2,pom</h4><h4 id="3-配置文件-8"><a href="#3-配置文件-8" class="headerlink" title="3,配置文件"></a>3,配置文件</h4><p>注意这个配置文件就不是application.yml</p><p>​            而是bootstrap.yml</p><p>这个配置文件的作用是,先到配置中心加载配置,然后加载到application.yml中</p><p><img src="/images/springcloud-20/springconfig%E7%9A%8415.png"></p><p><img src="/images/springcloud-20/springconfig%E7%9A%8416.png"></p><h4 id="4-主启动类-8"><a href="#4-主启动类-8" class="headerlink" title="4,主启动类:"></a>4,主启动类:</h4><p><img src="/images/springcloud-20/springconfig%E7%9A%8417.png"></p><h4 id="5-controller类"><a href="#5-controller类" class="headerlink" title="5,controller类"></a>5,controller类</h4><p>就是上面提到的,以rest风格将配置对外暴露</p><p><img src="/images/springcloud-20/springconfig%E7%9A%8418.png"></p><p><img src="/images/springcloud-20/springconfig%E7%9A%8419.png"></p><p><strong>如果客户端运行正常,就会读取到github上配置文件的,config.info下的配置</strong></p><h4 id="6-测试"><a href="#6-测试" class="headerlink" title="6,测试:"></a>6,测试:</h4><p>启动3344,3355</p><p>​    访问3355的  /configInfo</p><p><img src="/images/springcloud-20/springconfig%E7%9A%8421.png"></p><h4 id="7-问题"><a href="#7-问题" class="headerlink" title="7,问题::"></a>7,问题::</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">上面<span class="hljs-number">3355</span>确实获取到了配置文件,但是如果此时配置文件修改了,<span class="hljs-number">3355</span>是获取不到的<br><span class="hljs-number">3344</span>可以实时获取到最新配置文件,但是<span class="hljs-number">3355</span>却获取不到<br>  除非重启服务<br></code></pre></td></tr></table></figure><h4 id="8-实现动态刷新"><a href="#8-实现动态刷新" class="headerlink" title="8,实现动态刷新:"></a><strong>8,实现动态刷新:</strong></h4><h5 id="1-修改3355-添加一个pom依赖"><a href="#1-修改3355-添加一个pom依赖" class="headerlink" title="1,修改3355,添加一个pom依赖:"></a>1,修改3355,添加一个pom依赖:</h5><p><img src="/images/springcloud-20/springconfig%E7%9A%8422.png"></p><h5 id="2-修改配置文件-添加一个配置"><a href="#2-修改配置文件-添加一个配置" class="headerlink" title="2,修改配置文件,添加一个配置:"></a>2,修改配置文件,添加一个配置:</h5><p><img src="/images/springcloud-20/springconfig%E7%9A%8423.png"></p><h5 id="3-修改controller"><a href="#3-修改controller" class="headerlink" title="3,修改controller:"></a>3,修改controller:</h5><p><img src="/images/springcloud-20/springconfig%E7%9A%8424.png"></p><h5 id="4-此时重启服务"><a href="#4-此时重启服务" class="headerlink" title="4,此时重启服务"></a>4,此时重启服务</h5><p><strong>此时3355还不可以动态获取</strong></p><p>因为此时,还需要==外部==发送post请求通知3355</p><p><img src="/images/springcloud-20/springconfig%E7%9A%8425.png"></p><p><strong>此时在刷新3355,发现可以获取到最新的配置文件了,这就实现了动态获取配置文件,因为3355并没有重启</strong></p><p>具体流程就是:</p><p>​            我们启动好服务后</p><p>​            运维人员,修改了配置文件,然后发送一个post请求通知3355</p><p>​            3355就可以获取最新配置文件</p><p><strong>问题:</strong></p><p>​        如果有多个客户端怎么办(3355,3356,3357…..)</p><p>​                        虽然可以使用shell脚本,循环刷新</p><p>​        但是,可不可以使用广播,一次通知??</p><p>​                    这些springconfig做不到,需要使用springcloud Bus消息总线</p><h1 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线:"></a>消息总线:</h1><h2 id="SpringCloud-Bus"><a href="#SpringCloud-Bus" class="headerlink" title="SpringCloud Bus:"></a>SpringCloud Bus:</h2><p><img src="/images/springcloud-20/springconfig%E7%9A%8426.png"></p><p><img src="/images/springcloud-20/springconfig%E7%9A%8427.png"></p><p><img src="/images/springcloud-20/springconfig%E7%9A%8431.png"></p><p>注意,这里年张图片,就代表两种广播方式</p><p>​            图1:        <strong>它是Bus直接通知给其中一个客户端,由这个客户端开始蔓延,传播给其他所有客户端</strong></p><p>​            图2:        它<strong>是通知给配置中心的服务端,有服务端广播给所有客户端</strong></p><p><strong>为什么被称为总线?</strong></p><p><img src="/images/springcloud-20/springconfig%E7%9A%8428.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">就是通过消息队列达到广播的效果<br>  我们要广播每个消息时,主要放到某个topic中,所有监听的节点都可以获取到<br></code></pre></td></tr></table></figure><h3 id="使用Bus"><a href="#使用Bus" class="headerlink" title="使用Bus:"></a>使用Bus:</h3><h4 id="1-配置rabbitmq环境"><a href="#1-配置rabbitmq环境" class="headerlink" title="1,配置rabbitmq环境:"></a>1,配置rabbitmq环境:</h4><p><img src="/images/springcloud-20/springconfig%E7%9A%8429.png"></p><h4 id="2-之前只有一个配置中心客户端-这里在创建一个"><a href="#2-之前只有一个配置中心客户端-这里在创建一个" class="headerlink" title="2,之前只有一个配置中心客户端,这里在创建一个"></a><strong>2,之前只有一个配置中心客户端,这里在创建一个</strong></h4><p>​        ==<strong>复制3355即可,创建为3366</strong>==</p><p><img src="/images/springcloud-20/springconfig%E7%9A%8430.png"></p><p>全部复制3355的即可</p><h4 id="2-使用Bus实现全局广播"><a href="#2-使用Bus实现全局广播" class="headerlink" title="2,使用Bus实现全局广播"></a>2,使用Bus实现全局广播</h4><p><strong>Bus广播有两种方式:</strong></p><p>​        ==就是上面两个图片的两种方式==</p><p><img src="/images/springcloud-20/springconfig%E7%9A%8432.png"></p><p><strong>这两种方式,第二种跟合适,因为:</strong></p><p>​            ==第一种的缺点:==</p><p><img src="/images/springcloud-20/springconfig%E7%9A%8433.png"></p><h4 id="配置第二种方式"><a href="#配置第二种方式" class="headerlink" title="配置第二种方式:"></a><strong>配置第二种方式:</strong></h4><h5 id="1-配置3344-配置中心服务端"><a href="#1-配置3344-配置中心服务端" class="headerlink" title="1,配置3344(配置中心服务端):"></a><strong>1,配置3344(配置中心服务端):</strong></h5><h6 id="1-修改配置文件-2"><a href="#1-修改配置文件-2" class="headerlink" title="1,修改配置文件:"></a>1,修改配置文件:</h6><p><img src="/images/springcloud-20/Bus%E7%9A%841.png"></p><h6 id="2-添加pom"><a href="#2-添加pom" class="headerlink" title="2,添加pom"></a>2,添加pom</h6><p><strong>springboot的监控组件,和消息总线</strong></p><p><img src="/images/springcloud-20/Bus%E7%9A%843.png"></p><p><img src="/images/springcloud-20/Bus%E7%9A%842.png"></p><h5 id="2-修改3355-配置中心的客户端"><a href="#2-修改3355-配置中心的客户端" class="headerlink" title="2,修改3355(配置中心的客户端)"></a>2,修改3355(配置中心的客户端)</h5><h6 id="1-pom-2"><a href="#1-pom-2" class="headerlink" title="1,pom:"></a>1,pom:</h6><p><img src="/images/springcloud-20/Bus%E7%9A%843.png"></p><p><img src="/images/springcloud-20/Bus%E7%9A%842.png" alt="Bus的2"></p><h6 id="2-配置文件-4"><a href="#2-配置文件-4" class="headerlink" title="2,配置文件:"></a>2,配置文件:</h6><p>==注意配置文件的名字,要改为bootstrap.yml==</p><p><img src="/images/springcloud-20/Bus%E7%9A%845.png"></p><p><img src="/images/springcloud-20/Bus%E7%9A%844" alt="image-20200415102708661"></p><h5 id="3-修改3366-也是配置中心的客户端"><a href="#3-修改3366-也是配置中心的客户端" class="headerlink" title="3,修改3366(也是配置中心的客户端)"></a>3,修改3366(也是配置中心的客户端)</h5><p>​            修改与3355是一模一样的</p><h5 id="4-测试-2"><a href="#4-测试-2" class="headerlink" title="4,测试"></a>4,测试</h5><p>启动7001,3344,3355,3366</p><p>此时修改GitHub上的配置文件</p><p>==此时只需要刷新3344,即可让3355,3366动态获取最新的配置文件==</p><p><img src="/images/springcloud-20/Bus%E7%9A%846.png"></p><p>其原理就是:</p><p><img src="/images/springcloud-20/Bus%E7%9A%847.png"></p><p><strong>所有客户端都监听了一个rabbitMq的topic,我们将信息放入这个topic,所有客户端都可以送到,从而实时更新</strong></p><h4 id="配置定点通知"><a href="#配置定点通知" class="headerlink" title="配置定点通知"></a>配置定点通知</h4><p>​        就是只通知部分服务,比如只通知3355,不通知3366</p><p><img src="/images/springcloud-20/Bus%E7%9A%848.png"></p><p><img src="/images/springcloud-20/Bus%E7%9A%849.png" alt="Bus的8"></p><p><strong>只通知3355</strong></p><p><img src="/images/springcloud-20/Bus%E7%9A%8411.png"></p><p>​    <img src="/images/springcloud-20/Bus%E7%9A%8412.png"></p><p><strong>可以看到,实际上就是通过==微服务的名称+端口号==进行指定</strong></p><h1 id="8-消息驱动"><a href="#8-消息驱动" class="headerlink" title="8,消息驱动:"></a>8,消息驱动:</h1><h2 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream:"></a>Spring Cloud Stream:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">现在一个很项目可能分为三部分:<br>前端---&gt;后端----&gt;大数据<br>而后端开发使用消息中间件,可能会使用RabbitMq<br>而大数据开发,一般都是使用Kafka,<br>那么一个项目中有多个消息中间件,对于程序员,因为人员都不友好<br></code></pre></td></tr></table></figure><p>而Spring Cloud Stream就类似jpa,屏蔽底层消息中间件的差异,程序员主要操作Spring Cloud Stream即可</p><p>​            不需要管底层是kafka还是rabbitMq</p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%841.png"></p><h3 id="什么是Spring-Cloud-Stream"><a href="#什么是Spring-Cloud-Stream" class="headerlink" title="==什么是Spring Cloud Stream=="></a>==什么是Spring Cloud Stream==</h3><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%842.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%843.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%844.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%845.png"></p><h3 id="Spring-Cloud-Stream是怎么屏蔽底层差异的"><a href="#Spring-Cloud-Stream是怎么屏蔽底层差异的" class="headerlink" title="==Spring Cloud Stream是怎么屏蔽底层差异的?=="></a>==<strong>Spring Cloud Stream是怎么屏蔽底层差异的?</strong>==</h3><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%846.png"></p><p><strong>绑定器:</strong></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%847.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%848.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%849.png"></p><h3 id="Spring-Cloud-Streamd-通信模式"><a href="#Spring-Cloud-Streamd-通信模式" class="headerlink" title="Spring Cloud Streamd 通信模式:"></a><strong>Spring Cloud Streamd 通信模式:</strong></h3><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8410.png"><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8411.png"></p><h3 id="Spring-Cloud-Stream的业务流程"><a href="#Spring-Cloud-Stream的业务流程" class="headerlink" title="Spring Cloud Stream的业务流程:"></a>Spring Cloud Stream的业务流程:</h3><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8412.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8414.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8413.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">类似flume中的channel,source,sink  估计是借鉴(抄袭)的<br>  source用于获取数据(要发送到mq的数据)<br>  channel类似SpringCloudStream中的中间件,用于存放source接收到的数据,或者是存放binder拉取的数据<br></code></pre></td></tr></table></figure><h3 id="常用注解和api"><a href="#常用注解和api" class="headerlink" title="常用注解和api:"></a>常用注解和api:</h3><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8415.png"></p><h3 id="使用SpringCloudStream"><a href="#使用SpringCloudStream" class="headerlink" title="使用SpringCloudStream:"></a>使用SpringCloudStream:</h3><p>需要创建三个项目,一个生产者,两个消费者</p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8416.png"></p><h3 id="1-创建生产者"><a href="#1-创建生产者" class="headerlink" title="1,创建生产者"></a>1,创建生产者</h3><h4 id="1-pom-3"><a href="#1-pom-3" class="headerlink" title="1,pom"></a>1,pom</h4><h4 id="2-配置文件-5"><a href="#2-配置文件-5" class="headerlink" title="2,配置文件"></a>2,配置文件</h4><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8417" alt="image-20200415114816133"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8418.png"></p><h4 id="3-主启动类-5"><a href="#3-主启动类-5" class="headerlink" title="3,主启动类"></a>3,主启动类</h4><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8419.png"></p><h4 id="4-service和实现类"><a href="#4-service和实现类" class="headerlink" title="4,service和实现类"></a>4,service和实现类</h4><p>service定义发送消息</p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8420.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8421.png"></p><p><strong>这里,就会调用send方法,将消息发送给channel,</strong></p><p>​                <strong>然后channel将消费发送给binder,然后发送到rabbitmq中</strong></p><h4 id="5-controller-2"><a href="#5-controller-2" class="headerlink" title="5,controller"></a>5,controller</h4><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8422.png"></p><h4 id="6-可以测试"><a href="#6-可以测试" class="headerlink" title="6,可以测试"></a>6,可以测试</h4><p><strong>启动rabbitmq</strong></p><p><strong>启动7001,8801</strong></p><p>​        确定8801后,会在rabbitmq中创建一个Exchange,就是我们配置文件中配置的exchange</p><p><strong>访问8801的/sendMessage</strong></p><h3 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者:"></a>创建消费者:</h3><h4 id="1-pom文件-2"><a href="#1-pom文件-2" class="headerlink" title="1,pom文件"></a>1,pom文件</h4><h4 id="2-配置文件-6"><a href="#2-配置文件-6" class="headerlink" title="2,配置文件"></a>2,配置文件</h4><p>==<strong>这里排版一点问题</strong>==</p><p><strong>==input==就表示,当前服务是一个消费者,需要消费消息,下面就是指定消费哪个Exchange中的消息</strong></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8423.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8424.png"></p><h4 id="3-主启动类-6"><a href="#3-主启动类-6" class="headerlink" title="3,主启动类"></a>3,主启动类</h4><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8425.png"></p><h4 id="4-业务类-消费数据"><a href="#4-业务类-消费数据" class="headerlink" title="4,业务类(消费数据)"></a>4,业务类(消费数据)</h4><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8426.png"></p><p><strong>生产者发送消息时,使用send方法发送,send方法发送的是一个个Message,里面封装了数据</strong></p><h4 id="5-测试"><a href="#5-测试" class="headerlink" title="5,测试:"></a>5,测试:</h4><p>启动7001.8801.8802</p><p><strong>此时使用生产者生产消息</strong></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8427.png"></p><p>==可以看到,消费者已经接收到消息了==</p><h3 id="创建消费者2"><a href="#创建消费者2" class="headerlink" title="创建消费者2"></a>创建消费者2</h3><p>创建8803,</p><p>==与8802创建一模一样,就不写了==</p><p><strong>创建8803主要是为了演示重复消费等问题</strong></p><p>…</p><p>….</p><p>…</p><h3 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="==重复消费问题:=="></a>==重复消费问题:==</h3><p>此时启动7001.8801.8802.8803</p><p>此时生产者生产一条消息</p><p>但是此时查询消费者,发现8802,8803==都消费到了同一条数据==</p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8428.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8429.png"></p><h4 id="1-自定义分组"><a href="#1-自定义分组" class="headerlink" title="1,自定义分组"></a>1,自定义分组</h4><p><strong>修改8802,8803的配置文件</strong></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8430.png"></p><p>![](/images/springcloud-20/SpringCloudStream的31 - 副本.png)</p><p><strong>现在将8802,8803都分到了A组</strong></p><p>然后去重启02,03</p><p><strong>然后此时生产者生产两条消息</strong></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8433.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8434.png"></p><p><img src="/images/springcloud-20/SpringCloudStream%E7%9A%8435.png"></p><p><strong>可以看到,每人只消费了一条消息,并且没有重复消费</strong></p><h3 id="持久化问题"><a href="#持久化问题" class="headerlink" title="持久化问题:"></a>持久化问题:</h3><p>就是当服务挂了,怎么消费没有消费的数据??</p><p>这里,先将8802移除A组,</p><p>​        然后将02,03服务关闭</p><p>此时生产者开启,发送3条消息</p><p>​        此时重启02,03</p><p>​        可以看到,当02退出A组后,它就获取不到在它宕机的时间段内的数据</p><p>​        但是03重启后,直接获取到了宕机期间它没有消费的数据,并且消费了</p><p>总结:<br>        也就是,当我们没有配置分组时,会出现消息漏消费的问题</p><p>​        而配置分组后,我们可以自动获取未消费的数据</p><h1 id="9-链路追踪"><a href="#9-链路追踪" class="headerlink" title="9,链路追踪:"></a>9,链路追踪:</h1><h2 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h2><p><strong>sleuth要解决的问题:</strong></p><p><img src="/images/springcloud-20/sleuth%E7%9A%841.png"></p><p><strong>而来sleuth就是用于追踪每个请求的整体链路</strong></p><p><img src="/images/springcloud-20/sleuth%E7%9A%842.png"></p><h3 id="使用sleuth"><a href="#使用sleuth" class="headerlink" title="使用sleuth:"></a>使用sleuth:</h3><h4 id="1-安装zipkin"><a href="#1-安装zipkin" class="headerlink" title="1,安装zipkin:"></a>1,安装zipkin:</h4><p><img src="/images/springcloud-20/sleuth%E7%9A%843.png"></p><p><strong>运行jar包</strong></p><p>​            java -jar xxxx.jar</p><p><strong>然后就可以访问web界面,  默认zipkin监听的端口是9411</strong></p><p>​            localhost:9411/zipkin/</p><p><img src="/images/springcloud-20/sleuth%E7%9A%844.png"></p><p><strong>一条链路完整图片:</strong></p><p><img src="/images/springcloud-20/sleuth%E7%9A%845.png"></p><p><strong>精简版:</strong></p><p><img src="/images/springcloud-20/sleuth%E7%9A%846.png"></p><p><strong>可以看到,类似链表的形式</strong></p><h4 id="2-使用sleuth"><a href="#2-使用sleuth" class="headerlink" title="2,使用sleuth:"></a>2,使用sleuth:</h4><p>不需要额外创建项目,使用之前的8001和order的80即可</p><h5 id="1-修改8001"><a href="#1-修改8001" class="headerlink" title="1,修改8001"></a>1,修改8001</h5><p><strong>引入pom:</strong></p><p><img src="/images/springcloud-20/sleuth%E7%9A%847.png"></p><p>这个包虽然叫zipkin但是,里面包含了zpikin与sleuth</p><p><strong>修改配置文件:</strong></p><p><img src="/images/springcloud-20/sleuth%E7%9A%848.png"></p><h5 id="2-修改80"><a href="#2-修改80" class="headerlink" title="2,修改80"></a>2,修改80</h5><p><strong>添加pom</strong></p><p>与上面是一样的</p><p><strong>添加配置</strong>:</p><p>与上面也是一样的</p><h5 id="3-测试-1"><a href="#3-测试-1" class="headerlink" title="3,测试:"></a>3,测试:</h5><p>启动7001.8001,80,9411</p><p><img src="/images/springcloud-20/sleuth%E7%9A%849.png"></p><h1 id="10-Spring-CloudAlibaba"><a href="#10-Spring-CloudAlibaba" class="headerlink" title="10,Spring CloudAlibaba:"></a>10,Spring CloudAlibaba:</h1><p><strong>之所以有Spring CloudAlibaba,是因为Spring Cloud Netflix项目进入维护模式</strong></p><p>​        <strong>也就是,就不是不更新了,不会开发新组件了</strong></p><p>​        <strong>所以,某些组件都有代替版了,比如Ribbon由Loadbalancer代替,等等</strong></p><p>==支持的功能==</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%841.png"></p><p>几乎可以将之前的Spring Cloud代替</p><p>==具体组件==:<br><img src="/images/springcloud-20/Alibaba%E7%9A%842.png"></p><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos:"></a>Nacos:</h2><p><strong>服务注册和配置中心的组合</strong></p><p>​            Nacos=erueka+config+bus</p><h3 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos:"></a>安装Nacos:</h3><p>需要java8  和 Mavne</p><p><strong>1,到github上下载安装包</strong></p><p>​        解压安装包</p><p><strong>2,启动Nacos</strong></p><p>​        在bin下,进入cod</p><p>​        ./startup.cmd</p><p><strong>3,访问Nacos</strong></p><p>​        Nacos默认监听8848</p><p>​        localhost:8848/nacos</p><p>​        账号密码:默认都是nacos</p><h3 id="使用Nacos"><a href="#使用Nacos" class="headerlink" title="使用Nacos:"></a>使用Nacos:</h3><p>新建pay模块</p><p>​        <strong>现在不需要额外的服务注册模块了,Nacos单独启动了</strong></p><p>名字: cloudalibaba-pay-9001</p><h4 id="1-pom-4"><a href="#1-pom-4" class="headerlink" title="1,pom"></a>1,pom</h4><p>父项目管理alibaba的依赖:</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%844.png"></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%843.png"></p><p>==9001的pom==:</p><p>​            另外一个文件…..</p><h4 id="2-配置文件-7"><a href="#2-配置文件-7" class="headerlink" title="2,配置文件"></a>2,配置文件</h4><p><img src="/images/springcloud-20/Alibaba%E7%9A%845.png"></p><h4 id="3-启动类"><a href="#3-启动类" class="headerlink" title="3,启动类"></a>3,启动类</h4><p><img src="/images/springcloud-20/Alibaba%E7%9A%846.png"></p><h4 id="4-controller-1"><a href="#4-controller-1" class="headerlink" title="4,controller:"></a>4,controller:</h4><p><img src="/images/springcloud-20/Alibaba%E7%9A%847.png"></p><h4 id="5-测试-1"><a href="#5-测试-1" class="headerlink" title="5,测试"></a>5,测试</h4><p>启动9001</p><p>然后查看Nacos的web界面,可以看到9001已经注册成功</p><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="创建其他Pay模块"><a href="#创建其他Pay模块" class="headerlink" title="创建其他Pay模块"></a>创建其他Pay模块</h3><p>​        额外在创建9002,9003</p><p>​        直接复制上面的即可</p><h3 id="创建order模块"><a href="#创建order模块" class="headerlink" title="创建order模块"></a>创建order模块</h3><p>名字:  cloudalibaba-order-83</p><h4 id="1-pom-5"><a href="#1-pom-5" class="headerlink" title="1,pom"></a>1,pom</h4><p><strong>为什么Nacos支持负载均衡?</strong></p><p>​                Nacos直接集成了Ribon,所以有负载均衡</p><h4 id="2-配置文件-8"><a href="#2-配置文件-8" class="headerlink" title="2,配置文件"></a>2,配置文件</h4><p><img src="/images/springcloud-20/Alibaba%E7%9A%848.png"></p><p><strong>这个server-url的作用是,我们在controller,需要使用RestTempalte远程调用9001,</strong></p><p>​        <strong>这里是指定9001的地址</strong></p><h4 id="3-主启动类-7"><a href="#3-主启动类-7" class="headerlink" title="3,主启动类"></a>3,主启动类</h4><p><img src="/images/springcloud-20/Alibaba%E7%9A%849.png"></p><h4 id="4-编写配置类"><a href="#4-编写配置类" class="headerlink" title="4,编写配置类"></a>4,编写配置类</h4><p>​    ==因为Naocs要使用Ribbon进行负载均衡,那么就需要使用RestTemplate==</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8410.png"></p><h4 id="5-controller-3"><a href="#5-controller-3" class="headerlink" title="5,controller:"></a>5,controller:</h4><p><img src="/images/springcloud-20/Alibaba%E7%9A%8411.png"></p><h4 id="6-测试-1"><a href="#6-测试-1" class="headerlink" title="6,测试"></a>6,测试</h4><p>启动83,访问9001,9002,可以看到,实现了负载均衡</p><h3 id="Nacos与其他服务注册的对比"><a href="#Nacos与其他服务注册的对比" class="headerlink" title="Nacos与其他服务注册的对比"></a>Nacos与其他服务注册的对比</h3><p>Nacos它既可以支持CP,也可以支持AP,可以切换</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8412.png"></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8413.png"></p><p>==下面这个curl命令,就是切换模式==</p><h3 id="使用Nacos作为配置中心"><a href="#使用Nacos作为配置中心" class="headerlink" title="使用Nacos作为配置中心:"></a>使用Nacos作为配置中心:</h3><p><img src="/images/springcloud-20/Alibaba%E7%9A%8414.png"></p><p><strong>==需要创建配置中心的客户端模块==</strong></p><p>cloudalibaba-Nacos-config-client-3377</p><h4 id="1-pom-6"><a href="#1-pom-6" class="headerlink" title="1,pom"></a>1,pom</h4><h4 id="2-配置文件-9"><a href="#2-配置文件-9" class="headerlink" title="2,配置文件"></a>2,配置文件</h4><p>这里需要配置两个配置文件,application.ymk和bootstarp.yml</p><p>​            主要是为了可以与spring clodu config无缝迁移</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8415.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">可以看到<br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/Alibaba%E7%9A%8416.png"></p><h4 id="3-主启动类-8"><a href="#3-主启动类-8" class="headerlink" title="3,主启动类"></a>3,主启动类</h4><p><img src="/images/springcloud-20/Alibaba%E7%9A%8418.png"></p><h4 id="4-controller-2"><a href="#4-controller-2" class="headerlink" title="4,controller"></a>4,controller</h4><p><img src="/images/springcloud-20/Alibaba%E7%9A%8417.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">可以看到,这里也添加了<span class="hljs-meta">@RefreshScope</span><br>  之前在Config配置中心,也是添加这个注解实现动态刷新的<br>  <br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/Alibaba%E7%9A%8419.png"></p><h4 id="5-在Nacos添加配置信息"><a href="#5-在Nacos添加配置信息" class="headerlink" title="5,在Nacos添加配置信息:"></a>5,在Nacos添加配置信息:</h4><p>==<strong>Nacos的配置规则:</strong>==</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8420.png"></p><p><strong>配置规则,就是我们在客户端如何指定读取配置文件,配置文件的命名的规则</strong></p><p>默认的命名方式:</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8421.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">prefix:<br>默认就是当前服务的服务名称<br> 也可以通过spring.cloud.necos.config.prefix配置<br>spring.profile.active:<br>就是我们在application.yml中指定的,当前是开发环境还是测试等环境<br>    这个可以不配置,如果不配置,那么前面的 -  也会没有<br>file-extension<br>     就是当前文件的格式(后缀),目前只支持yml和properties<br></code></pre></td></tr></table></figure><p><img src="/images/springcloud-20/Alibaba%E7%9A%8424.png"></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8425.png"></p><p>==在web UI上创建配置文件:==</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8422.png"></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8423.png"></p><p>注意,DataId就是配置文件名字:</p><p>​        名字一定要按照上面的==规则==命名,否则客户端会读取不到配置文件</p><h4 id="6-测试-2"><a href="#6-测试-2" class="headerlink" title="6,测试"></a>6,测试</h4><p>重启3377客户端</p><p>访问3377</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8426.png"></p><p><strong>拿到了配置文件中的值</strong></p><h4 id="7-注意默认就开启了自动刷新"><a href="#7-注意默认就开启了自动刷新" class="headerlink" title="7,注意默认就开启了自动刷新"></a>7,注意默认就开启了自动刷新</h4><p>此时我们修改了配置文件</p><p>客户端是可以立即更新的</p><p>​            因为Nacos支持Bus总线,会自动发送命令更新所有客户端</p><h3 id="Nacos配置中心之分类配置"><a href="#Nacos配置中心之分类配置" class="headerlink" title="Nacos配置中心之分类配置:"></a>Nacos配置中心之分类配置:</h3><p><img src="/images/springcloud-20/Alibaba%E7%9A%8427.png"></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8428.png"></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8429.png"></p><p>NameSpace默认有一个:public名称空间</p><p>这三个类似java的: 包名 + 类名 + 方法名</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8430.png"></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8431.png"></p><h4 id="1-配置不同DataId"><a href="#1-配置不同DataId" class="headerlink" title="1,配置不同DataId:"></a>1,配置不同DataId:</h4><p><img src="/images/springcloud-20/Alibaba%E7%9A%8432.png"></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8433.png"></p><p>​    ==通过配置文件,实现多环境的读取:==</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8434.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">此时,改为dev,就会读取dev的配置文件,改为test,就会读取test的配置文件<br></code></pre></td></tr></table></figure><h4 id="2-配置不同的GroupID"><a href="#2-配置不同的GroupID" class="headerlink" title="2,配置不同的GroupID:"></a>2,配置不同的GroupID:</h4><p>直接在新建配置文件时指定组</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8435.png"></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8436.png"></p><p>==在客户端配置,使用指定组的配置文件:==</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8437.png"></p><p><strong>这两个配置文件都要修改</strong></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8438.png"></p><p>​    </p><p>重启服务,即可</p><h4 id="配置不同的namespace"><a href="#配置不同的namespace" class="headerlink" title="配置不同的namespace:"></a>配置不同的namespace:</h4><p><img src="/images/springcloud-20/Alibaba%E7%9A%8439.png"></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8442.png"></p><p>==客户端配置使用不同名称空间:==</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8441.png"></p><p><strong>要通过命名空间id指定</strong></p><p>OK,测试</p><h3 id="Nacos集群和持久化配置"><a href="#Nacos集群和持久化配置" class="headerlink" title="Nacos集群和持久化配置:"></a>Nacos集群和持久化配置:</h3><p><img src="/images/springcloud-20/Alibaba%E7%9A%8445.png"></p><p>Nacos默认有自带嵌入式数据库,derby,但是如果做集群模式的话,就不能使用自己的数据库</p><p>​            不然每个节点一个数据库,那么数据就不统一了,需要使用外部的mysql</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8443.png"></p><h4 id="1-单机版-切换mysql数据库"><a href="#1-单机版-切换mysql数据库" class="headerlink" title="1,单机版,切换mysql数据库:"></a>1,单机版,切换mysql数据库:</h4><p>​                    <strong>将nacos切换到使用我们自己的mysql数据库:</strong></p><p><strong>1,nacos默认自带了一个sql文件,在nacos安装目录下</strong></p><p>​            将它放到我们的mysql执行</p><p><strong>2,修改Nacos安装目录下的安排application.properties,添加:</strong></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8446.png"></p><p><strong>3,此时可以重启nacos,那么就会改为使用我们自己的mysql</strong></p><h4 id="Linux上配置Nacos集群-Mysql数据库"><a href="#Linux上配置Nacos集群-Mysql数据库" class="headerlink" title="Linux上配置Nacos集群+Mysql数据库"></a>Linux上配置Nacos集群+Mysql数据库</h4><p>==官方架构图:==</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8445.png"></p><p><strong>需要一个Nginx作为VIP</strong></p><p>1,下载安装Nacos的Linux版安装包</p><p>2,进入安装目录,现在执行自带的sql文件</p><p>​            进入mysql,执行sql文件</p><p>3.修改配置文件,切换为我们的mysql</p><p>​            就是上面windos版要修改的几个属性</p><p>4,修改cluster.conf,指定哪几个节点是Nacos集群</p><p>​            这里使用3333,4444,5555作为三个Nacos节点监听的端口</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8447.png"></p><p>5,我们这里就不配置在不同节点上了,就放在一个节点上</p><p>​            既然要在一个节点上启动不同Nacos实例,就要修改startup.sh,使其根据不同端口启动不同Nacos实例</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8448.png"></p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8449.png"></p><p>可以看到,这个脚本就是通过jvm启动nacos</p><p>​        所以我们最后修改的就是,nohup java -Dserver.port=3344</p><p>6,配置Nginx:</p><p>​            <img src="/images/springcloud-20/Alibaba%E7%9A%8450.png"></p><p>7,启动Nacos:<br>            ./startup.sh -p 3333</p><p>​            ./startup.sh -p 4444</p><p>​            ./startup.sh -p 5555</p><p>7,启动nginx</p><p>8,测试:</p><p>​        访问192.168.159.121:1111</p><p>​        如果可以进入nacos的web界面,就证明安装成功了</p><p>9,将微服务注册到Nacos集群:<br><img src="/images/springcloud-20/Alibaba%E7%9A%8451.png"></p><p>10,进入Nacos的web界面</p><p>​        可以看到,已经注册成功</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8452.png"></p><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel:"></a>Sentinel:</h2><p>实现熔断与限流,就是Hystrix</p><p><img src="/images/springcloud-20/Alibaba%E7%9A%8453.png"></p><p>​    <img src="/images/springcloud-20/Alibaba%E7%9A%8454.png"></p><h3 id="使用sentinel"><a href="#使用sentinel" class="headerlink" title="==使用sentinel:=="></a>==使用sentinel:==</h3><p>1,下载sentinel的jar包</p><p>2,运行sentinel</p><p>​        由于是一个jar包,所以可以直接java -jar运行    </p><p>​        注意,默认sentinel占用8080端口</p><p>3,访问sentinel</p><p>​        localhost:8080</p><h3 id="微服务整合sentinel"><a href="#微服务整合sentinel" class="headerlink" title="微服务整合sentinel:"></a>微服务整合sentinel:</h3><h5 id="1-启动Nacos"><a href="#1-启动Nacos" class="headerlink" title="1,启动Nacos"></a>1,启动Nacos</h5><h5 id="2-新建一个项目-8401-主要用于配置sentinel"><a href="#2-新建一个项目-8401-主要用于配置sentinel" class="headerlink" title="2,新建一个项目,8401,主要用于配置sentinel"></a>2,新建一个项目,8401,主要用于配置sentinel</h5><ol><li><p> pom</p></li><li><p>  配置文件</p></li></ol><pre><code>![](/images/springcloud-20/Alibaba的55.png)</code></pre><ol start="3"><li>  主启动类</li></ol><pre><code>![](/images/springcloud-20/Alibaba的56.png)</code></pre><ol start="4"><li>  controller/</li></ol><pre><code>![](/images/springcloud-20/sentinel的1.png)</code></pre><ol start="5"><li>  到这里就可以启动8401</li></ol><pre><code>​    此时我们到sentinel中查看,发现并8401的任何信息​    是因为,sentinel是懒加载,需要我们执行一次访问,才会有信息​    访问localhost/8401/testA![](/images/springcloud-20/sentinel的2.png)</code></pre><ol start="6"><li>  可以看到.已经开始监听了</li></ol><p>​    </p><h3 id="sentinel的流控规则"><a href="#sentinel的流控规则" class="headerlink" title="sentinel的流控规则"></a>sentinel的流控规则</h3><p>流量限制控制规则</p><p><img src="/images/springcloud-20/sentinel%E7%9A%847.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%843.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%844.png"></p><p>==流控模式==:</p><ol><li>  直接快速失败</li></ol><pre><code>![](/images/springcloud-20/sentinel的9.png)![](/images/springcloud-20/sentinel的5.png)   ==直接失败的效果:==![](/images/springcloud-20/sentinel的6.png)</code></pre><ol start="2"><li><p>线程数:</p><p> ​        <img src="/images/springcloud-20/sentinel%E7%9A%848.png"></p><p> ​    <img src="/images/springcloud-20/sentinel%E7%9A%8410.png"></p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">比如<span class="hljs-selector-tag">a</span>请求过来,处理很慢,在一直处理,此时<span class="hljs-selector-tag">b</span>请求又过来了<br>此时因为<span class="hljs-selector-tag">a</span>占用一个线程,此时要处理<span class="hljs-selector-tag">b</span>请求就只有额外开启一个线程<br>那么就会报错<br></code></pre></td></tr></table></figure><p> <img src="/images/springcloud-20/sentinel%E7%9A%8411.png"></p></li><li><p>关联:</p><p>  <img src="/images/springcloud-20/sentinel%E7%9A%8412.png"></p><p>  ==应用场景:  比如<strong>支付接口</strong>达到阈值,就要限流下<strong>订单的接口</strong>,防止一直有订单==</p><p>  <img src="/images/springcloud-20/sentinel%E7%9A%8413.png"></p><p>  <strong>当testA达到阈值,qps大于1,就让testB之后的请求直接失败</strong></p><p>  可以使用postman压测</p></li></ol><p>​    </p><ol start="4"><li><p>链路:<br>  多个请求调用同一个微服务</p></li><li><p>  预热Warm up:</p></li></ol><pre><code>​     ![](/images/springcloud-20/sentinel的14.png)  ![](/images/springcloud-20/sentinel的15.png) ![](/images/springcloud-20/sentinel的16.png) ==应用场景== ![](/images/springcloud-20/sentinel的17.png)</code></pre><ol start="6"><li>  排队等待:</li></ol><pre><code>![](/images/springcloud-20/sentinel的18.png)![](/images/springcloud-20/sentinel的19.png)</code></pre><h3 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则:"></a>降级规则:</h3><p><strong>就是熔断降级</strong></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8421.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8420.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8422.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8423.png"></p><h4 id="1-RT配置"><a href="#1-RT配置" class="headerlink" title="1,RT配置:"></a>1,RT配置:</h4><p>新增一个请求方法用于测试</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8424.png"></p><p>==配置RT:==</p><p>​                这里配置的PT,默认是秒级的平均响应时间</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8425.png"></p><p>默认计算平均时间是: 1秒类进入5个请求,并且响应的平均值超过阈值(这里的200ms),就报错]</p><p>​            1秒5请求是Sentinel默认设置的</p><p>==测试==</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8427.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8426.png"></p><p><strong>默认熔断后.就直接抛出异常</strong></p><h4 id="2-异常比例"><a href="#2-异常比例" class="headerlink" title="2,异常比例:"></a>2,异常比例:</h4><p><img src="/images/springcloud-20/sentinel%E7%9A%8428.png"></p><p>修改请求方法</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8429.png"></p><p>配置:</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8431.png"></p><p>==如果没触发熔断,这正常抛出异常==:</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8432.png"></p><p>==触发熔断==:</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8433.png"></p><h4 id="3-异常数"><a href="#3-异常数" class="headerlink" title="3, 异常数:"></a>3, 异常数:</h4><p><img src="/images/springcloud-20/sentinel%E7%9A%8434.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8435.png"></p><p>一分钟之内,有5个请求发送异常,进入熔断</p><h3 id="热点规则"><a href="#热点规则" class="headerlink" title="热点规则:"></a>热点规则:</h3><p><img src="/images/springcloud-20/sentinel%E7%9A%8436.png"></p><p>​    <img src="/images/springcloud-20/sentinel%E7%9A%8437.png"></p><p>比如:</p><p>​            localhost:8080/aa?name=aa</p><p>​            localhost:8080/aa?name=b’b</p><p>​            加入两个请求中,带有参数aa的请求访问频次非常高,我们就现在name==aa的请求,但是bb的不限制</p><p>==如何自定义降级方法,而不是默认的抛出异常?==</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8438.png"></p><p><strong>使用@SentinelResource直接实现降级方法,它等同Hystrix的@HystrixCommand</strong></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8439.png"></p><p>==定义热点规则:==</p><p> <img src="/images/springcloud-20/sentinel%E7%9A%8440.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8442.png"></p><p><strong>此时我们访问/testHotkey并且带上才是p1</strong></p><p>​            如果qps大于1,就会触发我们定义的降级方法</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8441.png"></p><p><strong>但是我们的参数是P2,就没有问题</strong></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8444.png"></p><p>只有带了p1,才可能会触发热点限流</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8443.png"></p><h4 id="2-设置热点规则中的其他选项"><a href="#2-设置热点规则中的其他选项" class="headerlink" title="2,设置热点规则中的其他选项:"></a>2,设置热点规则中的其他选项:</h4><p><img src="/images/springcloud-20/sentinel%E7%9A%8445.png"></p><p><strong>需求:</strong></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8446.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8447.png"></p><p>==测试==</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8448.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8449.png"></p><p><strong>注意:</strong></p><p>参数类型只支持,8种基本类型+String类</p><p>==注意:==</p><p>如果我们程序出现异常,是不会走blockHander的降级方法的,因为这个方法只配置了热点规则,没有配置限流规则</p><p>我们这里配置的降级方法是sentinel针对热点规则配置的</p><p>只有触发热点规则才会降级</p><p><img src="/images/springcloud-20/sentinel%E7%9A%8450.png"></p><h3 id="3-系统规则"><a href="#3-系统规则" class="headerlink" title="3,系统规则:"></a>3,系统规则:</h3><p>系统自适应限流:<br>            从整体维度对应用入口进行限流</p><p>对整体限流,比如设置qps到达100,这里限流会限制整个系统不可以</p><p><em><img src="/images/springcloud-20/sentinel%E7%9A%8451.png"></em></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8452.png"></p><p>==测试==:<br><img src="/images/springcloud-20/sentinel%E7%9A%8453.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%8454.png"></p><h3 id="SentinelResource注解"><a href="#SentinelResource注解" class="headerlink" title="@SentinelResource注解:"></a>@SentinelResource注解:</h3><p><strong>用于配置降级等功能</strong></p><p>1,环境搭建</p><ol><li><p>为8401添加依赖</p><p> 添加我们自己的commone包的依赖</p><p> <img src="/images/springcloud-20/sentinel%E7%9A%8455.png"></p></li><li><p>  额外创建一个controller类</p></li></ol><pre><code>​     ![](/images/springcloud-20/sentinel的56.png) </code></pre><ol start="3"><li>  配置限流</li></ol><pre><code>**注意,我们这里配置规则,资源名指定的是@SentinelResource注解value的值,****这样也是可以的,也就是不一定要指定访问路径**![](/images/springcloud-20/sentinel的57.png)</code></pre><ol start="4"><li>  测试.</li></ol><pre><code>可以看到已经进入降级方法了![](/images/springcloud-20/sentinel的58.png)</code></pre><ol start="5"><li>  ==此时我们关闭8401服务==</li></ol><pre><code>可以看到,这些定义的规则是临时的,关闭服务,规则就没有了![](/images/springcloud-20/sentinel的59.png)</code></pre><p><strong>可以看到,上面配置的降级方法,又出现Hystrix遇到的问题了</strong></p><p>​            降级方法与业务方法耦合</p><p>​            每个业务方法都需要对应一个降级方法</p><h4 id="自定义限流处理逻辑"><a href="#自定义限流处理逻辑" class="headerlink" title="自定义限流处理逻辑:"></a>自定义限流处理逻辑:</h4><ol><li><p>==单独创建一个类,用于处理限流==</p><p> <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%841.png"></p></li><li><p>==在controller中,指定使用自定义类中的方法作为降级方法==</p><p> <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%842.png"></p></li><li><p>==Sentinel中定义流控规则==:</p><p>  这里资源名,是以url指定,也可以使用@SentinelResource注解value的值指定</p><p>  <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%845.png"></p></li><li><p>==测试==:</p><p> <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%843.png"></p></li><li><p>==整体==:</p><p> <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%844.png"></p></li><li></li></ol><h4 id="SentinelResource注解的其他属性"><a href="#SentinelResource注解的其他属性" class="headerlink" title="@SentinelResource注解的其他属性:"></a>@SentinelResource注解的其他属性:</h4><p><img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%847.png"></p><p><img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%846.png"></p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断:"></a>服务熔断:</h3><ol><li><p> <strong>启动nacos和sentinel</strong></p></li><li><p>  <strong>新建两个pay模块  9003和9004</strong></p></li></ol><pre><code>1.   pom2.   配置文件    ![](/images/springcloud-20/sentinel的的8.png)*3.   主启动类     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PaymentMain9003</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(PaymentMain9003.class,args);<br>    &#125;<br>&#125;<br> <br><br></code></pre></td></tr></table></figure>4.   controller    ![](/images/springcloud-20/sentinel的的9.png)     **然后启动9003.9004**</code></pre><ol start="3"><li>  <strong>新建一个order-84消费者模块:</strong></li></ol><pre><code>1.   pom    与上面的pay一模一样2.   配置文件    ![](/images/springcloud-20/sentinel的的10.png)3.   主启动类    ![](/images/springcloud-20/sentinel的的11.png)4.  配置类    ![](/images/springcloud-20/sentinel的的12.png)5.   controller    ![](/images/springcloud-20/sentinel的的13.png)    6.   **==为业务方法添加fallback来指定降级方法==**:    ![](/images/springcloud-20/sentinel的的14.png)    ​    ==重启order==    测试:    ![](/images/springcloud-20/sentinel的的15.png)          ==所以,fallback是用于管理异常的,当业务方法发生异常,可以降级到指定方法==    ​            注意,我们这里==并没有使用sentinel配置任何规则==,但是却降级成功,就是因为    ​            fallback是用于管理异常的,当业务方法发生异常,可以降级到指定方法==    7.   **==为业务方法添加blockHandler,看看是什么效果==**     ![](/images/springcloud-20/sentinel的的16.png)     **重启84,访问业务方法:**    ![](/images/springcloud-20/sentinel的的17.png)     可以看到.,直接报错了,并没有降级    ​                也就是说,blockHandler==只对sentienl定义的规则降级==     8.   **==如果fallback和blockHandler都配置呢?==**]     ![](/images/springcloud-20/sentinel的的18.png)     **设置qps规则,阈值1**     ![](/images/springcloud-20/sentinel的的19.png)     ==测试:==    ![](/images/springcloud-20/sentinel的的20.png)          可以看到,当两个都同时生效时,==blockhandler优先生效==9.  **==@SentinelResource还有一个属性,exceptionsToIgnore==**     ![](/images/springcloud-20/sentinel的的21.png)     **exceptionsToIgnore指定一个异常类,**    ​                    **表示如果当前方法抛出的是指定的异常,不降级,直接对用户抛出异常**     ![](/images/springcloud-20/sentinel的的22.png)          </code></pre><h3 id="sentinel整合ribbon-openFeign-fallback"><a href="#sentinel整合ribbon-openFeign-fallback" class="headerlink" title="sentinel整合ribbon+openFeign+fallback"></a>sentinel整合ribbon+openFeign+fallback</h3><ol><li><p>修改84模块,使其支持feign</p><ol><li><p>pom</p><p> <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%8423.png"></p></li><li><p>配置文件</p><p> <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%8424.png"></p></li><li><p>主启动类,也要修改</p><p> <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%8425.png"></p></li><li><p>创建远程调用pay模块的接口</p><p> <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%8426.png"></p></li><li><p>创建这个接口的实现类,用于降级</p><p> <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%8427.png"></p></li><li><p>  再次修改接口,指定降级类</p></li></ol><pre><code> ![](/images/springcloud-20/sentinel的的28.png)</code></pre><ol start="7"><li>  controller添加远程调用</li></ol><pre><code> ![](/images/springcloud-20/sentinel的的29.png)</code></pre><ol start="8"><li><p>测试</p><p> 启动9003,84</p></li><li><p>  测试,如果关闭9003.看看84会不会降级</p></li></ol><pre><code> ![](/images/springcloud-20/sentinel的的30.png) **可以看到,正常降级了** </code></pre></li></ol><p><strong>熔断框架比较</strong></p><p><img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%8431.png"></p><h3 id="sentinel持久化规则"><a href="#sentinel持久化规则" class="headerlink" title="sentinel持久化规则"></a>sentinel持久化规则</h3><p>默认规则是临时存储的,重启sentinel就会消失</p><p><img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%8432.png"></p><p><strong>这里以之前的8401为案例进行修改:</strong></p><ol><li><p>修改8401的pom</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">添加:<br><span class="hljs-comment">&lt;!-- SpringCloud ailibaba sentinel-datasource-nacos 持久化需要用到--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> <br></code></pre></td></tr></table></figure></li><li><p>  修改配置文件:</p></li></ol><pre><code>添加: ![](/images/springcloud-20/sentinel的的33.png) **实际上就是指定,我们的规则要保证在哪个名称空间的哪个分组下**             这里没有指定namespace, 但是是可以指定的​            **注意,这里的dataid要与8401的服务名一致**</code></pre><ol start="3"><li><p><strong>在nacos中创建一个配置文件,dataId就是上面配置文件中指定的</strong></p><p>  <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%8434.png"></p><p>  ==json中,这些属性的含义:==</p></li></ol><pre><code>​    ![](/images/springcloud-20/sentinel的的35.png) </code></pre><ol start="4"><li><p>启动8401:</p><p>  <img src="/images/springcloud-20/sentinel%E7%9A%84%E7%9A%8436.png"></p><p>  可以看到,直接读取到了规则</p></li><li><p>  关闭8401</p></li></ol><pre><code>![](/images/springcloud-20/sentinel的的37.png)</code></pre><ol start="6"><li>  此时重启8401,如果sentinel又可以正常读取到规则,那么证明持久化成功</li></ol><pre><code>可以看到,又重新出现了 ![](/images/springcloud-20/sentinel的的38.png)</code></pre><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata:"></a>Seata:</h2><p>是一个分布式事务的解决方案,</p><p><strong>分布式事务中的一些概念,也是seata中的概念:</strong></p><p>​        <img src="/images/springcloud-20/seala.png"></p><p><img src="/images/springcloud-20/seala%E7%9A%842.png"></p><p><img src="/images/springcloud-20/seala%E7%9A%843.png"></p><h3 id="seata安装"><a href="#seata安装" class="headerlink" title="seata安装:"></a>seata安装:</h3><ol><li><p> <strong>下载安装seata的安装包</strong></p></li><li><p><strong>修改file.conf</strong></p><p>  <img src="/images/springcloud-20/seala%E7%9A%844.png"></p><p>  <img src="/images/springcloud-20/seala%E7%9A%845.png"></p><p>  <img src="/images/springcloud-20/seala%E7%9A%846.png"></p></li><li><p><strong>mysql建库建表</strong></p><p>  1,上面指定了数据库为seata,所以创建一个数据库名为seata</p><p>  2,建表,在seata的安装目录下有一个db_store.sql,运行即可</p></li><li><p>  <strong>继续修改配置文件,修改registry.conf</strong></p></li></ol><pre><code>配置seata作为微服务,指定注册中心![](/images/springcloud-20/seala的7.png)</code></pre><ol start="5"><li>  启动</li></ol><pre><code>先启动nacos在启动seata-server(运行安装目录下的,seata-server.bat)</code></pre><p><strong>业务说明</strong></p><p><img src="/images/springcloud-20/seala%E7%9A%848.png"></p><p>下单—&gt;库存—&gt;账号余额</p><ol><li><p>创建三个数据库</p><p> <img src="/images/springcloud-20/seala%E7%9A%849.png"></p></li><li><p>  创建对应的表</p></li></ol><pre><code>![](/images/springcloud-20/seala的10.png)</code></pre><ol start="3"><li>  创建回滚日志表,方便查看</li></ol><pre><code>![](/images/springcloud-20/seala的11.png)**注意==每个库都要执行一次==这个sql,生成回滚日志表**</code></pre><ol start="4"><li>  ==每个业务都创建一个微服务,也就是要有三个微服务,订单,库存,账号==</li></ol><pre><code>​     ==订单==,seta-order-20011.   pom2.   配置文件    <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">2001</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">seata-order-service</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">alibaba:</span><br>      <span class="hljs-attr">seata:</span><br>        <span class="hljs-comment"># 自定义事务组名称需要与seata-server中的对应,我们之前在seata的配置文件中配置的名字</span><br>        <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">fsp_tx_group</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-comment"># 当前数据源操作类型</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-comment"># mysql驱动类</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/seata_order?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">io:</span><br>      <span class="hljs-attr">seata:</span> <span class="hljs-string">info</span><br><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">mapperLocations:</span> <span class="hljs-string">classpath*:mapper/*.xml</span><br><br> <br> <br><br></code></pre></td></tr></table></figure>    还要额外创建其他配置文件,创建一个file.conf:     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs .conf">transport &#123;<br>  # tcp udt unix-domain-socket<br>  type &#x3D; &quot;TCP&quot;<br>  #NIO NATIVE<br>  server &#x3D; &quot;NIO&quot;<br>  #enable heartbeat<br>  heartbeat &#x3D; true<br>  #thread factory for netty<br>  thread-factory &#123;<br>    boss-thread-prefix &#x3D; &quot;NettyBoss&quot;<br>    worker-thread-prefix &#x3D; &quot;NettyServerNIOWorker&quot;<br>    server-executor-thread-prefix &#x3D; &quot;NettyServerBizHandler&quot;<br>    share-boss-worker &#x3D; false<br>    client-selector-thread-prefix &#x3D; &quot;NettyClientSelector&quot;<br>    client-selector-thread-size &#x3D; 1<br>    client-worker-thread-prefix &#x3D; &quot;NettyClientWorkerThread&quot;<br>    # netty boss thread size,will not be used for UDT<br>    boss-thread-size &#x3D; 1<br>    #auto default pin or 8<br>    worker-thread-size &#x3D; 8<br>  &#125;<br>  shutdown &#123;<br>    # when destroy server, wait seconds<br>    wait &#x3D; 3<br>  &#125;<br>  serialization &#x3D; &quot;seata&quot;<br>  compressor &#x3D; &quot;none&quot;<br>&#125;<br>service &#123;<br>  #vgroup-&gt;rgroup<br>  # 事务组名称<br>  vgroup_mapping.fsp_tx_group &#x3D; &quot;default&quot;<br>  #only support single node<br>  default.grouplist &#x3D; &quot;127.0.0.1:8091&quot;<br>  #degrade current not support<br>  enableDegrade &#x3D; false<br>  #disable<br>  disable &#x3D; false<br>  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent<br>  max.commit.retry.timeout &#x3D; &quot;-1&quot;<br>  max.rollback.retry.timeout &#x3D; &quot;-1&quot;<br>&#125;<br> <br>client &#123;<br>  async.commit.buffer.limit &#x3D; 10000<br>  lock &#123;<br>    retry.internal &#x3D; 10<br>    retry.times &#x3D; 30<br>  &#125;<br>  report.retry.count &#x3D; 5<br>  tm.commit.retry.count &#x3D; 1<br>  tm.rollback.retry.count &#x3D; 1<br>&#125;<br> <br>## transaction log store<br>store &#123;<br>  ## store mode: file、db<br>  #mode &#x3D; &quot;file&quot;<br>  mode &#x3D; &quot;db&quot;<br> <br>  ## file store<br>  file &#123;<br>    dir &#x3D; &quot;sessionStore&quot;<br> <br>    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions<br>    max-branch-session-size &#x3D; 16384<br>    # globe session size , if exceeded throws exceptions<br>    max-global-session-size &#x3D; 512<br>    # file buffer size , if exceeded allocate new buffer<br>    file-write-buffer-cache-size &#x3D; 16384<br>    # when recover batch read size<br>    session.reload.read_size &#x3D; 100<br>    # async, sync<br>    flush-disk-mode &#x3D; async<br>  &#125;<br> <br>  ## database store<br>  db &#123;<br>    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)&#x2F;BasicDataSource(dbcp) etc.<br>    datasource &#x3D; &quot;dbcp&quot;<br>    ## mysql&#x2F;oracle&#x2F;h2&#x2F;oceanbase etc.<br>    db-type &#x3D; &quot;mysql&quot;<br>    driver-class-name &#x3D; &quot;com.mysql.jdbc.Driver&quot;<br>    url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;seata&quot;<br>    user &#x3D; &quot;root&quot;<br>    password &#x3D; &quot;root&quot;<br>    min-conn &#x3D; 1<br>    max-conn &#x3D; 3<br>    global.table &#x3D; &quot;global_table&quot;<br>    branch.table &#x3D; &quot;branch_table&quot;<br>    lock-table &#x3D; &quot;lock_table&quot;<br>    query-limit &#x3D; 100<br>  &#125;<br>&#125;<br>lock &#123;<br>  ## the lock store mode: local、remote<br>  mode &#x3D; &quot;remote&quot;<br> <br>  local &#123;<br>    ## store locks in user&#39;s database<br>  &#125;<br> <br>  remote &#123;<br>    ## store locks in the seata&#39;s server<br>  &#125;<br>&#125;<br>recovery &#123;<br>  #schedule committing retry period in milliseconds<br>  committing-retry-period &#x3D; 1000<br>  #schedule asyn committing retry period in milliseconds<br>  asyn-committing-retry-period &#x3D; 1000<br>  #schedule rollbacking retry period in milliseconds<br>  rollbacking-retry-period &#x3D; 1000<br>  #schedule timeout retry period in milliseconds<br>  timeout-retry-period &#x3D; 1000<br>&#125;<br> <br>transaction &#123;<br>  undo.data.validation &#x3D; true<br>  undo.log.serialization &#x3D; &quot;jackson&quot;<br>  undo.log.save.days &#x3D; 7<br>  #schedule delete expired undo_log in milliseconds<br>  undo.log.delete.period &#x3D; 86400000<br>  undo.log.table &#x3D; &quot;undo_log&quot;<br>&#125;<br> <br>## metrics settings<br>metrics &#123;<br>  enabled &#x3D; false<br>  registry-type &#x3D; &quot;compact&quot;<br>  # multi exporters use comma divided<br>  exporter-list &#x3D; &quot;prometheus&quot;<br>  exporter-prometheus-port &#x3D; 9898<br>&#125;<br> <br>support &#123;<br>  ## spring<br>  spring &#123;<br>    # auto proxy the DataSource bean<br>    datasource.autoproxy &#x3D; false<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>    创建registry.conf:    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs conf">registry &#123;<br>  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa<br>  type &#x3D; &quot;nacos&quot;<br> <br>  nacos &#123;<br>    #serverAddr &#x3D; &quot;localhost&quot;<br>    serverAddr &#x3D; &quot;localhost:8848&quot;<br>    namespace &#x3D; &quot;&quot;<br>    cluster &#x3D; &quot;default&quot;<br>  &#125;<br>  eureka &#123;<br>    serviceUrl &#x3D; &quot;http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&quot;<br>    application &#x3D; &quot;default&quot;<br>    weight &#x3D; &quot;1&quot;<br>  &#125;<br>  redis &#123;<br>    serverAddr &#x3D; &quot;localhost:6379&quot;<br>    db &#x3D; &quot;0&quot;<br>  &#125;<br>  zk &#123;<br>    cluster &#x3D; &quot;default&quot;<br>    serverAddr &#x3D; &quot;127.0.0.1:2181&quot;<br>    session.timeout &#x3D; 6000<br>    connect.timeout &#x3D; 2000<br>  &#125;<br>  consul &#123;<br>    cluster &#x3D; &quot;default&quot;<br>    serverAddr &#x3D; &quot;127.0.0.1:8500&quot;<br>  &#125;<br>  etcd3 &#123;<br>    cluster &#x3D; &quot;default&quot;<br>    serverAddr &#x3D; &quot;http:&#x2F;&#x2F;localhost:2379&quot;<br>  &#125;<br>  sofa &#123;<br>    serverAddr &#x3D; &quot;127.0.0.1:9603&quot;<br>    application &#x3D; &quot;default&quot;<br>    region &#x3D; &quot;DEFAULT_ZONE&quot;<br>    datacenter &#x3D; &quot;DefaultDataCenter&quot;<br>    cluster &#x3D; &quot;default&quot;<br>    group &#x3D; &quot;SEATA_GROUP&quot;<br>    addressWaitTime &#x3D; &quot;3000&quot;<br>  &#125;<br>  file &#123;<br>    name &#x3D; &quot;file.conf&quot;<br>  &#125;<br>&#125;<br> <br>config &#123;<br>  # file、nacos 、apollo、zk、consul、etcd3<br>  type &#x3D; &quot;file&quot;<br> <br>  nacos &#123;<br>    serverAddr &#x3D; &quot;localhost&quot;<br>    namespace &#x3D; &quot;&quot;<br>  &#125;<br>  consul &#123;<br>    serverAddr &#x3D; &quot;127.0.0.1:8500&quot;<br>  &#125;<br>  apollo &#123;<br>    app.id &#x3D; &quot;seata-server&quot;<br>    apollo.meta &#x3D; &quot;http:&#x2F;&#x2F;192.168.1.204:8801&quot;<br>  &#125;<br>  zk &#123;<br>    serverAddr &#x3D; &quot;127.0.0.1:2181&quot;<br>    session.timeout &#x3D; 6000<br>    connect.timeout &#x3D; 2000<br>  &#125;<br>  etcd3 &#123;<br>    serverAddr &#x3D; &quot;http:&#x2F;&#x2F;localhost:2379&quot;<br>  &#125;<br>  file &#123;<br>    name &#x3D; &quot;file.conf&quot;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>    ==实际上,就是要将seata中的我们之前修改的两个配置文件复制到这个项目下==3.   **主启动类**    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span> <span class="hljs-comment">//取消数据源的自动创建</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeataOrderMain2001</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SeataOrderMain2001.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>    4.   **service层**     <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">public interface OrderService &#123;<br><br>    /**<br>     * 创建订单<br>     * @param order<br>     */<br>    void create(Order order);<br>&#125;<br></code></pre></td></tr></table></figure>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">@FeignClient(value = &quot;seata-storage-service&quot;)<br>public interface StorageService &#123;<br><br>    /**<br>     * 减库存<br>     * @param productId<br>     * @param count<br>     * @return<br>     */<br>    @PostMapping(value = &quot;/storage/decrease&quot;)<br>    CommonResult decrease(@RequestParam(&quot;productId&quot;) Long productId, @RequestParam(&quot;count&quot;) Integer count);<br>&#125;<br></code></pre></td></tr></table></figure>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">@FeignClient(value = &quot;seata-account-service&quot;)<br>public interface AccountService &#123;<br><br>    /**<br>     * 减余额<br>     * @param userId<br>     * @param money<br>     * @return<br>     */<br>    @PostMapping(value = &quot;/account/decrease&quot;)<br>    CommonResult decrease(@RequestParam(&quot;userId&quot;) Long userId, @RequestParam(&quot;money&quot;) BigDecimal money);<br>&#125;<br> <br> <br><br></code></pre></td></tr></table></figure>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml">@Service<br>@Slf4j<br>public class OrderServiceImpl implements OrderService &#123;<br><br>    @Resource<br>    private OrderDao orderDao;<br>    @Resource<br>    private AccountService accountService;<br>    @Resource<br>    private StorageService storageService;<br><br>    /**<br>     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态<br>     * 简单说:<br>     * 下订单-&gt;减库存-&gt;减余额-&gt;改状态<br>     * GlobalTransactional seata开启分布式事务,异常时回滚,name保证唯一即可<br>     * @param order 订单对象<br>     */<br>    @Override<br>    ///@GlobalTransactional(name = &quot;fsp-create-order&quot;, rollbackFor = Exception.class)<br>    public void create(Order order) &#123;<br>        // 1 新建订单<br>        log.info(&quot;-----&gt;开始新建订单&quot;);<br>        orderDao.create(order);<br><br>        // 2 扣减库存<br>        log.info(&quot;-----&gt;订单微服务开始调用库存,做扣减Count&quot;);<br>        storageService.decrease(order.getProductId(), order.getCount());<br>        log.info(&quot;-----&gt;订单微服务开始调用库存,做扣减End&quot;);<br><br>        // 3 扣减账户<br>        log.info(&quot;-----&gt;订单微服务开始调用账户,做扣减Money&quot;);<br>        accountService.decrease(order.getUserId(), order.getMoney());<br>        log.info(&quot;-----&gt;订单微服务开始调用账户,做扣减End&quot;);<br><br>        // 4 修改订单状态,从0到1,1代表已完成<br>        log.info(&quot;-----&gt;修改订单状态开始&quot;);<br>        orderDao.update(order.getUserId(), 0);<br><br>        log.info(&quot;-----&gt;下订单结束了,O(∩_∩)O哈哈~&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>                                  5.   **dao层,也就是接口**    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderDao</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1 新建订单</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> order</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">create</span><span class="hljs-params">(Order order)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2 修改订单状态,从0改为1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="hljs-meta">@Param(&quot;status&quot;)</span> Integer status)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>     ==在resource下创建mapper文件夹,编写mapper.xml==    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.eiletxie.springcloud.alibaba.dao.OrderDao&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.eiletxie.springcloud.alibaba.domain.Order&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;product_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;productId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;count&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;count&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;money&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;money&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;DECIMAL&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;status&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;status&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;create&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.eiletxie.springcloud.alibaba.domain.Order&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>        insert into t_order(user_id,product_id,count,money,status) values (#&#123;userId&#125;,#&#123;productId&#125;,#&#123;count&#125;,#&#123;money&#125;,0);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>        update t_order set status =1 where user_id =#&#123;userId&#125; and status=#&#123;status&#125;;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br> <br></code></pre></td></tr></table></figure>6.   **controller层**    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> OrderService orderService;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建订单</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> order</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/order/create&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CommonResult <span class="hljs-title">create</span><span class="hljs-params">(Order order)</span> </span>&#123;<br>        orderService.create(order);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CommonResult(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;订单创建成功&quot;</span>);<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>    7.   **entity类(也叫domain类)**     <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonResult</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer code;<br>    <span class="hljs-keyword">private</span> String message;<br>    <span class="hljs-keyword">private</span> T data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CommonResult</span><span class="hljs-params">(Integer code, String message)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(code, message, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure>    ![](/images/springcloud-20/seala的12.png)              8.   config配置类    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@MapperScan(&#123;&quot;com.eiletxie.springcloud.alibaba.dao&quot;&#125;)</span>指定我们的接口的位置<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisConfig</span> </span>&#123;<br><br><br>&#125;<br> <br> <br><br></code></pre></td></tr></table></figure>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> EiletXie</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Since</span> 2020/3/18 21:51</span><br><span class="hljs-comment"> * 使用Seata对数据源进行代理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceProxyConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String mapperLocations;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceProxy <span class="hljs-title">dataSourceProxy</span><span class="hljs-params">(DataSource druidDataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProxy(druidDataSource);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactoryBean</span><span class="hljs-params">(DataSourceProxy dataSourceProxy)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        SqlSessionFactoryBean bean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();<br>        bean.setDataSource(dataSourceProxy);<br>        ResourcePatternResolver resolver = <span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver();<br>        bean.setMapperLocations(resolver.getResources(mapperLocations));<br>        <span class="hljs-keyword">return</span> bean.getObject();<br>    &#125;<br>&#125;<br> <br> <br><br></code></pre></td></tr></table></figure>    9.   10.   11.    ==库存==,seta-storage-2002**==看脑图==**1.    pom   2.   配置文件3.   主启动类4.    service层5.    dao层6.    controller层7.   8.     ==账号==,seta-account-2003**==看脑图==**1.    pom     2.   配置文件3.   主启动类4.   service层5.    dao层6.   controller层7.   8.   </code></pre><ol start="5"><li><p><strong>全局创建完成后,首先测试不加seata</strong></p><p>  <img src="/images/springcloud-20/seala%E7%9A%8414.png"></p><p>  <img src="/images/springcloud-20/seala%E7%9A%8413.png"></p></li></ol><p>​    </p><p>​    </p><p>​     </p><ol start="6"><li><p>使用seata:</p><p>  <strong>在==订单模块==的serviceImpl类中的==create方法==添加启动分布式事务的注解</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">这里添加开启分布式事务的注解,name指定当前全局事务的名称</span><br><span class="hljs-comment">rollbackFor表示,发生什么异常需要回滚</span><br><span class="hljs-comment">noRollbackFor:表示,发生什么异常不需要回滚</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@GlobalTransactional(name = &quot;fsp-create-order&quot;,rollbackFor = Exception.class)</span><br><span class="hljs-comment">///@GlobalTransactional(name = &quot;fsp-create-order&quot;, rollbackFor = Exception.class)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(Order order)</span> </span>&#123;<br>    <span class="hljs-comment">// 1 新建订单</span><br>    log.info(<span class="hljs-string">&quot;-----&gt;开始新建订单&quot;</span>);<br>    orderDao.create(order);<br><br>    <span class="hljs-comment">// 2 扣减库存</span><br>    log.info(<span class="hljs-string">&quot;-----&gt;订单微服务开始调用库存,做扣减Count&quot;</span>);<br>    storageService.decrease(order.getProductId(), order.getCount());<br>    log.info(<span class="hljs-string">&quot;-----&gt;订单微服务开始调用库存,做扣减End&quot;</span>);<br><br>    <span class="hljs-comment">// 3 扣减账户</span><br>    log.info(<span class="hljs-string">&quot;-----&gt;订单微服务开始调用账户,做扣减Money&quot;</span>);<br>    accountService.decrease(order.getUserId(), order.getMoney());<br>    log.info(<span class="hljs-string">&quot;-----&gt;订单微服务开始调用账户,做扣减End&quot;</span>);<br><br>    <span class="hljs-comment">// 4 修改订单状态,从0到1,1代表已完成</span><br>    log.info(<span class="hljs-string">&quot;-----&gt;修改订单状态开始&quot;</span>);<br>    orderDao.update(order.getUserId(), <span class="hljs-number">0</span>);<br><br>    log.info(<span class="hljs-string">&quot;-----&gt;下订单结束了,O(∩_∩)O哈哈~&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>  此时在测试</p></li></ol><pre><code>发现,发生异常后,直接回滚了,前面的修改操作都回滚了</code></pre><h3 id="setat原理"><a href="#setat原理" class="headerlink" title="setat原理:"></a>setat原理:</h3><p><img src="/images/springcloud-20/seala%E7%9A%8415.png"></p><p><img src="/images/springcloud-20/seala%E7%9A%8416.png"></p><p><strong>seata提供了四个模式:</strong></p><p><img src="/images/springcloud-20/seala%E7%9A%8417.png"></p><p><img src="/images/springcloud-20/seala%E7%9A%8418.png"></p><p>==第一阶段:==</p><p><img src="/images/springcloud-20/seala%E7%9A%8420.png"></p><p>​    <img src="/images/springcloud-20/seala%E7%9A%8419.png"></p><p>==二阶段之提交==:</p><p><img src="/images/springcloud-20/seala%E7%9A%8421.png"></p><p>==二阶段之回滚:==</p><p><img src="/images/springcloud-20/seala%E7%9A%8422.png"></p><p><img src="/images/springcloud-20/seala%E7%9A%8423.png"></p><p>==断点==:</p><p><img src="/images/springcloud-20/seala%E7%9A%8424.png"></p><p><strong>可以看到,他们的xid全局事务id是一样的,证明他们在一个事务下</strong></p><p><img src="/images/springcloud-20/seala%E7%9A%8425.png"></p><p><strong>before 和 after的原理就是</strong></p><p><img src="/images/springcloud-20/seala%E7%9A%8426.png"></p><p><strong>在更新数据之前,先解析这个更新sql,然后查询要更新的数据,进行保存</strong></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring Cloud</tag>
      
      <tag>Spring Cloud Alibaba</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 安装常用软件</title>
    <link href="/2021/03/22/Docker%20%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
    <url>/2021/03/22/Docker%20%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux环境配置"><a href="#Linux环境配置" class="headerlink" title="Linux环境配置"></a>Linux环境配置</h1><h2 id="Linux配置jdk8环境两种方式"><a href="#Linux配置jdk8环境两种方式" class="headerlink" title="Linux配置jdk8环境两种方式"></a>Linux配置jdk8环境两种方式</h2><ul><li> <strong>yum安装，默认路径(  usr/lib/jvm/  )，不用配置</strong></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>、查询要安装jdk的版本：<br><span class="hljs-attribute">yum</span> -y list java*<br><br><span class="hljs-attribute">2</span>、安装jdk<span class="hljs-number">1</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">yum</span> install -y java-<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-openjdk.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span><br><br><span class="hljs-attribute">3</span>、查询jdk版本<br><span class="hljs-attribute">java</span> -version<br></code></pre></td></tr></table></figure><ul><li><strong>手动安装，需配置环境 (  /usr/local/java/  )</strong></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1、进入安装目录<br>cd /usr/local<br><br>2、创建安装jdk的文件夹(可省略)<br>mkdir java<br><br>3、解压缩下载好的jdk<br><span class="hljs-comment">#cd java</span><br>tar -zxvf jdk-8u251-linux-x64.tar.gz -C /usr/local/java<br><br>4、打开/etc/profile<br>vim /etc/profile<br><br>5、在 /etc<span class="hljs-built_in">/profile </span>文件追加下面内容<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/local/java/jdk1.8.0_251<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JRE_HOME</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/jre<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CLASSPATH</span>=.:$&#123;JAVA_HOME&#125;/lib:<span class="hljs-variable">$&#123;JRE_HOME&#125;</span>/lib:<span class="hljs-variable">$CLASSPATH</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_PATH</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/bin:$&#123;JRE_HOME&#125;/bin<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$&#123;JAVA_PATH&#125;<br><br>6、生效配置文件<br>source /etc/profile<br><br>7、校验查询jdk版本<br>java -version<br></code></pre></td></tr></table></figure><h2 id="Linux安装配置maven"><a href="#Linux安装配置maven" class="headerlink" title="Linux安装配置maven"></a>Linux安装配置maven</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>、进入安装目录 并复制安装包<br>cd <span class="hljs-regexp">/usr/</span>local<br><br><span class="hljs-number">2</span>、解压下载好的maven<br>tar -zxvf apache-maven-<span class="hljs-number">3.6</span>.<span class="hljs-number">3</span>-bin.tar.gz<br><br><span class="hljs-number">3</span>、配置国内的maven仓库<br>cd apache-maven-<span class="hljs-number">3.6</span>.<span class="hljs-number">3</span>/<br><br>mkdir ck    <span class="hljs-comment">#创建maven仓库ck目录</span><br><br><span class="hljs-number">4</span>、进入cd conf目录，编辑 vi settings.xml文件，找到·localRepository下面复制一行加上<br>cd conf            <span class="hljs-comment"># 进入conf目录</span><br><br>vim settings.xml   <span class="hljs-comment"># settings.xm文件</span><br><br><span class="hljs-comment">#maven仓库地址</span><br>&lt;localRepository&gt;<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache-maven-3.6.3/</span>ck&lt;/localRepository&gt;    <br><br><span class="hljs-comment">#maven国内源</span><br>&lt;mirror&gt;<br>      &lt;id&gt;alimaven&lt;/id&gt;<br>      &lt;name&gt;aliyun maven&lt;/name&gt;<br>       &lt;url&gt;http:<span class="hljs-regexp">//m</span>aven.aliyun.com<span class="hljs-regexp">/nexus/</span>content<span class="hljs-regexp">/groups/</span>public<span class="hljs-regexp">/&lt;/u</span>rl&gt;<br>      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;<br>&lt;/mirror&gt;<br><br><span class="hljs-number">5</span>、配置环境变量<br>vim <span class="hljs-regexp">/etc/</span>profile<br><br>export MAVEN_HOME=<span class="hljs-regexp">/usr/</span>local/apache-maven-<span class="hljs-number">3.6</span>.<span class="hljs-number">3</span><br>export PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$MAVEN_HOME</span>/bin<br><br><span class="hljs-number">6</span>、使配置文件生效<br>source <span class="hljs-regexp">/etc/</span>profile<br><br><span class="hljs-number">7</span>、测试maven<br>mvn -v<br></code></pre></td></tr></table></figure><h1 id="Docker-安装常用软件"><a href="#Docker-安装常用软件" class="headerlink" title="Docker 安装常用软件"></a>Docker 安装常用软件</h1><h2 id="Linux-CentOS7-安装Docker"><a href="#Linux-CentOS7-安装Docker" class="headerlink" title="Linux(CentOS7)安装Docker"></a>Linux(CentOS7)安装Docker</h2><hr><ul><li><strong>安装之前最好永久关闭防火墙</strong></li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">#1、查看防火墙状态</span><br>systemctl status firewalld<br><br><span class="hljs-meta">#2:暂时关闭防火墙</span><br>systemctl stop firewalld<br><br><span class="hljs-meta">#3:永久关闭防火墙</span><br>systemctl disable firewalld<br><br><span class="hljs-meta">#4:重启防火墙</span><br>systemctl enable firewalld<br>  <br></code></pre></td></tr></table></figure><ul><li><strong>开始安装docker</strong></li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-comment">#卸载系统之前的</span><br>sudo yum remove docker <span class="hljs-string">\</span><br>                  docker-client <span class="hljs-string">\</span><br>                  docker-client-latest <span class="hljs-string">\</span><br>                  docker-common <span class="hljs-string">\</span><br>                  docker-latest <span class="hljs-string">\</span><br>                  docker-latest-logrotate <span class="hljs-string">\</span><br>                  docker-logrotate <span class="hljs-string">\</span><br>                  docker-engine<br>                 <br>sudo yum install -y yum-utils<br><br><span class="hljs-comment"># 配置镜像</span><br>sudo yum-config-manager <span class="hljs-string">\</span><br>    --add-repo <span class="hljs-string">\</span><br>    https:<span class="hljs-regexp">//download.docker.com/linux/centos/docker-ce.repo</span><br><span class="hljs-regexp">    </span><br><span class="hljs-regexp">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">systemctl start docker</span><br><span class="hljs-regexp"><span class="hljs-comment"># 设置开机自启动</span></span><br><span class="hljs-regexp">systemctl enable docker</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">docker -v</span><br><span class="hljs-regexp">docker images</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp"><span class="hljs-comment"># 配置镜像加速</span></span><br></code></pre></td></tr></table></figure><ul><li><strong>配置阿里云仓库</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mkdir -p <span class="hljs-regexp">/etc/</span>docker<br>sudo tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://cxa8dd3m.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><p><strong>在使用docker之前，为防止软件远程冲突，先关闭虚拟机的防火墙</strong></p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">#查看防火墙状态</span><br>firewall-cmd --state<br><br><span class="hljs-meta">#停止防火墙firewall</span><br>systemctl stop firewalld.service<br><br><span class="hljs-meta">#禁止firewall开机启动</span><br>systemctl disable firewalld.service <br><br></code></pre></td></tr></table></figure><hr><h2 id="Docker安装MySQL5-7"><a href="#Docker安装MySQL5-7" class="headerlink" title="Docker安装MySQL5.7"></a>Docker安装MySQL5.7</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker pull mysql:<span class="hljs-number">5.7</span><br><span class="hljs-comment">#创建MySQL映射文件夹</span><br>mkdir -p <span class="hljs-regexp">/mydata/my</span>sql/log<br>mkdir -p <span class="hljs-regexp">/mydata/my</span>sql/data<br>mkdir -p <span class="hljs-regexp">/mydata/my</span>sql/conf<br><br><span class="hljs-comment"># --name指定容器名字 -v目录挂载 -p指定端口映射  -e设置mysql参数 -d后台运行</span><br>docker run -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> --name mysql5.<span class="hljs-number">7</span> \<br>-v <span class="hljs-regexp">/mydata/my</span>sql<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/my</span>sql \<br>-v <span class="hljs-regexp">/mydata/my</span>sql<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql \<br>-v <span class="hljs-regexp">/mydata/my</span>sql<span class="hljs-regexp">/conf:/</span>etc/mysql \<br>-e MYSQL_ROOT_PASSWORD=root \<br>-d mysql:<span class="hljs-number">5.7</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> ps<br><span class="hljs-attribute">CONTAINER</span> ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES<br><span class="hljs-attribute">6a685a33103f</span>        mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span>           <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   <span class="hljs-number">32</span> seconds ago      Up <span class="hljs-number">30</span> seconds       <span class="hljs-number">0.0.0.0:3306</span>-&gt;<span class="hljs-number">3306</span>/tcp, <span class="hljs-number">33060</span>/tcp   mysql<br><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker exec -it mysql5<span class="hljs-number">.7</span> bin/bash<br><span class="hljs-keyword">exit</span>;<br><br>#在容器外部配置<br>vim /mydata/mysql/conf/my.conf <br><br>[client]<br><span class="hljs-keyword">default</span>-<span class="hljs-type">character</span>-<span class="hljs-keyword">set</span>=utf8<br>[mysql]<br><span class="hljs-keyword">default</span>-<span class="hljs-type">character</span>-<span class="hljs-keyword">set</span>=utf8<br>[mysqld]<br>init_connect=<span class="hljs-string">&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span><br>init_connect=<span class="hljs-string">&#x27;SET NAMES utf8&#x27;</span><br><span class="hljs-type">character</span>-<span class="hljs-keyword">set</span>-<span class="hljs-keyword">server</span>=utf8<br><span class="hljs-keyword">collation</span>-<span class="hljs-keyword">server</span>=utf8_unicode_ci<br>skip-<span class="hljs-type">character</span>-<span class="hljs-keyword">set</span>-client-handshake<br>skip-<span class="hljs-type">name</span>-resolve<br><br><br>#配置好之后重启<br>docker <span class="hljs-keyword">restart</span> mysql5<span class="hljs-number">.7</span><br></code></pre></td></tr></table></figure><ul><li><strong>设置启动docker时，即运行mysql</strong></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> update mysql<span class="hljs-number">5</span>.<span class="hljs-number">7</span> --restart=always<br></code></pre></td></tr></table></figure><hr><h2 id="Docker安装MySQL8"><a href="#Docker安装MySQL8" class="headerlink" title="Docker安装MySQL8"></a>Docker安装MySQL8</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker pull mysql:<span class="hljs-number">8.0</span><br><br><span class="hljs-comment"># --name指定容器名字 -v目录挂载 -p指定端口映射  -e设置mysql参数 -d后台运行</span><br>docker run -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> --name mysql8 \<br>-v <span class="hljs-regexp">/mydata/my</span>sql8<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/my</span>sql \<br>-v <span class="hljs-regexp">/mydata/my</span>sql8<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql \<br>-v <span class="hljs-regexp">/mydata/my</span>sql8<span class="hljs-regexp">/conf:/</span>etc/mysql \<br>-e MYSQL_ROOT_PASSWORD=root \<br>-d mysql:<span class="hljs-number">8.0</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>mysql8的配置文件</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#在容器外部配置</span><br>vim <span class="hljs-regexp">/mydata/my</span>sql8<span class="hljs-regexp">/conf/my</span>.conf<br><br><span class="hljs-comment">#复制粘贴以下内容</span><br><br>[client]<br>default-character-set=utf8mb4<br>[mysql]<br>default-character-set=utf8mb4<br>[mysqld]<br>init_connect=<span class="hljs-string">&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span><br>init_connect=<span class="hljs-string">&#x27;SET NAMES utf8&#x27;</span><br>character-set-server=utf8mb4<br>collation-server=utf8_unicode_ci<br>skip-character-set-client-handshake<br>skip-name-resolve<br><br>pid-file = <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/mysqld/my</span>sqld.pid<br>socket = <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/mysqld/my</span>sqld.sock<br>datadir = <span class="hljs-regexp">/var/</span>lib/mysql<br>secure-file-priv= NULL<br><br><span class="hljs-comment"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br>symbolic-links=<span class="hljs-number">0</span><br><br><span class="hljs-comment"># Custom config should go here</span><br>!includedir <span class="hljs-regexp">/etc/my</span>sql<span class="hljs-regexp">/conf.d/</span><br><br><span class="hljs-comment">#配置好之后重启</span><br>docker restart mysql8<br><br></code></pre></td></tr></table></figure><ul><li><strong>mysql8加密方式与其他版本不同，安装之后需要进行一些才能远程连接</strong></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker exec -it mysql8 bin/bash<br><br>mysql -u root -p <br>use mysql; <br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> host = <span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span> = <span class="hljs-string">&#x27;root&#x27;</span>;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;root&#x27;</span>; <br><span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>,host,plugin <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br>flush <span class="hljs-keyword">privileges</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h2><ul><li>下载docker（这里以最新版为例）</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull redis</span><br></code></pre></td></tr></table></figure><ul><li>启动docker</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[root@localhost ~]# mkdir -p <span class="hljs-regexp">/mydata/</span>redis/conf<br>[root@localhost ~]# touch <span class="hljs-regexp">/mydata/</span>redis<span class="hljs-regexp">/conf/</span>redis.conf<br>[root@localhost ~]# echo <span class="hljs-string">&quot;appendonly yes&quot;</span>  &gt;&gt; <span class="hljs-regexp">/mydata/</span>redis<span class="hljs-regexp">/conf/</span>redis.conf<br>[root@localhost ~]# docker run -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> --name redis -v <span class="hljs-regexp">/mydata/</span>redis<span class="hljs-regexp">/data:/</span>data \<br>-v <span class="hljs-regexp">/mydata/</span>redis<span class="hljs-regexp">/conf/</span>redis.conf:<span class="hljs-regexp">/etc/</span>redis/redis.conf \<br>-d redis redis-server <span class="hljs-regexp">/etc/</span>redis/redis.conf<br><br></code></pre></td></tr></table></figure><ul><li>连接到docker的redis</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[root@localhost ~]</span># docker exec -it redis redis-cli<br><span class="hljs-number">127.0.0.1:6379</span>&gt; set key1 v1<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; get key1<br><span class="hljs-string">&quot;v1&quot;</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; <br></code></pre></td></tr></table></figure><ul><li>设置redis容器在docker启动的时候启动</li></ul><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golo">root<span class="hljs-meta">@localhost</span> ~]<span class="hljs-comment"># docker update redis --restart=always</span><br>redis<br>[root<span class="hljs-meta">@localhost</span> ~]<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><hr><h2 id="Docker安装MongoDB"><a href="#Docker安装MongoDB" class="headerlink" title="Docker安装MongoDB"></a>Docker安装MongoDB</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#拉取镜像 </span><br>docker pull mongo:latestor     docker pull mongo:<span class="hljs-number">4.2</span>.<span class="hljs-number">5</span><br><br><span class="hljs-comment">#创建和启动容器 </span><br>docker run -d --restart=always -p <span class="hljs-number">27017</span>:<span class="hljs-number">27017</span> --name mongodb -v <span class="hljs-regexp">/mydata/</span>data<span class="hljs-regexp">/db:/</span>data/db -d mongo:<span class="hljs-number">4.2</span>.<span class="hljs-number">5</span><br><br><span class="hljs-comment">#进入容器 </span><br>docker exec -it mongodb <span class="hljs-regexp">/bin/</span>bash <br><br><span class="hljs-comment">#使用MongoDB客户端进行操作 </span><br>mongo <br><br>&gt; show dbs <span class="hljs-comment">#查询所有的数据库 </span><br>admin <span class="hljs-number">0.000</span>GB <br>config <span class="hljs-number">0.000</span>GB <br>local <span class="hljs-number">0.000</span>GB <br><br><br></code></pre></td></tr></table></figure><hr><h2 id="Docker安装ELK-7-x"><a href="#Docker安装ELK-7-x" class="headerlink" title="Docker安装ELK 7.x"></a>Docker安装ELK 7.x</h2><p><code>注意</code>   <strong>ElasticSearch、ik分词器、kibana版本要一致 (这里以7.6.2版本为例）</strong></p><ul><li><code>注意</code>   <strong>调高JVM线程数限制数量</strong></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim"># <span class="hljs-number">1</span>.在centos虚拟机中，修改配置sysctl.<span class="hljs-keyword">conf</span><br><span class="hljs-keyword">vim</span> /etc/sysctl.<span class="hljs-keyword">conf</span><br># <span class="hljs-number">2</span>.加入如下配置<br><span class="hljs-keyword">vm</span>.max_map_count=<span class="hljs-number">262144</span> <br># <span class="hljs-number">3</span>.启用配置<br>sysctl -<span class="hljs-keyword">p</span><br>注：这一步是为了防止启动容器时，报出如下错误：<br>bootstrap checks failed <span class="hljs-built_in">max</span> virtual memory areas <span class="hljs-keyword">vm</span>.max_map_count [<span class="hljs-number">65530</span>] likely too low, increase <span class="hljs-keyword">to</span> at least [<span class="hljs-number">262144</span>]<br></code></pre></td></tr></table></figure><ul><li><strong>下载ealasticsearch和kibana及前置准备</strong></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">docker</span> pull kibana:<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br><br><span class="hljs-attribute">mkdir</span> -p /mydata/elasticsearch<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>/config<br><span class="hljs-attribute">mkdir</span> -p /mydata/elasticsearch<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>/data<br><span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;http.host: 0.0.0.0&quot;</span> &gt;/mydata/elasticsearch<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>/config/elasticsearch.yml<br><br><span class="hljs-comment">#将/mydata/elasticsearch7.6.2/文件夹的权限修改为可读可改可执行</span><br><span class="hljs-attribute">chmod</span> -R <span class="hljs-number">777</span> /mydata/elasticsearch<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>/<br></code></pre></td></tr></table></figure><ul><li><strong>安装ealasticsearch</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#启动elasticsearch7.6.2</span><br>docker run --name elasticsearch7.<span class="hljs-number">6.2</span> -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> \<br>-e  <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> \<br>-e ES_JAVA_OPTS=<span class="hljs-string">&quot;-Xms64m -Xmx512m&quot;</span> \<br>-v <span class="hljs-regexp">/mydata/</span>elasticsearch7.<span class="hljs-number">6.2</span><span class="hljs-regexp">/config/</span>elasticsearch.yml:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/elasticsearch/</span>config/elasticsearch.yml \<br>-v <span class="hljs-regexp">/mydata/</span>elasticsearch7.<span class="hljs-number">6.2</span><span class="hljs-regexp">/data:/u</span>sr<span class="hljs-regexp">/share/</span>elasticsearch/data \<br>-v <span class="hljs-regexp">/mydata/</span>elasticsearch7.<span class="hljs-number">6.2</span><span class="hljs-regexp">/plugins:/u</span>sr<span class="hljs-regexp">/share/</span>elasticsearch/plugins \<br>-d elasticsearch:<span class="hljs-number">7.6</span>.<span class="hljs-number">2</span> <br><br><span class="hljs-comment">#设置开机自启</span><br>docker update elasticsearch7.<span class="hljs-number">6.2</span> --restart=always<br><br><span class="hljs-comment">#关闭开机自启</span><br>docker update elasticsearch7.<span class="hljs-number">6.2</span> --restart=no<br></code></pre></td></tr></table></figure><ul><li>**安装IK分词器  **</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 注意版本 可去GitHub复制对应版本网址的链接</span><br><span class="hljs-comment"># 在外部挂载的/mydata/elasticsearch7.6.2/plugins  执行以下命令</span><br><span class="hljs-attribute">cd</span> /mydata/elasticsearch<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>/plugins<br><br><span class="hljs-attribute">wget</span> https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>/elasticsearch-analysis-ik-<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>.zip<br><br><span class="hljs-comment"># 解压到plugins文件夹中</span><br><span class="hljs-attribute">yum</span> install -y unzip<br><span class="hljs-attribute">unzip</span> -d ik<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span> elasticsearch-analysis-ik-<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>.zip <br><br><span class="hljs-comment">#删除elasticsearch-analysis-ik-7.6.2.zip 包 </span><br><span class="hljs-attribute">rm</span> -rf elasticsearch-analysis-ik-<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>.zip<br><span class="hljs-attribute">chmod</span> -R <span class="hljs-number">777</span> /mydata/elasticsearch<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>/<br><br><span class="hljs-comment">#重启elasticsearch7.6.2容器</span><br><span class="hljs-attribute">docker</span> stop elasticsearch<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">docker</span> restart elasticsearch<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span> <br><br><span class="hljs-attribute">docker</span> logs -f elasticsearch<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>  #含loaded plugin<span class="hljs-meta"> [analysis-ik] 表示已加载ik分词器</span><br><span class="hljs-meta"></span><br></code></pre></td></tr></table></figure><ul><li><strong>为Ik分词器在Nginx中配置词库</strong></li></ul><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">#在安装Nginx的前提下新建文件夹es</span><br><span class="xml">mkdir -p /mydata/nginx/html/es</span><br><br><span class="xml">#放置自定义的分词文件 如:</span><br><span class="xml">/mydata/nginx/html/es/fenci.txt</span><br><br><span class="xml">#进入IK分词器的目录</span><br><span class="xml">cd /mydata/elasticsearch7.6.2/plugins/ik7.6.2/config/</span><br><br><span class="xml">#修改IK词库的自定义配置</span><br><span class="xml">vim IKAnalyzer.cfg.xml</span><br><br><span class="xml">#在用户可以在这里配置远程扩展字典 (注意IP地址)</span><br><br><span class="xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">properties</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="hljs-tag">&lt;/<span class="hljs-name">comment</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span></span><br><span class="xml">         <span class="hljs-comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;ext_stopwords&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;remote_ext_dict&quot;</span>&gt;</span>http://192.168.195.131/es/fenci.txt<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><br><span class="xml">#重启elasticsearch</span><br><span class="xml">docker restart elasticsearch7.6.2</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>安装kibana（注意IP地址 ）</strong></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 注意IP地址 ,为虚拟机的局域网IP</span><br><span class="hljs-comment"># 注意出现 Kibana server is not ready yet  请关闭防火墙</span><br><br><span class="hljs-attribute">docker</span> run --name kibana<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span> -e ELASTICSEARCH_HOSTS=http://<span class="hljs-number">192.168.195.131:9200</span> -p <span class="hljs-number">5601</span>:<span class="hljs-number">5601</span> -d kibana:<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br><br><span class="hljs-comment">#设置开机自启kibana7.6.2</span><br><span class="hljs-attribute">docker</span> update kibana<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>  --restart=always<br><br><span class="hljs-comment">#关闭开机自启kibana7.6.2</span><br><span class="hljs-attribute">docker</span> update kibana<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>  --restart=no<br><br></code></pre></td></tr></table></figure><ul><li><strong>安装logstash:7.6.2</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#下载logstash</span><br>docker pull logstash:<span class="hljs-number">7.6</span>.<span class="hljs-number">2</span><br><br><span class="hljs-comment">#创建映射文件夹</span><br>mkdir -p <span class="hljs-regexp">/mydata/</span>logstash<br><br><span class="hljs-comment">#进入映射文件夹并创建配置文件</span><br>cd <span class="hljs-regexp">/mydata/</span>logstash<br>touch logstash.conf <span class="hljs-comment">#logstash.conf为配置文件   文件内容自定义</span><br><br><span class="hljs-comment">#设置文件夹权限可读可写可执行</span><br>chmod -R <span class="hljs-number">777</span> <span class="hljs-regexp">/mydata/</span>logstash<br><br><span class="hljs-comment">#启动容器</span><br>docker run --name logstash7.<span class="hljs-number">6.2</span> -p <span class="hljs-number">4560</span>:<span class="hljs-number">4560</span> -p <span class="hljs-number">4561</span>:<span class="hljs-number">4561</span> -p <span class="hljs-number">4562</span>:<span class="hljs-number">4562</span> -p <span class="hljs-number">4563</span>:<span class="hljs-number">4563</span> \<br>--link elasticsearch7.<span class="hljs-number">6.2</span>:es \<br>-v <span class="hljs-regexp">/mydata/</span>logstash<span class="hljs-regexp">/logstash.conf:/u</span>sr<span class="hljs-regexp">/share/</span>logstash<span class="hljs-regexp">/pipeline/</span>logstash.conf \<br>-d logstash:<span class="hljs-number">7.6</span>.<span class="hljs-number">2</span><br><span class="hljs-comment">#启动容器若报错，先配置logstash.conf</span><br><br><span class="hljs-comment">#进入容器内部，安装json_lines插件</span><br>docker exec -it logstash7.<span class="hljs-number">6.2</span> <span class="hljs-regexp">/bin/</span>bash<br>logstash-plugin install logstash-codec-json_lines<br><br><br><span class="hljs-comment">#设置开机自启logstash7.6.2</span><br>docker update logstash7.<span class="hljs-number">6.2</span>  --restart=always<br><br><span class="hljs-comment">#关闭开机自启logstash7.6.2</span><br>docker update logstash7.<span class="hljs-number">6.2</span>  --restart=no<br><br></code></pre></td></tr></table></figure><hr><h2 id="Docker安装Nacos"><a href="#Docker安装Nacos" class="headerlink" title="Docker安装Nacos"></a>Docker安装Nacos</h2><ul><li><strong>nacos更新得比较快，安装前最好先搜索查看一下版本</strong> </li></ul><blockquote><p><a href="https://nacos.io/zh-cn/docs/quick-start-docker.html">https://nacos.io/zh-cn/docs/quick-start-docker.html</a></p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#这里安装 以 1.3.2版本为例</span><br>docker pull nacos/nacos-server:1.3.2<br><span class="hljs-comment">#创建映射文件夹</span><br>mkdir -p /mydata/nacos1.3.2/logs<br><br><span class="hljs-comment"># -e MODE=standalone 为单机   默认数据库 MySQL</span><br>docker <span class="hljs-builtin-name">run</span> --name nacos1.3.2 \<br>-e <span class="hljs-attribute">PREFER_HOST_MODE</span>=ip \<br>-e <span class="hljs-attribute">MODE</span>=standalone \<br>-e <span class="hljs-attribute">SPRING_DATASOURCE_PLATFORM</span>=mysql \<br>-e <span class="hljs-attribute">MYSQL_SERVICE_HOST</span>=47.119.183.206 \<br>-e <span class="hljs-attribute">MYSQL_SERVICE_PORT</span>=3306 \<br>-e <span class="hljs-attribute">MYSQL_SERVICE_USER</span>=root \<br>-e <span class="hljs-attribute">MYSQL_SERVICE_PASSWORD</span>=root \<br>-e <span class="hljs-attribute">MYSQL_SERVICE_DB_NAME</span>=nacos_config \<br>-e <span class="hljs-attribute">TIME_ZONE</span>=<span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span> \<br>-v /mydata/nacos1.3.2/logs:/home/nacos/logs \<br>-p 8848:8848 \<br>-d nacos/nacos-server:1.3.2<br><br><span class="hljs-comment">#开机自启</span><br>docker update nacos1.3.2 <span class="hljs-attribute">--restart</span>=always<br><br><br></code></pre></td></tr></table></figure><ul><li><strong>Nacos环境变量配置</strong></li></ul><blockquote><p><a href="https://nacos.io/zh-cn/docs/quick-start-docker.html">https://nacos.io/zh-cn/docs/quick-start-docker.html</a></p></blockquote><hr><h2 id="Docker安装Nginx"><a href="#Docker安装Nginx" class="headerlink" title="Docker安装Nginx"></a>Docker安装Nginx</h2><ul><li>随便启动一个nginx实例，只是为了复制出配置</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> --name nginx -d nginx:<span class="hljs-number">1</span>.<span class="hljs-number">10</span>   <br></code></pre></td></tr></table></figure><ul><li>将容器内的配置文件拷贝到/mydata/nginx/conf/ 下</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mkdir -p <span class="hljs-regexp">/mydata/</span>nginx<span class="hljs-regexp">/docker container cp nginx:/</span>etc<span class="hljs-regexp">/nginx/</span>  <span class="hljs-regexp">/mydata/</span>nginx<span class="hljs-regexp">/#将容器中的nginx文件夹改为conf文件夹mv /my</span>data<span class="hljs-regexp">/nginx/</span>nginx <span class="hljs-regexp">/mydata/</span>nginx<span class="hljs-regexp">/confmkdir -p /my</span>data<span class="hljs-regexp">/nginx/</span>htmlmkdir -p <span class="hljs-regexp">/mydata/</span>nginx/logs<br></code></pre></td></tr></table></figure><ul><li>终止原nginx容器并删除</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">docker <span class="hljs-built_in">stop</span> nginxdocker rm nginx<br></code></pre></td></tr></table></figure><ul><li>创建新的Nginx，执行以下命令</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker run -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> --name nginx \ -v <span class="hljs-regexp">/mydata/</span>nginx<span class="hljs-regexp">/html:/u</span>sr<span class="hljs-regexp">/share/</span>nginx<span class="hljs-regexp">/html \ -v /my</span>data<span class="hljs-regexp">/nginx/</span>logs:<span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx \ -v /my</span>data<span class="hljs-regexp">/nginx/</span>conf<span class="hljs-regexp">/:/</span>etc/nginx \ -d nginx:<span class="hljs-number">1.10</span><br></code></pre></td></tr></table></figure><ul><li>创建“/mydata/nginx/html/index.html”文件，测试是否能够正常访问</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-string">&#x27;&lt;h2&gt;hello nginx!&lt;/h2&gt;&#x27;</span> &gt;<span class="hljs-regexp">/mydata/</span>nginx<span class="hljs-regexp">/html/i</span>ndex.html<br></code></pre></td></tr></table></figure><ul><li>设置开机启动nginx</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">update</span> nginx <span class="hljs-comment">--restart=always</span><br></code></pre></td></tr></table></figure><hr><h2 id="Docker安装RabbitMQ"><a href="#Docker安装RabbitMQ" class="headerlink" title="Docker安装RabbitMQ"></a>Docker安装RabbitMQ</h2><ul><li>下载镜像：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull rabbitmq:managementor        docker pull rabbitmq:<span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><ul><li>创建实例并启动：</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --name rabbitmq --publish <span class="hljs-number">5671</span>:<span class="hljs-number">5671</span> \--publish <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> --publish <span class="hljs-number">4369</span>:<span class="hljs-number">4369</span> --publish <span class="hljs-number">25672</span>:<span class="hljs-number">25672</span> --publish <span class="hljs-number">15671</span>:<span class="hljs-number">15671</span> --publish <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> \rabbitmq:managementordocker run -d --name rabbitmq<span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">15</span> \-p <span class="hljs-number">5671</span>:<span class="hljs-number">5671</span> -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> -p <span class="hljs-number">4369</span>:<span class="hljs-number">4369</span> -p <span class="hljs-number">25672</span>:<span class="hljs-number">25672</span> -p <span class="hljs-number">15671</span>:<span class="hljs-number">15671</span> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> \-d rabbitmq:<span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p><strong>注：</strong><br>4369 – erlang发现口<br>5672 –client端通信口</p><p>15672 – 管理界面ui端口<br>25672 – server间内部通信口</p><ul><li>设置开机启动</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker update rabbitmq <span class="hljs-attribute">--restart</span>=always    <span class="hljs-keyword">or</span> docker update rabbitmq3.7.15 <span class="hljs-attribute">--restart</span>=always    <br></code></pre></td></tr></table></figure><blockquote><p>在web浏览器中输入地址：http://虚拟机ip:15672/</p><p>输入默认账号: guest   : guest</p></blockquote><p><strong>端口：</strong></p><p>5672: rabbitMq的编程语言客户端连接端口</p><p>15672：rabbitMq管理界面端口</p><p>25672：rabbitMq集群的端口</p><hr><h2 id="Docker安装Tomcat"><a href="#Docker安装Tomcat" class="headerlink" title="Docker安装Tomcat"></a>Docker安装Tomcat</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#拉取Tomcat       注意jdk版本docker pull tomcat:jre8-slim# 为了复制server.xml和tomcat-users.xmldocker run --name tomcat8 -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> \-d tomcat:jre8-slim#复制  <span class="hljs-number">340</span>e188fc94e为该Tomcat容器的ID docker cp <span class="hljs-number">340</span>e188fc94e:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/tomcat/</span>conf<span class="hljs-regexp">/server.xml /my</span>data<span class="hljs-regexp">/tomcat/</span>conf<span class="hljs-regexp">/docker cp 340e188fc94e:/u</span>sr<span class="hljs-regexp">/local/</span>tomcat<span class="hljs-regexp">/conf/</span>tomcat-users.xml <span class="hljs-regexp">/mydata/</span>tomcat<span class="hljs-regexp">/conf/</span>#<span class="hljs-number">340</span>e188fc94e为Tomcat的IDdocker rm -f <span class="hljs-number">340</span>e188fc94e# --name指定容器名字 -v目录挂载 -p指定端口映射  -e设置mysql参数 -d后台运行docker run --name tomcat8 -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> \-v <span class="hljs-regexp">/mydata/</span>tomcat<span class="hljs-regexp">/webapps:/u</span>sr<span class="hljs-regexp">/local/</span>tomcat<span class="hljs-regexp">/webapps \-v /my</span>data<span class="hljs-regexp">/tomcat/</span>conf<span class="hljs-regexp">/server.xml:/u</span>sr<span class="hljs-regexp">/local/</span>tomcat<span class="hljs-regexp">/conf/</span>server.xml \-v <span class="hljs-regexp">/mydata/</span>tomcat<span class="hljs-regexp">/conf/</span>tomcat-users.xml:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/tomcat/</span>conf<span class="hljs-regexp">/tomcat-users.xml \-v /my</span>data<span class="hljs-regexp">/tomcat/</span>logs:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/tomcat/</span>logs \-d tomcat:jre8-slim#设置开机自启tomcat8docker update tomcat8  --restart=always<br></code></pre></td></tr></table></figure><ul><li><strong>试试另一版本</strong></li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#拉取另一版本docker pull tomcat:<span class="hljs-number">9</span>-jdk8# 为了复制server.xml和tomcat-users.xmldocker run --name tomcat9 -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> \-d tomcat:<span class="hljs-number">9</span>-jdk8mkdir -p <span class="hljs-regexp">/mydata/</span>tomcat9<span class="hljs-regexp">/conf#复制  a6c152a51e51为该Tomcat容器的ID docker cp a6c152a51e51:/u</span>sr<span class="hljs-regexp">/local/</span>tomcat<span class="hljs-regexp">/conf/</span>server.xml <span class="hljs-regexp">/mydata/</span>tomcat9<span class="hljs-regexp">/conf/</span>docker cp a6c152a51e51:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/tomcat/</span>conf<span class="hljs-regexp">/tomcat-users.xml /my</span>data<span class="hljs-regexp">/tomcat9/</span>conf<span class="hljs-regexp">/#340e188fc94e为Tomcat的IDdocker rm -f a6c152a51e51# --name指定容器名字 -v目录挂载 -p指定端口映射  -e设置mysql参数 -d后台运行docker run --name tomcat9 -p 8080:8080 \-v /my</span>data<span class="hljs-regexp">/tomcat9/</span>webapps:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/tomcat/</span>webapps \-v <span class="hljs-regexp">/mydata/</span>tomcat9<span class="hljs-regexp">/conf/</span>server.xml:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/tomcat/</span>conf<span class="hljs-regexp">/server.xml \-v /my</span>data<span class="hljs-regexp">/tomcat9/</span>conf<span class="hljs-regexp">/tomcat-users.xml:/u</span>sr<span class="hljs-regexp">/local/</span>tomcat<span class="hljs-regexp">/conf/</span>tomcat-users.xml \-v <span class="hljs-regexp">/mydata/</span>tomcat9<span class="hljs-regexp">/logs:/u</span>sr<span class="hljs-regexp">/local/</span>tomcat/logs \-d tomcat:<span class="hljs-number">9</span>-jdk8#设置开机自启tomcat9docker update tomcat9  --restart=always<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>MySQL</tag>
      
      <tag>Redis</tag>
      
      <tag>MongoDB</tag>
      
      <tag>ElasticSearch</tag>
      
      <tag>Nginx</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>Tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/03/22/Git%20%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/22/Git%20%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">git <span class="hljs-params">--version</span><span class="hljs-comment">#查看版本</span><br>git config <span class="hljs-params">--global</span> user.name <span class="hljs-string">&quot;chiyujiang&quot;</span><span class="hljs-comment">#配置你的名字</span><br>git config <span class="hljs-params">--global</span> user.email <span class="hljs-string">&quot;jiangzhilin320@outlook.com&quot;</span><span class="hljs-comment">#配置你的邮箱</span><br>git config <span class="hljs-params">--list</span><span class="hljs-comment">#查看你的配置</span><br></code></pre></td></tr></table></figure><h2 id="git基础命令"><a href="#git基础命令" class="headerlink" title="git基础命令"></a>git基础命令</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">git init            <span class="hljs-comment">#初始化仓库</span><br>git status          <span class="hljs-comment">#查看文件的状态</span><br>git diff            <span class="hljs-comment">#查看哪些修改还没有暂存   对比工作区和暂存区有不同的文件</span><br>git  diff <span class="hljs-params">--cache</span>   <span class="hljs-comment">#查看未提交的暂存</span><br><br>git add . <span class="hljs-comment">#把所有修改文件都添加到 缓存区</span><br>git add 文件名<span class="hljs-comment">#把当前文件添加到 缓存区</span><br><br>git commit -m <span class="hljs-string">&quot;注释内容&quot;</span><span class="hljs-comment">#把修改文件添加到 版本库</span><br>git commit -a -m <span class="hljs-string">&quot;注释内容&quot;</span>     <span class="hljs-comment">#参数设置修改文件后不需要执行 git add 命令，直接来提交</span><br><br>git rebase -i head~~<span class="hljs-comment">#合并最后两个commit</span><br><br>git log<span class="hljs-comment">#查看提交到版本库的日志</span><br>git log <span class="hljs-params">--oneline</span><span class="hljs-comment"># --oneline 选项来查看历史记录的简洁的版本</span><br><br>git reflog     <span class="hljs-comment">#查看所有的commit记录 包括commit的ID值，方便后面的回退</span><br><br><span class="hljs-comment">#回退版本</span><br><span class="hljs-params">--hard</span>回退版本库、暂存区、工作区<br><span class="hljs-params">--mixed</span>回退版本库、暂存区 （默认选择）<br><span class="hljs-params">--soft</span>回退版本库<br><span class="hljs-comment">#如：</span><br>git reset <span class="hljs-params">--hard</span> HEAD~    <span class="hljs-comment"># 回退1个版本  </span><br>git reset <span class="hljs-params">--hard</span> HEAD~n    <span class="hljs-comment"># 回退n个版本  </span><br>git reset <span class="hljs-params">--hard</span> comment的ID值   <span class="hljs-comment"># 回退到某个版本回退点之前的所有信息。 </span><br>git reset <span class="hljs-params">--hard</span> origin/master      <span class="hljs-comment"># 将本地的状态回退到和远程的一样 </span><br><br>git reset <span class="hljs-params">--soft</span> HEAD~<br>。。。。。。<br><br><br>git rm 文件名<span class="hljs-comment">#在工作区中删除文件</span><br>git mv 旧的文件名 新的文件名<span class="hljs-comment">#重命名</span><br>git checkout -- 文件名<span class="hljs-comment">#将文件从暂存区恢复到工作区</span><br><br><br></code></pre></td></tr></table></figure><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">分支的本质其实就是一个提交对象!!!<br><span class="hljs-symbol">HEAD:</span> 是一个指针 它默认指向master分支 切换分支时其实就是让HEAD指向不同的分支<br>  <br>git  log --oneline --decorate --graph --all : 查看整个项目的分支图  <br><br>git <span class="hljs-keyword">branch </span>               <span class="hljs-comment">#显示分支列表</span><br>git <span class="hljs-keyword">branch </span>分支名          <span class="hljs-comment">#创建分支</span><br>git checkout 分支名        <span class="hljs-comment">#切换分支</span><br>git <span class="hljs-keyword">branch </span>-d 分支名<span class="hljs-comment">#删除空的分支 删除已经被合并的分支</span><br>git <span class="hljs-keyword">branch </span>-D 分支名       <span class="hljs-comment">#强制删除分支</span><br><br><span class="hljs-comment">#在主分支下合并其他分支</span><br>git checkout master<br>git merge 分支名<br><br>git <span class="hljs-keyword">branch </span>-v<span class="hljs-comment">#查看分支指向的最新的提交</span><br><br></code></pre></td></tr></table></figure><h2 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h2><blockquote><p>远程协作的基本流程</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">1.</span> 初始化远程仓库<br>    初始化一个空的仓库; 在github上操作<br><span class="hljs-number">2.</span>创建本地仓库  <br>    <span class="hljs-meta">#创建好后有提示命令行操作</span><br>    <br>    git remote 别名 仓库地址(https)<br>    git <span class="hljs-keyword">init</span> <span class="hljs-meta">#将源码复制进来</span><br>    git config --<span class="hljs-keyword">global</span> user.name <span class="hljs-string">&quot;chiyujiang&quot;</span><span class="hljs-meta">#配置你的名字</span><br>    git config --<span class="hljs-keyword">global</span> user.email <span class="hljs-string">&quot;jiangzhilin320@outlook.com&quot;</span><span class="hljs-meta">#配置你的邮箱</span><br>    git <span class="hljs-keyword">add</span> .<br>    git commit -m <span class="hljs-string">&quot;注释&quot;</span> <br>    <br><span class="hljs-number">3.</span> 项目经理推送本地仓库到远程仓库<br>    <br>    git remote -v<span class="hljs-meta">#查看远程库</span><br>    git push  <span class="hljs-meta">#默认在master </span><br>    <br>    <span class="hljs-meta">#一般不在master操作</span><br>    git branch develop  <span class="hljs-meta">#可创建一个开发分支</span><br>    git checkout develop      <span class="hljs-meta">#切换到develop分支</span><br>    git <span class="hljs-keyword">add</span> .<br>    git commit -m <span class="hljs-string">&quot;注释&quot;</span><br>    git push --<span class="hljs-keyword">set</span>-upstream origin develop    <span class="hljs-meta">#推送到远程仓库并建一个 develop 分支</span><br>    <br>    <br> <span class="hljs-number">4.</span> 项目邀请成员 &amp; 成员接受邀请<br>   清理windows凭据<br>      在github上操作  <br><br><span class="hljs-number">5.</span> 成员克隆远程仓库<br>    git clone  仓库地址 (在本地生成.git文件 默认为远程仓库配了别名 orgin) <br>如: git clone https:<span class="hljs-comment">//gitee.com/chiyujiang/git-demo.git</span><br>    注：只有在克隆的时候 本地分支master 和 远程跟踪分支别名/master 是有同步关系的<br><span class="hljs-number">6.</span> 成员做出贡献<br>    应创建新的分支<br>    git branch feature-f1  <span class="hljs-meta">#可创建一个成员自己的开发分支</span><br>    git checkout feature-f1      <span class="hljs-meta">#切换到feature-f1分支</span><br>    修改源码文件<br>    git <span class="hljs-keyword">add</span> .<br>    git commit -m <span class="hljs-string">&quot;注释&quot;</span>  <br>    git push --<span class="hljs-keyword">set</span>-upstream origin feature-f1 (输入用户名 密码;推完之后会附带生成远程跟踪分支) <br>    <br><span class="hljs-number">7.</span> 项目经理更新修改<br>    git fetch 别名 (将修改同步到远程跟踪分支上)<br>    git merge 远程跟踪分支<br></code></pre></td></tr></table></figure><h2 id="SSH公钥"><a href="#SSH公钥" class="headerlink" title="SSH公钥"></a>SSH公钥</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment">#使用以下命令生成 SSH Key</span><br>$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;jiangzhilin320@outlook.com&quot;</span><br><br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa):<br>/c/Users/Administrator/.ssh/id_rsa already exists.<br>Overwrite (y/n)? y<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa<br>Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.pub     <span class="hljs-comment">#公钥在这文件路径下</span><br>The key fingerprint is:<br>SHA256:ahlXZY2UZDn1FdhapT6wTEnPXijT1S7Z5P8s0NVKyQs jiangzhilin320<span class="hljs-meta">@outlook.com</span><br>The key&#x27;s randomart image is:<br>+---[RSA 3072]----+<br>|<span class="hljs-string">           oB*+.B</span>|<br>|<span class="hljs-string">           ==*.B+</span>|<br>|<span class="hljs-string">          . *oOB+</span>|<br>|<span class="hljs-string">         . oEO*.*</span>|<br>|<span class="hljs-string">      . S   o++=.</span>|<br>|<span class="hljs-string">       =    . +..</span>|<br>|<span class="hljs-string">      +      . ..</span>|<br>|<span class="hljs-string">     .        . o</span>|<br>|<span class="hljs-string">               . </span>|<br>+----[SHA256]-----+<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/03/22/Git/"/>
    <url>/2021/03/22/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">git <span class="hljs-params">--version</span><span class="hljs-comment">#查看版本</span><br>git config <span class="hljs-params">--global</span> user.name <span class="hljs-string">&quot;chiyujiang&quot;</span><span class="hljs-comment">#配置你的名字</span><br>git config <span class="hljs-params">--global</span> user.email <span class="hljs-string">&quot;jiangzhilin320@outlook.com&quot;</span><span class="hljs-comment">#配置你的邮箱</span><br>git config <span class="hljs-params">--list</span><span class="hljs-comment">#查看你的配置</span><br></code></pre></td></tr></table></figure><h2 id="git基础命令"><a href="#git基础命令" class="headerlink" title="git基础命令"></a>git基础命令</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">git init            <span class="hljs-comment">#初始化仓库</span><br>git status          <span class="hljs-comment">#查看文件的状态</span><br>git diff            <span class="hljs-comment">#查看哪些修改还没有暂存   对比工作区和暂存区有不同的文件</span><br>git  diff <span class="hljs-params">--cache</span>   <span class="hljs-comment">#查看未提交的暂存</span><br><br>git add . <span class="hljs-comment">#把所有修改文件都添加到 缓存区</span><br>git add 文件名<span class="hljs-comment">#把当前文件添加到 缓存区</span><br><br>git commit -m <span class="hljs-string">&quot;注释内容&quot;</span><span class="hljs-comment">#把修改文件添加到 版本库</span><br>git commit -a -m <span class="hljs-string">&quot;注释内容&quot;</span>     <span class="hljs-comment">#参数设置修改文件后不需要执行 git add 命令，直接来提交</span><br><br>git rebase -i head~~<span class="hljs-comment">#合并最后两个commit</span><br><br>git log<span class="hljs-comment">#查看提交到版本库的日志</span><br>git log <span class="hljs-params">--oneline</span><span class="hljs-comment"># --oneline 选项来查看历史记录的简洁的版本</span><br><br>git reflog     <span class="hljs-comment">#查看所有的commit记录 包括commit的ID值，方便后面的回退</span><br><br><span class="hljs-comment">#回退版本</span><br><span class="hljs-params">--hard</span>回退版本库、暂存区、工作区<br><span class="hljs-params">--mixed</span>回退版本库、暂存区 （默认选择）<br><span class="hljs-params">--soft</span>回退版本库<br><span class="hljs-comment">#如：</span><br>git reset <span class="hljs-params">--hard</span> HEAD~    <span class="hljs-comment"># 回退1个版本  </span><br>git reset <span class="hljs-params">--hard</span> HEAD~n    <span class="hljs-comment"># 回退n个版本  </span><br>git reset <span class="hljs-params">--hard</span> comment的ID值   <span class="hljs-comment"># 回退到某个版本回退点之前的所有信息。 </span><br>git reset <span class="hljs-params">--hard</span> origin/master      <span class="hljs-comment"># 将本地的状态回退到和远程的一样 </span><br><br>git reset <span class="hljs-params">--soft</span> HEAD~<br>。。。。。。<br><br><br>git rm 文件名<span class="hljs-comment">#在工作区中删除文件</span><br>git mv 旧的文件名 新的文件名<span class="hljs-comment">#重命名</span><br>git checkout -- 文件名<span class="hljs-comment">#将文件从暂存区恢复到工作区</span><br><br><br></code></pre></td></tr></table></figure><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">分支的本质其实就是一个提交对象!!!<br><span class="hljs-symbol">HEAD:</span> 是一个指针 它默认指向master分支 切换分支时其实就是让HEAD指向不同的分支<br>  <br>git  log --oneline --decorate --graph --all : 查看整个项目的分支图  <br><br>git <span class="hljs-keyword">branch </span>               <span class="hljs-comment">#显示分支列表</span><br>git <span class="hljs-keyword">branch </span>分支名          <span class="hljs-comment">#创建分支</span><br>git checkout 分支名        <span class="hljs-comment">#切换分支</span><br>git <span class="hljs-keyword">branch </span>-d 分支名<span class="hljs-comment">#删除空的分支 删除已经被合并的分支</span><br>git <span class="hljs-keyword">branch </span>-D 分支名       <span class="hljs-comment">#强制删除分支</span><br><br><span class="hljs-comment">#在主分支下合并其他分支</span><br>git checkout master<br>git merge 分支名<br><br>git <span class="hljs-keyword">branch </span>-v<span class="hljs-comment">#查看分支指向的最新的提交</span><br><br></code></pre></td></tr></table></figure><h2 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h2><blockquote><p>远程协作的基本流程</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">1.</span> 初始化远程仓库<br>    初始化一个空的仓库; 在github上操作<br><span class="hljs-number">2.</span>创建本地仓库  <br>    <span class="hljs-meta">#创建好后有提示命令行操作</span><br>    <br>    git remote 别名 仓库地址(https)<br>    git <span class="hljs-keyword">init</span> <span class="hljs-meta">#将源码复制进来</span><br>    git config --<span class="hljs-keyword">global</span> user.name <span class="hljs-string">&quot;chiyujiang&quot;</span><span class="hljs-meta">#配置你的名字</span><br>    git config --<span class="hljs-keyword">global</span> user.email <span class="hljs-string">&quot;jiangzhilin320@outlook.com&quot;</span><span class="hljs-meta">#配置你的邮箱</span><br>    git <span class="hljs-keyword">add</span> .<br>    git commit -m <span class="hljs-string">&quot;注释&quot;</span> <br>    <br><span class="hljs-number">3.</span> 项目经理推送本地仓库到远程仓库<br>    <br>    git remote -v<span class="hljs-meta">#查看远程库</span><br>    git push  <span class="hljs-meta">#默认在master </span><br>    <br>    <span class="hljs-meta">#一般不在master操作</span><br>    git branch develop  <span class="hljs-meta">#可创建一个开发分支</span><br>    git checkout develop      <span class="hljs-meta">#切换到develop分支</span><br>    git <span class="hljs-keyword">add</span> .<br>    git commit -m <span class="hljs-string">&quot;注释&quot;</span><br>    git push --<span class="hljs-keyword">set</span>-upstream origin develop    <span class="hljs-meta">#推送到远程仓库并建一个 develop 分支</span><br>    <br>    <br> <span class="hljs-number">4.</span> 项目邀请成员 &amp; 成员接受邀请<br>   清理windows凭据<br>      在github上操作  <br><br><span class="hljs-number">5.</span> 成员克隆远程仓库<br>    git clone  仓库地址 (在本地生成.git文件 默认为远程仓库配了别名 orgin) <br>如: git clone https:<span class="hljs-comment">//gitee.com/chiyujiang/git-demo.git</span><br>    注：只有在克隆的时候 本地分支master 和 远程跟踪分支别名/master 是有同步关系的<br><span class="hljs-number">6.</span> 成员做出贡献<br>    应创建新的分支<br>    git branch feature-f1  <span class="hljs-meta">#可创建一个成员自己的开发分支</span><br>    git checkout feature-f1      <span class="hljs-meta">#切换到feature-f1分支</span><br>    修改源码文件<br>    git <span class="hljs-keyword">add</span> .<br>    git commit -m <span class="hljs-string">&quot;注释&quot;</span>  <br>    git push --<span class="hljs-keyword">set</span>-upstream origin feature-f1 (输入用户名 密码;推完之后会附带生成远程跟踪分支) <br>    <br><span class="hljs-number">7.</span> 项目经理更新修改<br>    git fetch 别名 (将修改同步到远程跟踪分支上)<br>    git merge 远程跟踪分支<br></code></pre></td></tr></table></figure><h2 id="SSH公钥"><a href="#SSH公钥" class="headerlink" title="SSH公钥"></a>SSH公钥</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment">#使用以下命令生成 SSH Key</span><br>$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;jiangzhilin320@outlook.com&quot;</span><br><br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa):<br>/c/Users/Administrator/.ssh/id_rsa already exists.<br>Overwrite (y/n)? y<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa<br>Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.pub     <span class="hljs-comment">#公钥在这文件路径下</span><br>The key fingerprint is:<br>SHA256:ahlXZY2UZDn1FdhapT6wTEnPXijT1S7Z5P8s0NVKyQs jiangzhilin320<span class="hljs-meta">@outlook.com</span><br>The key&#x27;s randomart image is:<br>+---[RSA 3072]----+<br>|<span class="hljs-string">           oB*+.B</span>|<br>|<span class="hljs-string">           ==*.B+</span>|<br>|<span class="hljs-string">          . *oOB+</span>|<br>|<span class="hljs-string">         . oEO*.*</span>|<br>|<span class="hljs-string">      . S   o++=.</span>|<br>|<span class="hljs-string">       =    . +..</span>|<br>|<span class="hljs-string">      +      . ..</span>|<br>|<span class="hljs-string">     .        . o</span>|<br>|<span class="hljs-string">               . </span>|<br>+----[SHA256]-----+<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 笔记</title>
    <link href="/2021/03/22/Redis%20%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/22/Redis%20%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-NoSQL的引言"><a href="#1-NoSQL的引言" class="headerlink" title="1.  NoSQL的引言"></a>1.  NoSQL的引言</h2><p><strong>NoSQL</strong>(<code> Not Only SQL</code> )，意即<strong>不仅仅是SQL</strong>, 泛指非关系型的数据库。Nosql这个技术门类,早期就有人提出,发展至2009年趋势越发高涨。</p><h2 id="2-为什么是NoSQL"><a href="#2-为什么是NoSQL" class="headerlink" title="2. 为什么是NoSQL"></a>2. 为什么是NoSQL</h2><p>随着互联网网站的兴起，传统的关系数据库在应付动态网站，特别是超大规模和高并发的纯动态网站已经显得力不从心，暴露了很多难以克服的问题。如<code>商城网站中对商品数据频繁查询</code>、<code>对热搜商品的排行统计</code>、<code>订单超时问题</code>、以及微信朋友圈（音频，视频）存储等相关使用传统的关系型数据库实现就显得非常复杂，虽然能实现相应功能但是在性能上却不是那么乐观。nosql这个技术门类的出现，更好的解决了这些问题，它告诉了世界不仅仅是sql。</p><h2 id="3-NoSQL的四大分类"><a href="#3-NoSQL的四大分类" class="headerlink" title="3. NoSQL的四大分类"></a>3. NoSQL的四大分类</h2><h3 id="3-1-键值-Key-Value-存储数据库"><a href="#3-1-键值-Key-Value-存储数据库" class="headerlink" title="3.1 键值(Key-Value)存储数据库"></a>3.1 键值(Key-Value)存储数据库</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明: </span><br><span class="hljs-bullet">-</span> 这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。<br><br><span class="hljs-section"># 2.特点</span><br><span class="hljs-bullet">-</span> Key/value模型对于IT系统来说的优势在于简单、易部署。  <br><span class="hljs-bullet">-</span> 但是如果DBA只对部分值进行查询或更新的时候，Key/value就显得效率低下了。<br><br><span class="hljs-section"># 3.相关产品</span><br><span class="hljs-bullet">-</span> Tokyo Cabinet/Tyrant,<br><span class="hljs-bullet">-</span> Redis<br><span class="hljs-bullet">-</span> SSDB<br><span class="hljs-bullet">-</span> Voldemort <br><span class="hljs-bullet">-</span> Oracle BDB<br></code></pre></td></tr></table></figure><h3 id="3-2-列存储数据库"><a href="#3-2-列存储数据库" class="headerlink" title="3.2 列存储数据库"></a>3.2 列存储数据库</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明</span><br><span class="hljs-bullet">-</span> 这部分数据库通常是用来应对分布式存储的海量数据。<br><br><span class="hljs-section"># 2.特点</span><br><span class="hljs-bullet">-</span> 键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。<br><br><span class="hljs-section"># 3.相关产品</span><br><span class="hljs-bullet">-</span> Cassandra、HBase、Riak.<br></code></pre></td></tr></table></figure><h3 id="3-3-文档型数据库"><a href="#3-3-文档型数据库" class="headerlink" title="3.3 文档型数据库"></a>3.3 文档型数据库</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明</span><br><span class="hljs-bullet">-</span> 文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高<br><br><span class="hljs-section"># 2.特点</span><br><span class="hljs-bullet">-</span> 以文档形式存储<br><br><span class="hljs-section"># 3.相关产品</span><br><span class="hljs-bullet">-</span> MongoDB、CouchDB、 MongoDb(4.x). 国内也有文档型数据库SequoiaDB，已经开源。<br></code></pre></td></tr></table></figure><h3 id="3-4-图形-Graph-数据库"><a href="#3-4-图形-Graph-数据库" class="headerlink" title="3.4 图形(Graph)数据库"></a>3.4 图形(Graph)数据库</h3> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.说明</span><br><span class="hljs-bullet">-</span> 图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。<br><span class="hljs-bullet">-</span> NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。<br><br><span class="hljs-section"># 2.特点</span><br><br><span class="hljs-section"># 3.相关产品</span><br><span class="hljs-bullet">-</span> Neo4J、InfoGrid、 Infinite Graph、<br></code></pre></td></tr></table></figure><hr><h2 id="4-NoSQL应用场景"><a href="#4-NoSQL应用场景" class="headerlink" title="4. NoSQL应用场景"></a>4. NoSQL应用场景</h2><ul><li><p>数据模型比较简单</p></li><li><p>需要灵活性更强的IT系统</p></li><li><p>对数据库性能要求较高</p></li><li><p>不需要高度的数据一致性</p></li></ul><h2 id="5-什么是Redis"><a href="#5-什么是Redis" class="headerlink" title="5. 什么是Redis"></a>5. 什么是Redis</h2><p><img src="/images/imgRedis/image-20200623121234046.png" alt="image-20200623121234046"></p><blockquote><p>Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache and message broker.</p></blockquote><p>Redis 开源  遵循BSD  基于内存数据存储 被用于作为 数据库 缓存  消息中间件</p><ul><li>总结: redis是一个内存型的数据库</li></ul><h2 id="6-Redis特点"><a href="#6-Redis特点" class="headerlink" title="6. Redis特点"></a>6. Redis特点</h2><ul><li><p> Redis是一个高性能key/value内存型数据库</p></li><li><p>Redis支持丰富的数据类型 </p></li><li><p>Redis支持持久化 </p></li><li><p>Redis单线程,单进程</p></li></ul><hr><h2 id="7-Redis安装"><a href="#7-Redis安装" class="headerlink" title="7. Redis安装"></a>7. Redis安装</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 0.准备环境</span><br><span class="hljs-bullet">-</span> vmware15.x+<br><span class="hljs-bullet">-</span> centos7.x+<br><br><span class="hljs-section"># 1.下载redis源码包</span><br><span class="hljs-bullet">-</span> https://redis.io/<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623121621195.png" alt="image-20200623121621195"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 2.下载完整源码包</span><br><span class="hljs-bullet">-</span> redis-4.0.10.tar.gz<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623123918876.png" alt="image-20200623123918876"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 3.将下载redis资料包上传到Linux中</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623124327319.png" alt="image-20200623124327319"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 4.解压缩文件</span><br>[root@localhost ~]# tar -zxvf redis-4.0.10.tar.gz<br>[root@localhost ~]# ll<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623124522026.png" alt="image-20200623124522026"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 5.安装gcc  </span><br><span class="hljs-bullet">-</span> yum install -y gcc<br><br><span class="hljs-section"># 6.进入解压缩目录执行如下命令</span><br><span class="hljs-bullet">-</span> make MALLOC=libc<br><br><span class="hljs-section"># 7.编译完成后执行如下命令</span><br><span class="hljs-bullet">-</span> make install PREFIX=/usr/redis<br><br><span class="hljs-section"># 8.进入/usr/redis目录启动redis服务 </span><br><span class="hljs-bullet">-</span> ./redis-server<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623125420505.png" alt="image-20200623125420505"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 9.Redis服务端口默认是 6379</span><br><br><span class="hljs-section"># 10.进入bin目录执行客户端连接操作</span><br><span class="hljs-bullet">-</span> ./redis-cli –p 6379<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623125716013.png" alt="image-20200623125716013"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 11.连接成功出现上面界面连接成功</span><br></code></pre></td></tr></table></figure><h2 id="8-Redis数据库相关指令"><a href="#8-Redis数据库相关指令" class="headerlink" title="8. Redis数据库相关指令"></a>8. Redis数据库相关指令</h2><h3 id="8-1-数据库操作指令"><a href="#8-1-数据库操作指令" class="headerlink" title="8.1 数据库操作指令"></a>8.1 数据库操作指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.Redis中库说明</span><br><span class="hljs-bullet">-</span> 使用redis的默认配置器动redis服务后,默认会存在16个库,编号从0-15<br><span class="hljs-bullet">-</span> 可以使用select 库的编号 来选择一个redis的库<br><br><span class="hljs-section"># 2.Redis中操作库的指令</span><br><span class="hljs-bullet">-</span> 清空当前的库  FLUSHDB<br><span class="hljs-bullet">-</span> 清空全部的库  FLUSHALL<br><br><span class="hljs-section"># 3.redis客户端显示中文</span><br><span class="hljs-bullet">-</span>./redis-cli  -p 7000 --raw<br></code></pre></td></tr></table></figure><h3 id="8-2-操作key相关指令"><a href="#8-2-操作key相关指令" class="headerlink" title="8.2 操作key相关指令"></a>8.2 操作key相关指令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.DEL指令</span><br><span class="hljs-bullet">-</span> 语法 :  DEL key [key ...] <br><span class="hljs-bullet">-</span> 作用 :  删除给定的一个或多个key 。不存在的key 会被忽略。<br><span class="hljs-bullet">-</span> 可用版本： &gt;= 1.0.0<br><span class="hljs-bullet">-</span> 返回值： 被删除key 的数量。 <br><br><span class="hljs-section"># 2.EXISTS指令</span><br><span class="hljs-bullet">-</span> 语法:  EXISTS key<br><span class="hljs-bullet">-</span> 作用:  检查给定key 是否存在。<br><span class="hljs-bullet">-</span> 可用版本： &gt;= 1.0.0<br><span class="hljs-bullet">-</span> 返回值： 若key 存在，返回1 ，否则返回0。<br><br><span class="hljs-section"># 3.EXPIRE</span><br><span class="hljs-bullet">-</span> 语法:  EXPIRE key seconds<br><span class="hljs-bullet">-</span> 作用:  为给定key 设置生存时间，当key 过期时(生存时间为0 )，它会被自动删除。<br><span class="hljs-bullet">-</span> 可用版本： &gt;= 1.0.0<br><span class="hljs-bullet">-</span> 时间复杂度： O(1)<br><span class="hljs-bullet">-</span> 返回值：设置成功返回1 。<br><br><span class="hljs-section"># 4.KEYS</span><br><span class="hljs-bullet">-</span> 语法 :  KEYS pattern<br><span class="hljs-bullet">-</span> 作用 :  查找所有符合给定模式pattern 的key 。<br><span class="hljs-bullet">-</span> 语法:<br><span class="hljs-code">KEYS * 匹配数据库中所有key 。</span><br><span class="hljs-code">KEYS h?llo 匹配hello ，hallo 和hxllo 等。</span><br><span class="hljs-code">KEYS h*llo 匹配hllo 和heeeeello 等。</span><br><span class="hljs-code">KEYS h[ae]llo 匹配hello 和hallo ，但不匹配hillo 。特殊符号用 &quot;\&quot; 隔开</span><br><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><br><span class="hljs-code">- 返回值： 符合给定模式的key 列表。</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 5.MOVE</span><br><span class="hljs-code">- 语法 :  MOVE key db</span><br><span class="hljs-code">- 作用 :  将当前数据库的key 移动到给定的数据库db 当中。</span><br><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><br><span class="hljs-code">- 返回值： 移动成功返回1 ，失败则返回0 。</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 6.PEXPIRE</span><br><span class="hljs-code">- 语法 :  PEXPIRE key milliseconds</span><br><span class="hljs-code">- 作用 :  这个命令和EXPIRE 命令的作用类似，但是它以毫秒为单位设置key 的生存时间，而不像EXPIRE 命令那样，以秒为单位。</span><br><span class="hljs-code">- 可用版本： &gt;= 2.6.0</span><br><span class="hljs-code">- 时间复杂度： O(1)</span><br><span class="hljs-code">- 返回值：设置成功，返回1  key 不存在或设置失败，返回0</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 7.PEXPIREAT</span><br><span class="hljs-code">- 语法 :  PEXPIREAT key milliseconds-timestamp</span><br><span class="hljs-code">- 作用 :  这个命令和EXPIREAT 命令类似，但它以毫秒为单位设置key 的过期unix 时间戳，而不是像EXPIREAT那样，以秒为单位。</span><br><span class="hljs-code">- 可用版本： &gt;= 2.6.0</span><br><span class="hljs-code">- 返回值：如果生存时间设置成功，返回1 。当key 不存在或没办法设置生存时间时，返回0 。(查看EXPIRE 命令获取更多信息)</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 8.TTL</span><br><span class="hljs-code">- 语法 :   TTL key</span><br><span class="hljs-code">- 作用 :   以秒为单位，返回给定key 的剩余生存时间(TTL, time to live)。</span><br><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><br><span class="hljs-code">- 返回值：</span><br><span class="hljs-code">当key 不存在时，返回-2 。</span><br><span class="hljs-code">当key 存在但没有设置剩余生存时间时，返回-1 。</span><br><span class="hljs-code">否则，以秒为单位，返回key 的剩余生存时间。</span><br><span class="hljs-code">- Note : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 9.PTTL</span><br><span class="hljs-code">- 语法 :  PTTL key</span><br><span class="hljs-code">- 作用 :  这个命令类似于TTL 命令，但它以毫秒为单位返回key 的剩余生存时间，而不是像TTL 命令那样，以秒为单位。</span><br><span class="hljs-code">- 可用版本： &gt;= 2.6.0</span><br><span class="hljs-code">- 返回值： 当key 不存在时，返回-2 。当key 存在但没有设置剩余生存时间时，返回-1 。</span><br><span class="hljs-code">- 否则，以毫秒为单位，返回key 的剩余生存时间。</span><br><span class="hljs-code">- 注意 : 在Redis 2.8 以前，当key 不存在，或者key 没有设置剩余生存时间时，命令都返回-1 。</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 10.RANDOMKEY</span><br><span class="hljs-code">- 语法 :  RANDOMKEY</span><br><span class="hljs-code">- 作用 :  从当前数据库中随机返回(不删除) 一个key 。</span><br><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><br><span class="hljs-code">- 返回值：当数据库不为空时，返回一个key 。当数据库为空时，返回nil 。</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 11.RENAME</span><br><span class="hljs-code">- 语法 :  RENAME key newkey</span><br><span class="hljs-code">- 作用 :  将key 改名为newkey 。当key 和newkey 相同，或者key 不存在时，返回一个错误。当newkey 已经存在时，RENAME 命令将覆盖旧值。</span><br><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><br><span class="hljs-code">- 返回值： 改名成功时提示OK ，失败时候返回一个错误。</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 12.TYPE</span><br><span class="hljs-code">- 语法 :  TYPE key</span><br><span class="hljs-code">- 作用 :  返回key 所储存的值的类型。</span><br><span class="hljs-code">- 可用版本： &gt;= 1.0.0</span><br><span class="hljs-code">- 返回值：</span><br><span class="hljs-code">none (key 不存在)</span><br><span class="hljs-code">string (字符串)</span><br><span class="hljs-code">list (列表)</span><br><span class="hljs-code">set (集合)</span><br><span class="hljs-code">zset (有序集)</span><br><span class="hljs-code">hash (哈希表)</span><br></code></pre></td></tr></table></figure><h3 id="8-3-String类型"><a href="#8-3-String类型" class="headerlink" title="8.3 String类型"></a>8.3 String类型</h3><h4 id="1-内存存储模型"><a href="#1-内存存储模型" class="headerlink" title="1. 内存存储模型"></a>1. 内存存储模型</h4><p><img src="/images/imgRedis/image-20200623132104399.png" alt="image-20200623132104399"></p><h4 id="2-常用操作命令"><a href="#2-常用操作命令" class="headerlink" title="2. 常用操作命令"></a>2. 常用操作命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>set</td><td>设置一个key/value</td></tr><tr><td>get</td><td>根据key获得对应的value</td></tr><tr><td>mset</td><td>一次设置多个key value</td></tr><tr><td>mget</td><td>一次获得多个key的value</td></tr><tr><td>getset</td><td>获得原始key的值，同时设置新值</td></tr><tr><td>strlen</td><td>获得对应key存储value的长度</td></tr><tr><td>append</td><td>为对应key的value追加内容</td></tr><tr><td>getrange 索引0开始</td><td>截取value的内容</td></tr><tr><td>setex</td><td>设置一个key存活的有效期（秒）</td></tr><tr><td>psetex</td><td>设置一个key存活的有效期（毫秒）</td></tr><tr><td>setnx</td><td>存在不做任何操作,不存在添加</td></tr><tr><td>msetnx原子操作(只要有一个存在不做任何操作)</td><td>可以同时设置多个key,只有有一个存在都不保存</td></tr><tr><td>decr</td><td>进行数值类型的-1操作</td></tr><tr><td>decrby</td><td>根据提供的数据进行减法操作</td></tr><tr><td>Incr</td><td>进行数值类型的+1操作</td></tr><tr><td>incrby</td><td>根据提供的数据进行加法操作</td></tr><tr><td>Incrbyfloat</td><td>根据提供的数据加入浮点数</td></tr></tbody></table><h3 id="8-4-List类型"><a href="#8-4-List类型" class="headerlink" title="8.4 List类型"></a>8.4 List类型</h3><p>list 列表 相当于java中list 集合  特点  元素有序  且 可以重复</p><h4 id="1-内存存储模型-1"><a href="#1-内存存储模型-1" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p><img src="/images/imgRedis/image-20200623161114380.png" alt="image-20200623161114380"></p><h4 id="2-常用操作指令"><a href="#2-常用操作指令" class="headerlink" title="2.常用操作指令"></a>2.常用操作指令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>lpush</td><td>将某个值加入到一个key列表头部</td></tr><tr><td>lpushx</td><td>同lpush,但是必须要保证这个key存在</td></tr><tr><td>rpush</td><td>将某个值加入到一个key列表末尾</td></tr><tr><td>rpushx</td><td>同rpush,但是必须要保证这个key存在</td></tr><tr><td>lpop</td><td>返回和移除列表左边的第一个元素</td></tr><tr><td>rpop</td><td>返回和移除列表右边的第一个元素</td></tr><tr><td>lrange</td><td>获取某一个下标区间内的元素</td></tr><tr><td>llen</td><td>获取列表元素个数</td></tr><tr><td>lset</td><td>设置某一个指定索引的值(索引必须存在)</td></tr><tr><td>lindex</td><td>获取某一个指定索引位置的元素</td></tr><tr><td>lrem</td><td>删除重复元素</td></tr><tr><td>ltrim</td><td>保留列表中特定区间内的元素</td></tr><tr><td>linsert</td><td>在某一个元素之前，之后插入新元素</td></tr></tbody></table><h3 id="8-5-Set类型"><a href="#8-5-Set类型" class="headerlink" title="8.5 Set类型"></a>8.5 Set类型</h3><p>特点: Set类型 Set集合 元素无序  不可以重复</p><h4 id="1-内存存储模型-2"><a href="#1-内存存储模型-2" class="headerlink" title="1.内存存储模型"></a>1.内存存储模型</h4><p><img src="/images/imgRedis/image-20200623193634316.png" alt="image-20200623193634316"></p><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>sadd</td><td>为集合添加元素</td></tr><tr><td>smembers</td><td>显示集合中所有元素 无序</td></tr><tr><td>scard</td><td>返回集合中元素的个数</td></tr><tr><td>spop</td><td>随机返回一个元素 并将元素在集合中删除</td></tr><tr><td>smove</td><td>从一个集合中向另一个集合移动元素  必须是同一种类型</td></tr><tr><td>srem</td><td>从集合中删除一个元素</td></tr><tr><td>sismember</td><td>判断一个集合中是否含有这个元素</td></tr><tr><td>srandmember</td><td>随机返回元素</td></tr><tr><td>sdiff</td><td>去掉第一个集合中其它集合含有的相同元素</td></tr><tr><td>sinter</td><td>求交集</td></tr><tr><td>sunion</td><td>求和集</td></tr></tbody></table><h3 id="8-6-ZSet类型"><a href="#8-6-ZSet类型" class="headerlink" title="8.6 ZSet类型"></a>8.6 ZSet类型</h3><p>特点: 可排序的set集合  排序  不可重复 </p><p>ZSET 官方  可排序SET  sortSet   </p><h4 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p><img src="/images/imgRedis/image-20200623194903967.png" alt="image-20200623194903967"></p><h4 id="2-常用命令-1"><a href="#2-常用命令-1" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>zadd</td><td>添加一个有序集合元素</td></tr><tr><td>zcard</td><td>返回集合的元素个数</td></tr><tr><td>zrange 升序 zrevrange 降序</td><td>返回一个范围内的元素</td></tr><tr><td>zrangebyscore</td><td>按照分数查找一个范围内的元素</td></tr><tr><td>zrank</td><td>返回排名</td></tr><tr><td>zrevrank</td><td>倒序排名</td></tr><tr><td>zscore</td><td>显示某一个元素的分数</td></tr><tr><td>zrem</td><td>移除某一个元素</td></tr><tr><td>zincrby</td><td>给某个特定元素加分</td></tr></tbody></table><h3 id="8-7-hash类型"><a href="#8-7-hash类型" class="headerlink" title="8.7 hash类型"></a>8.7 hash类型</h3><p>特点: value 是一个map结构 存在key value  key 无序的  </p><h4 id="1-内存模型-1"><a href="#1-内存模型-1" class="headerlink" title="1.内存模型"></a>1.内存模型</h4><p><img src="/images/imgRedis/image-20200623200348408.png" alt="image-20200623200348408"></p><h4 id="2-常用命令-2"><a href="#2-常用命令-2" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>hset</td><td>设置一个key/value对</td></tr><tr><td>hget</td><td>获得一个key对应的value</td></tr><tr><td>hgetall</td><td>获得所有的key/value对</td></tr><tr><td>hdel</td><td>删除某一个key/value对</td></tr><tr><td>hexists</td><td>判断一个key是否存在</td></tr><tr><td>hkeys</td><td>获得所有的key</td></tr><tr><td>hvals</td><td>获得所有的value</td></tr><tr><td>hmset</td><td>设置多个key/value</td></tr><tr><td>hmget</td><td>获得多个key的value</td></tr><tr><td>hsetnx</td><td>设置一个不存在的key的值</td></tr><tr><td>hincrby</td><td>为value进行加法运算</td></tr><tr><td>hincrbyfloat</td><td>为value加入浮点值</td></tr></tbody></table><hr><h2 id="9-持久化机制"><a href="#9-持久化机制" class="headerlink" title="9. 持久化机制"></a>9. 持久化机制</h2><p>client  redis[内存] —–&gt;  内存数据- 数据持久化–&gt;磁盘</p><p>Redis官方提供了两种不同的持久化方法来将数据存储到硬盘里面分别是:</p><ul><li>快照(Snapshot)</li><li>AOF (Append Only File) 只追加日志文件</li></ul><h3 id="9-1-快照-Snapshot"><a href="#9-1-快照-Snapshot" class="headerlink" title="9.1 快照(Snapshot)"></a>9.1 快照(Snapshot)</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h4><p>这种方式可以将某一时刻的所有数据都写入硬盘中,当然这也是<strong>redis的默认开启持久化方式</strong>,保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB方式。</p><p><img src="/images/imgRedis/image-20200623204303074.png" alt="image-20200623204303074"></p><h4 id="2-快照生成方式"><a href="#2-快照生成方式" class="headerlink" title="2.快照生成方式"></a>2.快照生成方式</h4><ul><li>客户端方式: BGSAVE 和 SAVE指令</li><li>服务器配置自动触发</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.客户端方式之BGSAVE</span><br><span class="hljs-bullet">-</span> a.客户端可以使用BGSAVE命令来创建一个快照,当接收到客户端的BGSAVE命令时,redis会调用fork¹来创建一个子进程,然后子进程负责将快照写入磁盘中,而父进程则继续处理命令请求。<br><span class="hljs-code"></span><br><span class="hljs-code">`名词解释: fork当一个进程创建子进程的时候,底层的操作系统会创建该进程的一个副本,在类unix系统中创建子进程的操作会进行优化:在刚开始的时候,父子进程共享相同内存,直到父进程或子进程对内存进行了写之后,对被写入的内存的共享才会结束服务`</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623205132460.png" alt="image-20200623205132460"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 2.客户端方式之SAVE</span><br><span class="hljs-bullet">-</span> b.客户端还可以使用SAVE命令来创建一个快照,接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623205444101.png" alt="image-20200623205444101"></p><ul><li><strong>注意: SAVE命令并不常用,使用SAVE命令在快照创建完毕之前,redis处于阻塞状态,无法对外服务</strong></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 3.服务器配置方式之满足配置自动触发</span><br><span class="hljs-bullet">-</span> 如果用户在redis.conf中设置了save配置选项,redis会在save选项条件满足之后自动触发一次BGSAVE命令,如果设置多个save配置选项,当任意一个save配置选项条件满足,redis也会触发一次BGSAVE命令<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623210021012.png" alt="image-20200623210021012"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 4.服务器接收客户端shutdown指令</span><br><span class="hljs-bullet">-</span> 当redis通过shutdown指令接收到关闭服务器的请求时,会执行一个save命令,阻塞所有的客户端,不再执行客户端执行发送的任何命令,并且在save命令执行完毕之后关闭服务器<br></code></pre></td></tr></table></figure><h4 id="3-配置生成快照名称和位置"><a href="#3-配置生成快照名称和位置" class="headerlink" title="3.配置生成快照名称和位置"></a>3.配置生成快照名称和位置</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">#1.修改生成快照名称</span><br><span class="hljs-bullet">-</span> dbfilename dump.rdb<br><br><span class="hljs-section"># 2.修改生成位置</span><br><span class="hljs-bullet">-</span> dir ./<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623210352448.png" alt="image-20200623210352448"></p><hr><h3 id="9-2-AOF-只追加日志文件"><a href="#9-2-AOF-只追加日志文件" class="headerlink" title="9.2 AOF 只追加日志文件"></a>9.2 AOF 只追加日志文件</h3><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1.特点"></a>1.特点</h4><p>这种方式可以将所有客户端执行的写命令记录到日志文件中,AOF持久化会将被执行的写命令写到AOF的文件末尾,以此来记录数据发生的变化,因此只要redis从头到尾执行一次AOF文件所包含的所有写命令,就可以恢复AOF文件的记录的数据集.</p><p><img src="/images/imgRedis/image-20200623211330798.png" alt="image-20200623211330798"></p><h4 id="2-开启AOF持久化"><a href="#2-开启AOF持久化" class="headerlink" title="2.开启AOF持久化"></a>2.开启AOF持久化</h4><p>在redis的默认配置中AOF持久化机制是没有开启的，需要在配置中开启</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.开启AOF持久化</span><br><span class="hljs-bullet">-</span> a.修改 appendonly yes 开启持久化<br><span class="hljs-bullet">-</span> b.修改 appendfilename &quot;appendonly.aof&quot; 指定生成文件名称<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623211508987.png" alt="image-20200623211508987"></p><h4 id="3-日志追加频率"><a href="#3-日志追加频率" class="headerlink" title="3.日志追加频率"></a>3.日志追加频率</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.always 【谨慎使用】</span><br><span class="hljs-bullet">-</span> 说明: 每个redis写命令都要同步写入硬盘,严重降低redis速度<br><span class="hljs-bullet">-</span> 解释: 如果用户使用了always选项,那么每个redis写命令都会被写入硬盘,从而将发生系统崩溃时出现的数据丢失减到最少;遗憾的是,因为这种同步策略需要对硬盘进行大量的写入操作,所以redis处理命令的速度会受到硬盘性能的限制;<br><span class="hljs-bullet">-</span> 注意: 转盘式硬盘在这种频率下200左右个命令/s ; 固态硬盘(SSD) 几百万个命令/s;<br><span class="hljs-bullet">-</span> 警告: 使用SSD用户请谨慎使用always选项,这种模式不断写入少量数据的做法有可能会引发严重的写入放大问题,导致将固态硬盘的寿命从原来的几年降低为几个月。<br><br><span class="hljs-section"># 2.everysec 【推荐】</span><br><span class="hljs-bullet">-</span> 说明: 每秒执行一次同步显式的将多个写命令同步到磁盘<br><span class="hljs-bullet">-</span> 解释： 为了兼顾数据安全和写入性能,用户可以考虑使用everysec选项,让redis每秒一次的频率对AOF文件进行同步;redis每秒同步一次AOF文件时性能和不使用任何持久化特性时的性能相差无几,而通过每秒同步一次AOF文件,redis可以保证,即使系统崩溃,用户最多丢失一秒之内产生的数据。<br><br><span class="hljs-section"># 3.no【不推荐】</span><br><span class="hljs-bullet">-</span> 说明: 由操作系统决定何时同步 <br><span class="hljs-bullet">-</span> 解释：最后使用no选项,将完全有操作系统决定什么时候同步AOF日志文件,这个选项不会对redis性能带来影响但是系统崩溃时,会丢失不定数量的数据,另外如果用户硬盘处理写入操作不够快的话,当缓冲区被等待写入硬盘数据填满时,redis会处于阻塞状态,并导致redis的处理命令请求的速度变慢。<br></code></pre></td></tr></table></figure><h4 id="4-修改同步频率"><a href="#4-修改同步频率" class="headerlink" title="4.修改同步频率"></a>4.修改同步频率</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.修改日志同步频率</span><br><span class="hljs-bullet">-</span> 修改appendfsync everysec|always|no 指定<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623211658910.png" alt="image-20200623211658910"></p><hr><h3 id="9-3-AOF文件的重写"><a href="#9-3-AOF文件的重写" class="headerlink" title="9.3 AOF文件的重写"></a>9.3 AOF文件的重写</h3><h4 id="1-AOF带来的问题"><a href="#1-AOF带来的问题" class="headerlink" title="1. AOF带来的问题"></a>1. AOF带来的问题</h4><p>AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写(ReWriter)机制。</p><h4 id="2-AOF重写"><a href="#2-AOF重写" class="headerlink" title="2. AOF重写"></a>2. AOF重写</h4><p>用来在一定程度上减小AOF文件的体积</p><h4 id="3-触发重写方式"><a href="#3-触发重写方式" class="headerlink" title="3. 触发重写方式"></a>3. 触发重写方式</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.客户端方式触发重写</span><br><span class="hljs-bullet">-</span> 执行BGREWRITEAOF命令  不会阻塞redis的服务<br><br><span class="hljs-section"># 2.服务器配置方式自动触发</span><br><span class="hljs-bullet">-</span> 配置redis.conf中的auto-aof-rewrite-percentage选项 参加下图↓↓↓<br><span class="hljs-bullet">-</span> 如果设置auto-aof-rewrite-percentage值为100和auto-aof-rewrite-min-size 64mb,并且启用的AOF持久化时,那么当AOF文件体积大于64M,并且AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时,会自动触发,如果重写过于频繁,用户可以考虑将auto-aof-rewrite-percentage设置为更大<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623212547775.png" alt="image-20200623212547775"></p><h4 id="4-重写原理"><a href="#4-重写原理" class="headerlink" title="4. 重写原理"></a>4. 重写原理</h4><p> <strong>注意：重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,替换原有的文件这点和快照有点类似。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 重写流程</span><br><span class="hljs-bullet">-</span> 1. redis调用fork ，现在有父子两个进程 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令<br><span class="hljs-bullet">-</span> 2. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。<br><span class="hljs-bullet">-</span> 3. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。<br><span class="hljs-bullet">-</span> 4. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623214843123.png" alt="image-20200623214843123"></p><hr><h3 id="9-4-持久化总结"><a href="#9-4-持久化总结" class="headerlink" title="9.4 持久化总结"></a>9.4 持久化总结</h3><p>两种持久化方案既可以同时使用(aof),又可以单独使用,在某种情况下也可以都不使用,具体使用那种持久化方案取决于用户的数据和应用决定。</p><p>无论使用AOF还是快照机制持久化,将数据持久化到硬盘都是有必要的,除了持久化外,用户还应该对持久化的文件进行备份(最好备份在多个不同地方)。</p><hr><h2 id="10-java操作Redis"><a href="#10-java操作Redis" class="headerlink" title="10. java操作Redis"></a>10. java操作Redis</h2><h3 id="10-1-环境准备"><a href="#10-1-环境准备" class="headerlink" title="10.1 环境准备"></a>10.1 环境准备</h3><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入jedis连接依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-创建jedis对象"><a href="#2-创建jedis对象" class="headerlink" title="2.创建jedis对象"></a>2.创建jedis对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  <span class="hljs-comment">//1.创建jedis对象</span><br>  Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.40.4&quot;</span>, <span class="hljs-number">6379</span>);<span class="hljs-comment">//1.redis服务必须关闭防火墙  2.redis服务必须开启远程连接</span><br>  jedis.select(<span class="hljs-number">0</span>);<span class="hljs-comment">//选择操作的库默认0号库</span><br>  <span class="hljs-comment">//2.执行相关操作</span><br>  <span class="hljs-comment">//....</span><br>  <span class="hljs-comment">//3.释放资源</span><br>  jedis.close();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200623201932000.png" alt="image-20200623201932000"></p><h3 id="10-2-操作key相关API"><a href="#10-2-操作key相关API" class="headerlink" title="10.2 操作key相关API"></a>10.2 操作key相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">&quot;192.168.202.205&quot;</span>, <span class="hljs-number">7000</span>);<br>    &#125;<br>    <span class="hljs-meta">@After</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>        jedis.close();<br>    &#125;<br><br>    <span class="hljs-comment">//测试key相关</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testKeys</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//删除一个key</span><br>        jedis.del(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">//删除多个key</span><br>        jedis.del(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>);<br><br>        <span class="hljs-comment">//判断一个key是否存在exits</span><br>        Boolean name = jedis.exists(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br><br>        <span class="hljs-comment">//设置一个key超时时间 expire pexpire</span><br>        Long age = jedis.expire(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">100</span>);<br>        System.out.println(age);<br><br>        <span class="hljs-comment">//获取一个key超时时间 ttl</span><br>        Long age1 = jedis.ttl(<span class="hljs-string">&quot;newage&quot;</span>);<br>        System.out.println(age1);<br><br>        <span class="hljs-comment">//随机获取一个key</span><br>        String s = jedis.randomKey();<br><br>        <span class="hljs-comment">//修改key名称</span><br>        jedis.rename(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;newage&quot;</span>);<br><br>        <span class="hljs-comment">//查看可以对应值的类型</span><br>        String name1 = jedis.type(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name1);<br>        String maps = jedis.type(<span class="hljs-string">&quot;maps&quot;</span>);<br>        System.out.println(maps);<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627180325687.png" alt="image-20200627180325687"></p><h3 id="10-3操作String相关API"><a href="#10-3操作String相关API" class="headerlink" title="10.3操作String相关API"></a>10.3操作String相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试String相关</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testString</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//set</span><br>        jedis.set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;小陈&quot;</span>);<br>        <span class="hljs-comment">//get</span><br>        String s = jedis.get(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(s);<br>        <span class="hljs-comment">//mset</span><br>        jedis.mset(<span class="hljs-string">&quot;content&quot;</span>,<span class="hljs-string">&quot;好人&quot;</span>,<span class="hljs-string">&quot;address&quot;</span>,<span class="hljs-string">&quot;海淀区&quot;</span>);<br>        <span class="hljs-comment">//mget</span><br>        List&lt;String&gt; mget = jedis.mget(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-string">&quot;address&quot;</span>);<br>        mget.forEach(v-&gt; System.out.println(<span class="hljs-string">&quot;v = &quot;</span> + v));<br>        <span class="hljs-comment">//getset</span><br>        String set = jedis.getSet(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>        System.out.println(set);<br><br>        <span class="hljs-comment">//............</span><br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627180352953.png" alt="image-20200627180352953"></p><h3 id="10-4操作List相关API"><a href="#10-4操作List相关API" class="headerlink" title="10.4操作List相关API"></a>10.4操作List相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试List相关</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testList</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//lpush</span><br>        jedis.lpush(<span class="hljs-string">&quot;names1&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;王五&quot;</span>,<span class="hljs-string">&quot;赵柳&quot;</span>,<span class="hljs-string">&quot;win7&quot;</span>);<br><br>        <span class="hljs-comment">//rpush</span><br>        jedis.rpush(<span class="hljs-string">&quot;names1&quot;</span>,<span class="hljs-string">&quot;xiaomingming&quot;</span>);<br><br>        <span class="hljs-comment">//lrange</span><br><br>        List&lt;String&gt; names1 = jedis.lrange(<span class="hljs-string">&quot;names1&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        names1.forEach(name-&gt; System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name));<br><br>        <span class="hljs-comment">//lpop rpop</span><br>        String names11 = jedis.lpop(<span class="hljs-string">&quot;names1&quot;</span>);<br>        System.out.println(names11);<br><br>        <span class="hljs-comment">//llen</span><br>        jedis.linsert(<span class="hljs-string">&quot;lists&quot;</span>, BinaryClient.LIST_POSITION.BEFORE,<span class="hljs-string">&quot;xiaohei&quot;</span>,<span class="hljs-string">&quot;xiaobai&quot;</span>);<br><br>      <span class="hljs-comment">//........</span><br><br>    &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627180435997.png" alt="image-20200627180435997"></p><h3 id="10-5操作Set的相关API"><a href="#10-5操作Set的相关API" class="headerlink" title="10.5操作Set的相关API"></a>10.5操作Set的相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试SET相关</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSet</span><span class="hljs-params">()</span></span>&#123;<br><br>  <span class="hljs-comment">//sadd</span><br>  jedis.sadd(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>);<br><br>  <span class="hljs-comment">//smembers</span><br>  jedis.smembers(<span class="hljs-string">&quot;names&quot;</span>);<br><br>  <span class="hljs-comment">//sismember</span><br>  jedis.sismember(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-string">&quot;xiaochen&quot;</span>);<br><br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627181913715.png" alt="image-20200627181913715"></p><h3 id="10-6-操作ZSet相关API"><a href="#10-6-操作ZSet相关API" class="headerlink" title="10.6 操作ZSet相关API"></a>10.6 操作ZSet相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试ZSET相关</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testZset</span><span class="hljs-params">()</span></span>&#123;<br><br>  <span class="hljs-comment">//zadd</span><br>  jedis.zadd(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br><br>  <span class="hljs-comment">//zrange</span><br>  jedis.zrange(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">//zcard</span><br>  jedis.zcard(<span class="hljs-string">&quot;names&quot;</span>);<br><br>  <span class="hljs-comment">//zrangeByScore</span><br>  jedis.zrangeByScore(<span class="hljs-string">&quot;names&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br><br>  <span class="hljs-comment">//..</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627181947116.png" alt="image-20200627181947116"></p><h3 id="10-7-操作Hash相关API"><a href="#10-7-操作Hash相关API" class="headerlink" title="10.7 操作Hash相关API"></a>10.7 操作Hash相关API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试HASH相关</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHash</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//hset</span><br>  jedis.hset(<span class="hljs-string">&quot;maps&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>  <span class="hljs-comment">//hget</span><br>  jedis.hget(<span class="hljs-string">&quot;maps&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>);<br>  <span class="hljs-comment">//hgetall</span><br>  jedis.hgetAll(<span class="hljs-string">&quot;mps&quot;</span>);<br>  <span class="hljs-comment">//hkeys</span><br>  jedis.hkeys(<span class="hljs-string">&quot;maps&quot;</span>);<br>  <span class="hljs-comment">//hvals</span><br>  jedis.hvals(<span class="hljs-string">&quot;maps&quot;</span>);<br>  <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200628093242527.png" alt="image-20200628093242527"></p><hr><h2 id="11-SpringBoot整合Redis"><a href="#11-SpringBoot整合Redis" class="headerlink" title="11.SpringBoot整合Redis"></a>11.SpringBoot整合Redis</h2><p>Spring Boot Data(数据) Redis 中提供了<strong>RedisTemplate和StringRedisTemplate</strong>，其中StringRedisTemplate是RedisTemplate的子类，两个方法基本一致，不同之处主要体现在操作的数据类型不同，<strong>RedisTemplate中的两个泛型都是Object，意味着存储的key和value都可以是一个对象，而StringRedisTemplate的两个泛型都是String，意味着StringRedisTemplate的key和value都只能是字符串。</strong></p><p><code>注意: 使用RedisTemplate默认是将对象序列化到Redis中,所以放入的对象必须实现对象序列化接口</code></p><h3 id="11-1-环境准备"><a href="#11-1-环境准备" class="headerlink" title="11.1 环境准备"></a>11.1 环境准备</h3><h4 id="1-引入依赖-1"><a href="#1-引入依赖-1" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-配置application-propertie"><a href="#2-配置application-propertie" class="headerlink" title="2.配置application.propertie"></a>2.配置application.propertie</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-meta">spring.redis.database</span>=<span class="hljs-string">0</span><br></code></pre></td></tr></table></figure><h3 id="11-2-使用StringRedisTemplate和RedisTemplate"><a href="#11-2-使用StringRedisTemplate和RedisTemplate" class="headerlink" title="11.2 使用StringRedisTemplate和RedisTemplate"></a>11.2 使用StringRedisTemplate和RedisTemplate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;  <span class="hljs-comment">//对字符串支持比较友好,不能存储对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;  <span class="hljs-comment">//存储对象</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testRedisTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(redisTemplate);<br>        <span class="hljs-comment">//设置redistemplate值使用对象序列化策略</span><br>        redisTemplate.setValueSerializer(<span class="hljs-keyword">new</span> JdkSerializationRedisSerializer());<span class="hljs-comment">//指定值使用对象序列化</span><br>        <span class="hljs-comment">//redisTemplate.opsForValue().set(&quot;user&quot;,new User(&quot;21&quot;,&quot;小黑&quot;,23,new Date()));</span><br>        User user = (User) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user&quot;</span>);<br>        System.out.println(user);<br><span class="hljs-comment">//      Set keys = redisTemplate.keys(&quot;*&quot;);</span><br><span class="hljs-comment">//      keys.forEach(key -&gt; System.out.println(key));</span><br>        <span class="hljs-comment">/*Object name = redisTemplate.opsForValue().get(&quot;name&quot;);</span><br><span class="hljs-comment">        System.out.println(name);*/</span><br><br>        <span class="hljs-comment">//Object xiaohei = redisTemplate.opsForValue().get(&quot;xiaohei&quot;);</span><br>        <span class="hljs-comment">//System.out.println(xiaohei);</span><br>        <span class="hljs-comment">/*redisTemplate.opsForValue().set(&quot;name&quot;,&quot;xxxx&quot;);</span><br><span class="hljs-comment">        Object name = redisTemplate.opsForValue().get(&quot;name&quot;);</span><br><span class="hljs-comment">        System.out.println(name);*/</span><br>        <span class="hljs-comment">/*redisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;xxxx&quot;,&quot;1111&quot;);</span><br><span class="hljs-comment">        List lists = redisTemplate.opsForList().range(&quot;lists&quot;, 0, -1);</span><br><span class="hljs-comment">        lists.forEach(list-&gt; System.out.println(list));*/</span><br>    &#125;<br><br><br>    <span class="hljs-comment">//key的绑定操作 如果日后对某一个key的操作及其频繁,可以将这个key绑定到对应redistemplate中,日后基于绑定操作都是操作这个key</span><br>    <span class="hljs-comment">//boundValueOps 用来对String值绑定key</span><br>    <span class="hljs-comment">//boundListOps 用来对List值绑定key</span><br>    <span class="hljs-comment">//boundSetOps 用来对Set值绑定key</span><br>    <span class="hljs-comment">//boundZsetOps 用来对Zset值绑定key</span><br>    <span class="hljs-comment">//boundHashOps 用来对Hash值绑定key</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBoundKey</span><span class="hljs-params">()</span></span>&#123;<br>        BoundValueOperations&lt;String, String&gt; nameValueOperations = stringRedisTemplate.boundValueOps(<span class="hljs-string">&quot;name&quot;</span>);<br>        nameValueOperations.set(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-comment">//yuew</span><br>        nameValueOperations.set(<span class="hljs-string">&quot;2&quot;</span>);<br>        String s = nameValueOperations.get();<br>        System.out.println(s);<br><br>    &#125;<br><br><br>    <span class="hljs-comment">//hash相关操作 opsForHash</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHash</span><span class="hljs-params">()</span></span>&#123;<br>        stringRedisTemplate.opsForHash().put(<span class="hljs-string">&quot;maps&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;小黑&quot;</span>);<br>        Object o = stringRedisTemplate.opsForHash().get(<span class="hljs-string">&quot;maps&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(o);<br>    &#125;<br><br>    <span class="hljs-comment">//zset相关操作 opsForZSet</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testZSet</span><span class="hljs-params">()</span></span>&#123;<br>        stringRedisTemplate.opsForZSet().add(<span class="hljs-string">&quot;zsets&quot;</span>,<span class="hljs-string">&quot;小黑&quot;</span>,<span class="hljs-number">10</span>);<br>        Set&lt;String&gt; zsets = stringRedisTemplate.opsForZSet().range(<span class="hljs-string">&quot;zsets&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        zsets.forEach(value-&gt; System.out.println(value));<br>    &#125;<br><br>    <span class="hljs-comment">//set相关操作 opsForSet</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSet</span><span class="hljs-params">()</span></span>&#123;<br>        stringRedisTemplate.opsForSet().add(<span class="hljs-string">&quot;sets&quot;</span>,<span class="hljs-string">&quot;xiaosan&quot;</span>,<span class="hljs-string">&quot;xiaosi&quot;</span>,<span class="hljs-string">&quot;xiaowu&quot;</span>);<br>        Set&lt;String&gt; sets = stringRedisTemplate.opsForSet().members(<span class="hljs-string">&quot;sets&quot;</span>);<br>        sets.forEach(value-&gt; System.out.println(value));<br>    &#125;<br><br>    <span class="hljs-comment">//list相关的操作opsForList</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testList</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// stringRedisTemplate.opsForList().leftPushAll(&quot;lists&quot;,&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);</span><br>        List&lt;String&gt; lists = stringRedisTemplate.opsForList().range(<span class="hljs-string">&quot;lists&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        lists.forEach(key -&gt; System.out.println(key));<br>    &#125;<br><br><br>    <span class="hljs-comment">//String相关的操作 opsForValue</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testString</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//stringRedisTemplate.opsForValue().set(&quot;166&quot;,&quot;好同学&quot;);</span><br>        String s = stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;166&quot;</span>);<br>        System.out.println(s);<br>        Long size = stringRedisTemplate.opsForValue().size(<span class="hljs-string">&quot;166&quot;</span>);<br>        System.out.println(size);<br>    &#125;<br><br><br>    <span class="hljs-comment">//key相关的操作</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        Set&lt;String&gt; keys = stringRedisTemplate.keys(<span class="hljs-string">&quot;*&quot;</span>);<span class="hljs-comment">//查看所有key</span><br>        Boolean name = stringRedisTemplate.hasKey(<span class="hljs-string">&quot;name&quot;</span>);<span class="hljs-comment">//判断某个key是否存在</span><br>        stringRedisTemplate.delete(<span class="hljs-string">&quot;age&quot;</span>);<span class="hljs-comment">//根据指定key删除</span><br>        stringRedisTemplate.rename(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//修改key的名称</span><br>        stringRedisTemplate.expire(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-number">10</span>, TimeUnit.HOURS);<br>      <span class="hljs-comment">//设置key超时时间 参数1:设置key名 参数2:时间 参数3:时间的单位</span><br>        stringRedisTemplate.move(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//移动key</span><br>    &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="12-Redis-主从复制"><a href="#12-Redis-主从复制" class="headerlink" title="12. Redis 主从复制"></a>12. Redis 主从复制</h2><h3 id="12-1-主从复制"><a href="#12-1-主从复制" class="headerlink" title="12.1 主从复制"></a>12.1 主从复制</h3><p>主从复制架构仅仅用来解决数据的冗余备份,从节点仅仅用来同步数据</p><p><strong>无法解决: 1.master节点出现故障的自动故障转移</strong></p><h3 id="12-2-主从复制架构图"><a href="#12-2-主从复制架构图" class="headerlink" title="12.2 主从复制架构图"></a>12.2 主从复制架构图</h3><p><img src="/images/imgRedis/image-20200627201722700.png" alt="image-20200627201722700"></p><h3 id="12-3-搭建主从复制"><a href="#12-3-搭建主从复制" class="headerlink" title="12.3 搭建主从复制"></a>12.3 搭建主从复制</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.准备3台机器并修改配置</span><br><span class="hljs-bullet">-</span> master<br><span class="hljs-code">port 6379</span><br><span class="hljs-code">bind 0.0.0.0</span><br><span class="hljs-code"></span><br><span class="hljs-code">- slave1</span><br><span class="hljs-code">port 6380</span><br><span class="hljs-code">bind 0.0.0.0</span><br><span class="hljs-code">slaveof masterip masterport</span><br><span class="hljs-code"></span><br><span class="hljs-code">- slave2</span><br><span class="hljs-code">port 6381</span><br><span class="hljs-code">bind 0.0.0.0</span><br><span class="hljs-code">slaveof masterip masterport</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627202443388.png" alt="image-20200627202443388"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 2.启动3台机器进行测试</span><br><span class="hljs-bullet">-</span> cd /usr/redis/bin<br><span class="hljs-bullet">-</span> ./redis-server /root/master/redis.conf<br><span class="hljs-bullet">-</span> ./redis-server /root/slave1/redis.conf<br><span class="hljs-bullet">-</span> ./redis-server /root/slave2/redis.conf<br></code></pre></td></tr></table></figure><hr><h2 id="13-Redis哨兵机制"><a href="#13-Redis哨兵机制" class="headerlink" title="13. Redis哨兵机制"></a>13. Redis哨兵机制</h2><h3 id="13-1-哨兵Sentinel机制"><a href="#13-1-哨兵Sentinel机制" class="headerlink" title="13.1 哨兵Sentinel机制"></a>13.1 哨兵Sentinel机制</h3><p>Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。简单的说哨兵就是带有<strong>自动故障转移功能的主从架构</strong>。</p><p><strong>无法解决: 1.单节点并发压力问题   2.单节点内存和磁盘物理上限</strong></p><h3 id="13-2-哨兵架构原理"><a href="#13-2-哨兵架构原理" class="headerlink" title="13.2 哨兵架构原理"></a>13.2 哨兵架构原理</h3><p><img src="/images/imgRedis/image-20200627204422750.png" alt="image-20200627204422750"></p><h3 id="13-3-搭建哨兵架构"><a href="#13-3-搭建哨兵架构" class="headerlink" title="13.3 搭建哨兵架构"></a>13.3 搭建哨兵架构</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.在主节点上创建哨兵配置</span><br><span class="hljs-bullet">-</span> 在Master对应redis.conf同目录下新建sentinel.conf文件，名字绝对不能错；<br><br><span class="hljs-section"># 2.配置哨兵，在sentinel.conf文件中填入内容：</span><br><span class="hljs-bullet">-</span> sentinel monitor 被监控数据库名字（自己起名字） ip port 1<br><br><span class="hljs-section"># 3.启动哨兵模式进行测试</span><br><span class="hljs-bullet">-</span> redis-sentinel  /root/sentinel/sentinel.conf<br><span class="hljs-code">说明:这个后面的数字2,是指当有两个及以上的sentinel服务检测到master宕机，才会去执行主从切换的功能。</span><br></code></pre></td></tr></table></figure><h3 id="13-4-通过springboot操作哨兵"><a href="#13-4-通过springboot操作哨兵" class="headerlink" title="13.4 通过springboot操作哨兵"></a>13.4 通过springboot操作哨兵</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># redis sentinel 配置</span><br><span class="hljs-comment"># master书写是使用哨兵监听的那个名称</span><br><span class="hljs-meta">spring.redis.sentinel.master</span>=<span class="hljs-string">mymaster</span><br><span class="hljs-comment"># 连接的不再是一个具体redis主机,书写的是多个哨兵节点</span><br><span class="hljs-meta">spring.redis.sentinel.nodes</span>=<span class="hljs-string">192.168.202.206:26379</span><br></code></pre></td></tr></table></figure><ul><li><strong>注意:如果连接过程中出现如下错误:RedisConnectionException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2)</strong></li><li><strong>解决方案:在哨兵的配置文件中加入bind 0.0.0.0 开启远程连接权限</strong></li></ul><p><img src="/images/imgRedis/image-20200629154647970.png" alt="image-20200629154647970"></p><h2 id="14-Redis集群"><a href="#14-Redis集群" class="headerlink" title="14. Redis集群"></a>14. Redis集群</h2><h3 id="14-1-集群"><a href="#14-1-集群" class="headerlink" title="14.1 集群"></a>14.1 集群</h3><p>Redis在3.0后开始支持Cluster(模式)模式,目前redis的集群支持节点的自动发现,支持slave-master选举和容错,支持在线分片(sharding shard )等特性。reshard</p><h3 id="14-2-集群架构图"><a href="#14-2-集群架构图" class="headerlink" title="14.2 集群架构图"></a>14.2 集群架构图</h3><p><img src="/images/imgRedis/wpsgRnQP8.jpg" alt="img"></p><h3 id="14-3-集群细节"><a href="#14-3-集群细节" class="headerlink" title="14.3 集群细节"></a>14.3 集群细节</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.<br><span class="hljs-bullet">-</span> 节点的fail是通过集群中超过半数的节点检测失效时才生效. <br><span class="hljs-bullet">-</span> 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可<br><span class="hljs-bullet">-</span> redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200629165226329.png" alt="image-20200629165226329"></p><h3 id="14-4-集群搭建"><a href="#14-4-集群搭建" class="headerlink" title="14.4 集群搭建"></a>14.4 集群搭建</h3><p>判断一个是集群中的节点是否可用,是集群中的所用主节点选举过程,如果半数以上的节点认为当前节点挂掉,那么当前节点就是挂掉了,所以搭建redis集群时建议节点数最好为奇数，<strong>搭建集群至少需要三个主节点,三个从节点,至少需要6个节点</strong>。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.准备环境安装ruby以及redis集群依赖</span><br><span class="hljs-bullet">-</span> yum install -y ruby rubygems<br><span class="hljs-bullet">-</span> gem install redis-xxx.gem<br><br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627193219366.png" alt="image-20200627193219366"></p><p><img src="/images/imgRedis/image-20200627193348905.png" alt="image-20200627193348905"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 2.在一台机器创建7个目录</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627193849867.png" alt="image-20200627193849867"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 3.每个目录复制一份配置文件</span><br>[root@localhost ~]# cp redis-4.0.10/redis.conf 7000/<br>[root@localhost ~]# cp redis-4.0.10/redis.conf 7001/<br>[root@localhost ~]# cp redis-4.0.10/redis.conf 7002/<br>[root@localhost ~]# cp redis-4.0.10/redis.conf 7003/<br>[root@localhost ~]# cp redis-4.0.10/redis.conf 7004/<br>[root@localhost ~]# cp redis-4.0.10/redis.conf 7005/<br>[root@localhost ~]# cp redis-4.0.10/redis.conf 7006/<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627194103354.png" alt="image-20200627194103354"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 4.修改不同目录配置文件</span><br><span class="hljs-bullet">-</span> port 6379 .....                 //修改端口<br><span class="hljs-bullet">-</span> bind  0.0.0.0                    //开启远程连接<br><span class="hljs-bullet">-</span> cluster-enabled  yes          //开启集群模式<br><span class="hljs-bullet">-</span> cluster-config-file  nodes-port.conf //集群节点配置文件<br><span class="hljs-bullet">-</span> cluster-node-timeout  5000         //集群节点超时时间<br><span class="hljs-bullet">-</span> appendonly  yes                  //开启AOF持久化<br><br><span class="hljs-section"># 5.指定不同目录配置文件启动七个节点</span><br><span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7000/redis.conf<br><span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7001/redis.conf<br><span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7002/redis.conf<br><span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7003/redis.conf<br><span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7004/redis.conf<br><span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7005/redis.conf<br><span class="hljs-bullet">-</span> [root@localhost bin]# ./redis-server  /root/7006/redis.conf<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627194913866.png" alt="image-20200627194913866"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 6.查看进程</span><br><span class="hljs-bullet">-</span> [root@localhost bin]# ps aux|grep redis<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627194954143.png" alt="image-20200627194954143"></p><h4 id="1-创建集群"><a href="#1-创建集群" class="headerlink" title="1.创建集群"></a>1.创建集群</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.复制集群操作脚本到bin目录中</span><br><span class="hljs-bullet">-</span> [root@localhost bin]# cp /root/redis-4.0.10/src/redis-trib.rb .<br><br><span class="hljs-section"># 2.创建集群</span><br><span class="hljs-bullet">-</span> ./redis-trib.rb create --replicas 1 192.168.202.205:7000 192.168.202.205:7001 192.168.202.205:7002 192.168.202.205:7003 192.168.202.205:7004 192.168.202.205:7005<br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627195601307.png" alt="image-20200627195601307"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 3.集群创建成功出现如下提示</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRedis/image-20200627195647767.png" alt="image-20200627195647767"></p><h4 id="2-查看集群状态"><a href="#2-查看集群状态" class="headerlink" title="2.查看集群状态"></a>2.查看集群状态</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.查看集群状态 check [原始集群中任意节点] [无]</span><br><span class="hljs-bullet">-</span> ./redis-trib.rb check 192.168.202.205:7000<br><br><span class="hljs-section"># 2.集群节点状态说明</span><br><span class="hljs-bullet">-</span> 主节点 <br><span class="hljs-code">主节点存在hash slots,且主节点的hash slots 没有交叉</span><br><span class="hljs-code">主节点不能删除</span><br><span class="hljs-code">一个主节点可以有多个从节点</span><br><span class="hljs-code">主节点宕机时多个副本之间自动选举主节点</span><br><span class="hljs-code"></span><br><span class="hljs-code">- 从节点</span><br><span class="hljs-code">从节点没有hash slots</span><br><span class="hljs-code">从节点可以删除</span><br><span class="hljs-code">从节点不负责数据的写,只负责数据的同步</span><br></code></pre></td></tr></table></figure><h4 id="3-添加主节点"><a href="#3-添加主节点" class="headerlink" title="3.添加主节点"></a>3.添加主节点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.添加主节点 add-node [新加入节点] [原始集群中任意节点]</span><br><span class="hljs-bullet">-</span> ./redis-trib.rb  add-node 192.168.1.158:7006  192.168.1.158:7005<br><span class="hljs-bullet">-</span> 注意:<br><span class="hljs-code">1.该节点必须以集群模式启动</span><br><span class="hljs-code">2.默认情况下该节点就是以master节点形式添加</span><br></code></pre></td></tr></table></figure><h4 id="4-添加从节点"><a href="#4-添加从节点" class="headerlink" title="4.添加从节点"></a>4.添加从节点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.添加从节点 add-node --slave [新加入节点] [集群中任意节点]</span><br><span class="hljs-bullet">-</span> ./redis-trib.rb  add-node --slave 192.168.1.158:7006 192.168.1.158:7000<br><span class="hljs-bullet">-</span> 注意:<br><span class="hljs-code">当添加副本节点时没有指定主节点,redis会随机给副本节点较少的主节点添加当前副本节点</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 2.为确定的master节点添加主节点 add-node --slave --master-id master节点id [新加入节点] [集群任意节点]</span><br><span class="hljs-code">- ./redis-trib.rb  add-node --slave --master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7006  127.0.0.1:7000</span><br></code></pre></td></tr></table></figure><h4 id="5-删除副本节点"><a href="#5-删除副本节点" class="headerlink" title="5.删除副本节点"></a>5.删除副本节点</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.删除节点 del-node [集群中任意节点] [删除节点id]</span><br><span class="hljs-bullet">-</span> ./redis-trib.rb  del-node 127.0.0.1:7002 0ca3f102ecf0c888fc7a7ce43a13e9be9f6d3dd1<br><span class="hljs-bullet">-</span> 注意:<br> 1.被删除的节点必须是从节点或没有被分配hash slots的节点<br></code></pre></td></tr></table></figure><h4 id="6-集群在线分片"><a href="#6-集群在线分片" class="headerlink" title="6.集群在线分片"></a>6.集群在线分片</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.在线分片 reshard [集群中任意节点] [无]</span><br><span class="hljs-bullet">-</span> ./redis-trib.rb  reshard  192.168.1.158:7000<br></code></pre></td></tr></table></figure><hr><h2 id="15-Redis实现分布式Session管理"><a href="#15-Redis实现分布式Session管理" class="headerlink" title="15.Redis实现分布式Session管理"></a>15.Redis实现分布式Session管理</h2><h3 id="15-1-管理机制"><a href="#15-1-管理机制" class="headerlink" title="15.1 管理机制"></a>15.1 管理机制</h3><p><strong>redis的session管理是利用spring提供的session管理解决方案,将一个应用session交给Redis存储,整个应用中所有session的请求都会去redis中获取对应的session数据。</strong></p><p><img src="/images/imgRedis/image-20200628201643358.png" alt="image-20200628201643358"></p><h3 id="15-2-开发Session管理"><a href="#15-2-开发Session管理" class="headerlink" title="15.2 开发Session管理"></a>15.2 开发Session管理</h3><h4 id="1-引入依赖-2"><a href="#1-引入依赖-2" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-开发Session管理配置类"><a href="#2-开发Session管理配置类" class="headerlink" title="2. 开发Session管理配置类"></a>2. 开发Session管理配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableRedisHttpSession</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisSessionManager</span> </span>&#123;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-打包测试即可"><a href="#3-打包测试即可" class="headerlink" title="3.打包测试即可"></a>3.打包测试即可</h4><hr>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>NoSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ 笔记</title>
    <link href="/2021/03/22/RibbitMQ%20%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/22/RibbitMQ%20%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ-笔记"><a href="#RabbitMQ-笔记" class="headerlink" title="RabbitMQ 笔记"></a>RabbitMQ 笔记</h1><h2 id="1-MQ引言"><a href="#1-MQ引言" class="headerlink" title="1.MQ引言"></a>1.MQ引言</h2><h3 id="1-1-什么是MQ"><a href="#1-1-什么是MQ" class="headerlink" title="1.1 什么是MQ"></a>1.1 什么是MQ</h3><p><code>MQ</code>(Message Quene) :  翻译为 <code>消息队列</code>,通过典型的 <code>生产者</code>和<code>消费者</code>模型,生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入,轻松的实现系统间解耦。别名为 <code>消息中间件</code>    通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</p><h3 id="1-2-MQ有哪些"><a href="#1-2-MQ有哪些" class="headerlink" title="1.2 MQ有哪些"></a>1.2 MQ有哪些</h3><p>当今市面上有很多主流的消息中间件，如老牌的<code>ActiveMQ</code>、<code>RabbitMQ</code>，炙手可热的<code>Kafka</code>，阿里巴巴自主开发<code>RocketMQ</code>等。</p><h3 id="1-3-不同MQ特点"><a href="#1-3-不同MQ特点" class="headerlink" title="1.3 不同MQ特点"></a>1.3 不同MQ特点</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.ActiveMQ</span><br><span class="hljs-code">ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。它是一个完全支持JMS规范的的消息中间件。丰富的API,多种集群架构模式让ActiveMQ在业界成为老牌的消息中间件,在中小型企业颇受欢迎!</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 2.Kafka</span><br><span class="hljs-code">Kafka是LinkedIn开源的分布式发布-订阅消息系统，目前归属于Apache顶级项目。Kafka主要特点是基于Pull的模式来处理消息消费，</span><br><span class="hljs-code">追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，</span><br><span class="hljs-code">适合产生大量数据的互联网服务的数据收集业务。</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 3.RocketMQ</span><br><span class="hljs-code">RocketMQ是阿里开源的消息中间件，它是纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起</span><br><span class="hljs-code">源于Kafka，但并不是Kafka的一个Copy，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消</span><br><span class="hljs-code">息推送、日志流式处理、binglog分发等场景。</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 4.RabbitMQ</span><br><span class="hljs-code">RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和</span><br><span class="hljs-code">发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在</span><br><span class="hljs-code">其次。</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><blockquote><p>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</p></blockquote><hr><h2 id="2-RabbitMQ-的引言"><a href="#2-RabbitMQ-的引言" class="headerlink" title="2.RabbitMQ 的引言"></a>2.RabbitMQ 的引言</h2><h3 id="2-1-RabbitMQ"><a href="#2-1-RabbitMQ" class="headerlink" title="2.1 RabbitMQ"></a>2.1 RabbitMQ</h3><blockquote><p>基于<code>AMQP</code>协议，erlang语言开发，是部署最广泛的开源消息中间件,是最受欢迎的开源消息中间件之一。</p></blockquote><p><img src="/images/imgRibbitMQ/image-20190925215603036-9419777.png" alt="image-20190925215603036"></p><p><code>官网</code>: <a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><p><code>官方教程</code>: <a href="https://www.rabbitmq.com/#getstarted">https://www.rabbitmq.com/#getstarted</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># AMQP 协议</span><br><span class="hljs-code">AMQP（advanced message queuing protocol）`在2003年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。以下是AMQP协议模型:</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRibbitMQ/image-20200311182438041.png" alt="image-20200311182438041"></p><h3 id="2-2-RabbitMQ-的安装"><a href="#2-2-RabbitMQ-的安装" class="headerlink" title="2.2 RabbitMQ 的安装"></a>2.2 RabbitMQ 的安装</h3><h4 id="2-2-1-下载"><a href="#2-2-1-下载" class="headerlink" title="2.2.1 下载"></a>2.2.1 下载</h4><p><code>官网下载地址</code>: <a href="https://www.rabbitmq.com/download.html![image-20190925220115235](/images/imgRibbitMQ/image-20190925220115235.png)">https://www.rabbitmq.com/download.html![image-20190925220115235](/images/imgRibbitMQ/image-20190925220115235.png)</a></p><blockquote><p><code>最新版本</code>: 3.7.18</p></blockquote><h4 id="2-2-2-下载的安装包"><a href="#2-2-2-下载的安装包" class="headerlink" title="2.2.2 下载的安装包"></a>2.2.2 下载的安装包<img src="/images/imgRibbitMQ/image-20190925220343521.png" alt="image-20190925220343521"></h4><blockquote><p><code>注意</code>:这里的安装包是centos7安装的包</p></blockquote><h4 id="2-2-3-安装步骤"><a href="#2-2-3-安装步骤" class="headerlink" title="2.2.3 安装步骤"></a>2.2.3 安装步骤</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.将rabbitmq安装包上传到linux系统中</span><br><span class="hljs-code">erlang-22.0.7-1.el7.x86_64.rpm</span><br><span class="hljs-code">rabbitmq-server-3.7.18-1.el7.noarch.rpm</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 2.安装Erlang依赖包</span><br><span class="hljs-code">rpm -ivh erlang-22.0.7-1.el7.x86_64.rpm</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 3.安装RabbitMQ安装包(需要联网)</span><br><span class="hljs-code">yum install -y rabbitmq-server-3.7.18-1.el7.noarch.rpm</span><br><span class="hljs-code">注意:默认安装完成后配置文件模板在:/usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example目录中,需要</span><br><span class="hljs-code">将配置文件复制到/etc/rabbitmq/目录中,并修改名称为rabbitmq.config</span><br><span class="hljs-code"># 4.复制配置文件</span><br><span class="hljs-code">cp /usr/share/doc/rabbitmq-server-3.7.18/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 5.查看配置文件位置</span><br><span class="hljs-code">ls /etc/rabbitmq/rabbitmq.config</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 6.修改配置文件(参见下图:)</span><br><span class="hljs-code">vim /etc/rabbitmq/rabbitmq.config </span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRibbitMQ/image-20190925222230260-3836271.png" alt="image-20190925222230260"></p><p>将上图中配置文件中红色部分去掉<code>%%</code>,以及最后的<code>,</code>逗号 修改为下图:</p><p><img src="/images/imgRibbitMQ/image-20190925222329200-3836312.png" alt="image-20190925222329200"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 7.执行如下命令,启动rabbitmq中的插件管理</span><br><span class="hljs-code">rabbitmq-plugins enable rabbitmq_management</span><br><span class="hljs-code"></span><br><span class="hljs-code">出现如下说明:</span><br><span class="hljs-code">Enabling plugins on node rabbit@localhost:</span><br><span class="hljs-code">    rabbitmq_management</span><br><span class="hljs-code">    The following plugins have been configured:</span><br><span class="hljs-code">      rabbitmq_management</span><br><span class="hljs-code">      rabbitmq_management_agent</span><br><span class="hljs-code">      rabbitmq_web_dispatch</span><br><span class="hljs-code">    Applying plugin configuration to rabbit@localhost...</span><br><span class="hljs-code">    The following plugins have been enabled:</span><br><span class="hljs-code">      rabbitmq_management</span><br><span class="hljs-code">      rabbitmq_management_agent</span><br><span class="hljs-code">      rabbitmq_web_dispatch</span><br><span class="hljs-code"></span><br><span class="hljs-code">    set 3 plugins.</span><br><span class="hljs-code">    Offline change; changes will take effect at broker restart.</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 8.启动RabbitMQ的服务</span><br><span class="hljs-code">systemctl start rabbitmq-server</span><br><span class="hljs-code">systemctl restart rabbitmq-server</span><br><span class="hljs-code">systemctl stop rabbitmq-server</span><br><span class="hljs-code"></span><br><span class="hljs-code"></span><br><span class="hljs-code"># 9.查看服务状态(见下图:)</span><br><span class="hljs-code">systemctl status rabbitmq-server</span><br><span class="hljs-code">  ● rabbitmq-server.service - RabbitMQ broker</span><br><span class="hljs-code">     Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)</span><br><span class="hljs-code">     Active: active (running) since 三 2019-09-25 22:26:35 CST; 7s ago</span><br><span class="hljs-code">   Main PID: 2904 (beam.smp)</span><br><span class="hljs-code">     Status: &quot;Initialized&quot;</span><br><span class="hljs-code">     CGroup: /system.slice/rabbitmq-server.service</span><br><span class="hljs-code">             ├─2904 /usr/lib64/erlang/erts-10.4.4/bin/beam.smp -W w -A 64 -MBas ageffcbf -MHas ageffcbf -</span><br><span class="hljs-code">             MBlmbcs...</span><br><span class="hljs-code">             ├─3220 erl_child_setup 32768</span><br><span class="hljs-code">             ├─3243 inet_gethost 4</span><br><span class="hljs-code">             └─3244 inet_gethost 4</span><br><span class="hljs-code">      .........</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRibbitMQ/image-20190925222743776-3836511.png" alt="image-20190925222743776"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 10.关闭防火墙服务</span><br><span class="hljs-code">systemctl disable firewalld</span><br><span class="hljs-code">    Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.</span><br><span class="hljs-code">    Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span><br><span class="hljs-code">systemctl stop firewalld   </span><br><span class="hljs-code"></span><br><span class="hljs-code"># 11.访问web管理界面</span><br><span class="hljs-code">http://10.15.0.8:15672/</span><br></code></pre></td></tr></table></figure><p> <img src="/images/imgRibbitMQ/image-20190926194738708-3836601.png" alt="image-20190926194738708"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 12.登录管理界面</span><br><span class="hljs-code">username:  guest</span><br><span class="hljs-code">password:  guest</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRibbitMQ/image-20190926194954822-3836665.png" alt="image-20190926194954822"></p><hr><h2 id="3-RabiitMQ-配置"><a href="#3-RabiitMQ-配置" class="headerlink" title="3. RabiitMQ 配置"></a>3. RabiitMQ 配置</h2><h3 id="3-1RabbitMQ-管理命令行"><a href="#3-1RabbitMQ-管理命令行" class="headerlink" title="3.1RabbitMQ 管理命令行"></a>3.1RabbitMQ 管理命令行</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 1.服务启动相关</span><br><span class="hljs-code">systemctl start|restart|stop|status rabbitmq-server</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 2.管理命令行  用来在不使用web管理界面情况下命令操作RabbitMQ</span><br><span class="hljs-code">rabbitmqctl  help  可以查看更多命令</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 3.插件管理命令行</span><br><span class="hljs-code">rabbitmq-plugins enable|list|disable </span><br></code></pre></td></tr></table></figure><h3 id="3-2-web管理界面介绍"><a href="#3-2-web管理界面介绍" class="headerlink" title="3.2 web管理界面介绍"></a>3.2 web管理界面介绍</h3><h4 id="3-2-1-overview概览"><a href="#3-2-1-overview概览" class="headerlink" title="3.2.1 overview概览"></a>3.2.1 overview概览</h4><p><img src="/images/imgRibbitMQ/image-20191126162026720.png" alt="image-20191126162026720"></p><ul><li><p><code>connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况</code></p></li><li><p><code>channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。</code></p></li><li><p><code>Exchanges：交换机，用来实现消息的路由</code></p></li><li><p><code>Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。</code></p></li></ul><h4 id="3-2-2-Admin用户和虚拟主机管理"><a href="#3-2-2-Admin用户和虚拟主机管理" class="headerlink" title="3.2.2 Admin用户和虚拟主机管理"></a>3.2.2 Admin用户和虚拟主机管理</h4><h5 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="1. 添加用户"></a>1. 添加用户</h5><p><img src="/images/imgRibbitMQ/image-20191126162617280.png" alt="image-20191126162617280"></p><p>上面的Tags选项，其实是指定用户的角色，可选的有以下几个：</p><ul><li><p><code>超级管理员(administrator)</code></p><p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p></li><li><p><code>监控者(monitoring)</code></p><p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p></li><li><p><code>策略制定者(policymaker)</code></p><p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p></li><li><p><code>普通管理者(management)</code></p><p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p></li><li><p><code>其他</code></p><p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p></li></ul><h5 id="2-创建虚拟主机"><a href="#2-创建虚拟主机" class="headerlink" title="2. 创建虚拟主机"></a>2. 创建虚拟主机</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 虚拟主机</span><br><span class="hljs-code">为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。</span><br></code></pre></td></tr></table></figure><p> <img src="/images/imgRibbitMQ/image-20191126163023153.png" alt="image-20191126163023153"></p><h5 id="3-绑定虚拟主机和用户"><a href="#3-绑定虚拟主机和用户" class="headerlink" title="3. 绑定虚拟主机和用户"></a>3. 绑定虚拟主机和用户</h5><p>创建好虚拟主机，我们还要给用户添加访问权限：</p><p>点击添加好的虚拟主机：</p><p> <img src="/images/imgRibbitMQ/image-20191126163506795.png" alt="image-20191126163506795"></p><p>进入虚拟机设置界面:</p><p><img src="/images/imgRibbitMQ/image-20191126163631889.png" alt="image-20191126163631889"></p><hr><h2 id="4-RabbitMQ-的第一个程序"><a href="#4-RabbitMQ-的第一个程序" class="headerlink" title="4.RabbitMQ 的第一个程序"></a>4.RabbitMQ 的第一个程序</h2><h3 id="4-0-AMQP协议的回顾"><a href="#4-0-AMQP协议的回顾" class="headerlink" title="4.0 AMQP协议的回顾"></a>4.0 AMQP协议的回顾</h3><p><img src="/images/imgRibbitMQ/image-20200312140114784.png" alt="image-20200312140114784"></p><h3 id="4-1-RabbitMQ支持的消息模型"><a href="#4-1-RabbitMQ支持的消息模型" class="headerlink" title="4.1 RabbitMQ支持的消息模型"></a>4.1 RabbitMQ支持的消息模型</h3><p><img src="/images/imgRibbitMQ/image-20191126165434784.png" alt="image-20191126165434784"></p><p><img src="/images/imgRibbitMQ/image-20191126165459282.png" alt="image-20191126165459282"></p><h3 id="4-2-引入依赖"><a href="#4-2-引入依赖" class="headerlink" title="4.2 引入依赖"></a>4.2 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-3-第一种模型-直连"><a href="#4-3-第一种模型-直连" class="headerlink" title="4.3 第一种模型(直连)"></a>4.3 第一种模型(直连)</h3><p><img src="/images/imgRibbitMQ/image-20191126165840602.png" alt="image-20191126165840602"></p><p>在上图的模型中，有以下概念：</p><ul><li>P：生产者，也就是要发送消息的程序</li><li>C：消费者：消息的接受者，会一直等待消息到来。</li><li>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</li></ul><h5 id="1-开发生产者"><a href="#1-开发生产者" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建连接工厂</span><br>ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();<br>connectionFactory.setHost(<span class="hljs-string">&quot;10.15.0.9&quot;</span>);<br>connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>connectionFactory.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br>connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>Connection connection = connectionFactory.newConnection();<br><span class="hljs-comment">//创建通道</span><br>Channel channel = connection.createChannel();<br><span class="hljs-comment">//参数1: 是否持久化  参数2:是否独占队列 参数3:是否自动删除  参数4:其他属性</span><br>channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;hello rabbitmq&quot;</span>.getBytes());<br>channel.close();<br>connection.close();<br></code></pre></td></tr></table></figure><h5 id="2-开发消费者"><a href="#2-开发消费者" class="headerlink" title="2. 开发消费者"></a>2. 开发消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建连接工厂</span><br>ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();<br>connectionFactory.setHost(<span class="hljs-string">&quot;10.15.0.9&quot;</span>);<br>connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>connectionFactory.setUsername(<span class="hljs-string">&quot;ems&quot;</span>);<br>connectionFactory.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br>connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/ems&quot;</span>);<br>Connection connection = connectionFactory.newConnection();<br>Channel channel = connection.createChannel();<br>channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br>channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.out.println(<span class="hljs-keyword">new</span> String(body));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="3-参数的说明"><a href="#3-参数的说明" class="headerlink" title="3. 参数的说明"></a>3. 参数的说明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br><span class="hljs-string">&#x27;参数1&#x27;</span>:用来声明通道对应的队列<br> <span class="hljs-string">&#x27;参数2&#x27;</span>:用来指定是否持久化队列<br> <span class="hljs-string">&#x27;参数3&#x27;</span>:用来指定是否独占队列<br> <span class="hljs-string">&#x27;参数4&#x27;</span>:用来指定是否自动删除队列<br> <span class="hljs-string">&#x27;参数5&#x27;</span>:对队列的额外配置<br></code></pre></td></tr></table></figure><hr><h3 id="4-4-第二种模型-work-quene"><a href="#4-4-第二种模型-work-quene" class="headerlink" title="4.4 第二种模型(work quene)"></a>4.4 第二种模型(work quene)</h3><p><code>Work queues</code>，也被称为（<code>Task queues</code>），任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work 模型：<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。</p><p><img src="/images/imgRibbitMQ/image-20200314221002008.png" alt="image-20200314221002008"></p><p>角色：</p><ul><li>P：生产者：任务的发布者</li><li>C1：消费者-1，领取任务并且完成任务，假设完成速度较慢</li><li>C2：消费者-2：领取任务并完成任务，假设完成速度快</li></ul><h5 id="1-开发生产者-1"><a href="#1-开发生产者-1" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-keyword">null</span>, (i+<span class="hljs-string">&quot;====&gt;:我是消息&quot;</span>).getBytes());<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-开发消费者-1"><a href="#2-开发消费者-1" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1: &quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="3-开发消费者-2"><a href="#3-开发消费者-2" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.queueDeclare(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      Thread.sleep(<span class="hljs-number">1000</span>);   <span class="hljs-comment">//处理消息比较慢 一秒处理一个消息</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;消费者2: &quot;</span>+<span class="hljs-keyword">new</span> String(body));  <br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="4-测试结果"><a href="#4-测试结果" class="headerlink" title="4.测试结果"></a>4.测试结果</h5><p><img src="/images/imgRibbitMQ/image-20200314223242058.png" alt="image-20200314223242058"></p><p><img src="/images/imgRibbitMQ/image-20200314223302207.png" alt="image-20200314223302207"></p><blockquote><p><code>总结:默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。</code></p></blockquote><h5 id="5-消息自动确认机制"><a href="#5-消息自动确认机制" class="headerlink" title="5.消息自动确认机制"></a>5.消息自动确认机制</h5><blockquote><p>Doing a task can take a few seconds. You may wonder what happens if one of the consumers starts a long task and dies with it only partly done. With our current code, once RabbitMQ delivers a message to the consumer it immediately marks it for deletion. In this case, if you kill a worker we will lose the message it was just processing. We’ll also lose all the messages that were dispatched to this particular worker but were not yet handled.</p><p>But we don’t want to lose any tasks. If a worker dies, we’d like the task to be delivered to another worker.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicQos(<span class="hljs-number">1</span>);<span class="hljs-comment">//一次只接受一条未确认的消息</span><br><span class="hljs-comment">//参数2:关闭自动确认消息</span><br>channel.basicConsume(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1: &quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>    channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-keyword">false</span>);<span class="hljs-comment">//手动确认消息</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><p>设置通道一次只能消费一个消息</p></li><li><p>关闭消息的自动确认,开启手动确认消息</p><p><img src="/images/imgRibbitMQ/image-20200314230412178.png" alt="image-20200314230412178"></p><p><img src="/images/imgRibbitMQ/image-20200314230423280.png" alt="image-20200314230423280"></p></li></ul><hr><h3 id="4-5-第三种模型-fanout"><a href="#4-5-第三种模型-fanout" class="headerlink" title="4.5 第三种模型(fanout)"></a>4.5 第三种模型(fanout)</h3><p><code>fanout 扇出 也称为广播</code></p><p> <img src="/images/imgRibbitMQ/image-20191126213115873.png" alt="image-20191126213115873"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li> 可以有多个消费者</li><li> 每个<strong>消费者有自己的queue</strong>（队列）</li><li> 每个<strong>队列都要绑定到Exchange</strong>（交换机）</li><li><strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li><li> 交换机把消息发送给绑定过的所有队列</li><li> 队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li></ul><h5 id="1-开发生产者-2"><a href="#1-开发生产者-2" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//声明交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<span class="hljs-comment">//广播 一条消息多个消费者同时消费</span><br><span class="hljs-comment">//发布消息</span><br>channel.basicPublish(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;hello&quot;</span>.getBytes());<br></code></pre></td></tr></table></figure><h5 id="2-开发消费者-1-1"><a href="#2-开发消费者-1-1" class="headerlink" title="2. 开发消费者-1"></a>2. 开发消费者-1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//绑定交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br><span class="hljs-comment">//创建临时队列</span><br>String queue = channel.queueDeclare().getQueue();<br><span class="hljs-comment">//将临时队列绑定exchange</span><br>channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//处理消息</span><br>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1: &quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="3-开发消费者-2-1"><a href="#3-开发消费者-2-1" class="headerlink" title="3. 开发消费者-2"></a>3. 开发消费者-2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//绑定交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br><span class="hljs-comment">//创建临时队列</span><br>String queue = channel.queueDeclare().getQueue();<br><span class="hljs-comment">//将临时队列绑定exchange</span><br>channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//处理消息</span><br>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者2: &quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="4-开发消费者-3"><a href="#4-开发消费者-3" class="headerlink" title="4.开发消费者-3"></a>4.开发消费者-3</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//绑定交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;fanout&quot;</span>);<br><span class="hljs-comment">//创建临时队列</span><br>String queue = channel.queueDeclare().getQueue();<br><span class="hljs-comment">//将临时队列绑定exchange</span><br>channel.queueBind(queue,<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//处理消息</span><br>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者3: &quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="5-测试结果"><a href="#5-测试结果" class="headerlink" title="5. 测试结果"></a>5. 测试结果</h5><p><img src="/images/imgRibbitMQ/image-20200315180653207.png" alt="image-20200315180653207"></p><p><img src="/images/imgRibbitMQ/image-20200315180708489.png" alt="image-20200315180708489"></p><p><img src="/images/imgRibbitMQ/image-20200315180728035.png" alt="image-20200315180728035"></p><hr><h3 id="4-6-第四种模型-Routing"><a href="#4-6-第四种模型-Routing" class="headerlink" title="4.6 第四种模型(Routing)"></a>4.6 第四种模型(Routing)</h3><h4 id="4-6-1-Routing-之订阅模型-Direct-直连"><a href="#4-6-1-Routing-之订阅模型-Direct-直连" class="headerlink" title="4.6.1 Routing 之订阅模型-Direct(直连)"></a>4.6.1 Routing 之订阅模型-Direct(直连)</h4><p><code>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</code></p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p>流程:</p><p><img src="/images/imgRibbitMQ/image-20191126220145375.png" alt="image-20191126220145375"></p><p>图解：</p><ul><li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li><li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li><li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li><li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li></ul><h5 id="1-开发生产者-3"><a href="#1-开发生产者-3" class="headerlink" title="1. 开发生产者"></a>1. 开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//声明交换机  参数1:交换机名称 参数2:交换机类型 基于指令的Routing key转发</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br>String key = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-comment">//发布消息</span><br>channel.basicPublish(<span class="hljs-string">&quot;logs_direct&quot;</span>,key,<span class="hljs-keyword">null</span>,(<span class="hljs-string">&quot;指定的route key&quot;</span>+key+<span class="hljs-string">&quot;的消息&quot;</span>).getBytes());<br></code></pre></td></tr></table></figure><h5 id="2-开发消费者-1-2"><a href="#2-开发消费者-1-2" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//声明交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br><span class="hljs-comment">//创建临时队列</span><br>String queue = channel.queueDeclare().getQueue();<br><span class="hljs-comment">//绑定队列和交换机</span><br>channel.queueBind(queue,<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>);<br>channel.queueBind(queue,<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;info&quot;</span>);<br>channel.queueBind(queue,<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;warn&quot;</span>);<br><br><span class="hljs-comment">//消费消息</span><br>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1: &quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="3-开发消费者-2-2"><a href="#3-开发消费者-2-2" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//声明交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>);<br><span class="hljs-comment">//创建临时队列</span><br>String queue = channel.queueDeclare().getQueue();<br><span class="hljs-comment">//绑定队列和交换机</span><br>channel.queueBind(queue,<span class="hljs-string">&quot;logs_direct&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>);<br><span class="hljs-comment">//消费消息</span><br>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者2: &quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="4-测试生产者发送Route-key为error的消息时"><a href="#4-测试生产者发送Route-key为error的消息时" class="headerlink" title="4.测试生产者发送Route key为error的消息时"></a>4.测试生产者发送Route key为error的消息时</h5><p> <img src="/images/imgRibbitMQ/image-20200316102613933.png" alt="image-20200316102613933"></p><p> <img src="/images/imgRibbitMQ/image-20200316102627912.png" alt="image-20200316102627912"></p><h5 id="5-测试生产者发送Route-key为info的消息时"><a href="#5-测试生产者发送Route-key为info的消息时" class="headerlink" title="5.测试生产者发送Route key为info的消息时"></a>5.测试生产者发送Route key为info的消息时</h5><p> <img src="/images/imgRibbitMQ/image-20200316102925740.png" alt="image-20200316102925740"></p><p> <img src="/images/imgRibbitMQ/image-20200316102947326.png" alt="image-20200316102947326"></p><hr><h4 id="4-6-2-Routing-之订阅模型-Topic"><a href="#4-6-2-Routing-之订阅模型-Topic" class="headerlink" title="4.6.2 Routing 之订阅模型-Topic"></a>4.6.2 Routing 之订阅模型-Topic</h4><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！这种模型<code>Routingkey</code> 一般都是由一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p><img src="/images/imgRibbitMQ/image-20191127121900255.png" alt="image-20191127121900255"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 统配符</span><br><span class="hljs-bullet">*</span> (star) can substitute for exactly one word.    匹配不多不少恰好1个词<br><span class="hljs-code"># (hash) can substitute for zero or more words.  匹配一个或多个词</span><br><span class="hljs-code"># 如:</span><br><span class="hljs-code">audit.#    匹配audit.irs.corporate或者 audit.irs 等</span><br><span class="hljs-code">    audit.*   只能匹配 audit.irs</span><br></code></pre></td></tr></table></figure><h5 id="1-开发生产者-4"><a href="#1-开发生产者-4" class="headerlink" title="1.开发生产者"></a>1.开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生命交换机和交换机类型 topic 使用动态路由(通配符方式)</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br>String routekey = <span class="hljs-string">&quot;user.save&quot;</span>;<span class="hljs-comment">//动态路由key</span><br><span class="hljs-comment">//发布消息</span><br>channel.basicPublish(<span class="hljs-string">&quot;topics&quot;</span>,routekey,<span class="hljs-keyword">null</span>,(<span class="hljs-string">&quot;这是路由中的动态订阅模型,route key: [&quot;</span>+routekey+<span class="hljs-string">&quot;]&quot;</span>).getBytes());<br></code></pre></td></tr></table></figure><h5 id="2-开发消费者-1-3"><a href="#2-开发消费者-1-3" class="headerlink" title="2.开发消费者-1"></a>2.开发消费者-1</h5><p><code>Routing Key中使用*通配符方式</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//声明交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br><span class="hljs-comment">//创建临时队列</span><br>String queue = channel.queueDeclare().getQueue();<br><span class="hljs-comment">//绑定队列与交换机并设置获取交换机中动态路由</span><br>channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.*&quot;</span>);<br><br><span class="hljs-comment">//消费消息</span><br>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者1: &quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="3-开发消费者-2-3"><a href="#3-开发消费者-2-3" class="headerlink" title="3.开发消费者-2"></a>3.开发消费者-2</h5><p><code>Routing Key中使用#通配符方式</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//声明交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;topic&quot;</span>);<br><span class="hljs-comment">//创建临时队列</span><br>String queue = channel.queueDeclare().getQueue();<br><span class="hljs-comment">//绑定队列与交换机并设置获取交换机中动态路由</span><br>channel.queueBind(queue,<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.#&quot;</span>);<br><br><span class="hljs-comment">//消费消息</span><br>channel.basicConsume(queue,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;消费者2: &quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="4-测试结果-1"><a href="#4-测试结果-1" class="headerlink" title="4.测试结果"></a>4.测试结果</h5><p> <img src="/images/imgRibbitMQ/image-20200316113935785.png" alt="image-20200316113935785"></p><p> <img src="/images/imgRibbitMQ/image-20200316114000459.png" alt="image-20200316114000459"></p><h2 id="5-SpringBoot中使用RabbitMQ"><a href="#5-SpringBoot中使用RabbitMQ" class="headerlink" title="5. SpringBoot中使用RabbitMQ"></a>5. SpringBoot中使用RabbitMQ</h2><h3 id="5-0-搭建初始环境"><a href="#5-0-搭建初始环境" class="headerlink" title="5.0 搭建初始环境"></a>5.0 搭建初始环境</h3><h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-配置配置文件"><a href="#2-配置配置文件" class="headerlink" title="2. 配置配置文件"></a>2. 配置配置文件</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">springboot_rabbitmq</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">10.15</span><span class="hljs-number">.0</span><span class="hljs-number">.9</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">ems</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/ems</span><br></code></pre></td></tr></table></figure><p><code>RabbitTemplate</code>  用来简化操作     使用时候直接在项目中注入即可使用</p><h3 id="5-1-第一种hello-world模型使用"><a href="#5-1-第一种hello-world模型使用" class="headerlink" title="5.1 第一种hello world模型使用"></a>5.1 第一种hello world模型使用</h3><ol><li><h5 id="开发生产者"><a href="#开发生产者" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHello</span><span class="hljs-params">()</span></span>&#123;<br>  rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="开发消费者"><a href="#开发消费者" class="headerlink" title="开发消费者"></a>开发消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;hello&quot;))</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloCustomer</span> </span>&#123;<br><br>    <span class="hljs-meta">@RabbitHandler</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-2-第二种work模型使用"><a href="#5-2-第二种work模型使用" class="headerlink" title="5.2 第二种work模型使用"></a>5.2 第二种work模型使用</h3><ol><li><h5 id="开发生产者-1"><a href="#开发生产者-1" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWork</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;work&quot;</span>,<span class="hljs-string">&quot;hello work!&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="开发消费者-1"><a href="#开发消费者-1" class="headerlink" title="开发消费者"></a>开发消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkCustomer</span> </span>&#123;<br>    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;work message1 = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(&quot;work&quot;))</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;work message2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>说明:默认在Spring AMQP实现中Work这种方式就是公平调度,如果需要实现能者多劳需要额外配置</code></p></blockquote></li></ol><h3 id="5-3-Fanout-广播模型"><a href="#5-3-Fanout-广播模型" class="headerlink" title="5.3 Fanout 广播模型"></a>5.3 Fanout 广播模型</h3><ol><li><h5 id="开发生产者-2"><a href="#开发生产者-2" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFanout</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>  rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;logs&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;这是日志广播&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="开发消费者-2"><a href="#开发消费者-2" class="headerlink" title="开发消费者"></a>开发消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutCustomer</span> </span>&#123;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">            value = @Queue,</span><br><span class="hljs-meta">            exchange = @Exchange(name=&quot;logs&quot;,type = &quot;fanout&quot;)</span><br><span class="hljs-meta">    ))</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message1 = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">            value = @Queue, //创建临时队列</span><br><span class="hljs-meta">            exchange = @Exchange(name=&quot;logs&quot;,type = &quot;fanout&quot;)  //绑定交换机类型</span><br><span class="hljs-meta">    ))</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="5-4-Route-路由模型"><a href="#5-4-Route-路由模型" class="headerlink" title="5.4 Route 路由模型"></a>5.4 Route 路由模型</h3><ol><li><h5 id="开发生产者-3"><a href="#开发生产者-3" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDirect</span><span class="hljs-params">()</span></span>&#123;<br>  rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;directs&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>,<span class="hljs-string">&quot;error 的日志信息&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="开发消费者-3"><a href="#开发消费者-3" class="headerlink" title="开发消费者"></a>开发消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectCustomer</span> </span>&#123;<br><br>    <span class="hljs-meta">@RabbitListener(bindings =&#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue(),</span><br><span class="hljs-meta">                    key=&#123;&quot;info&quot;,&quot;error&quot;&#125;,</span><br><span class="hljs-meta">                    exchange = @Exchange(type = &quot;direct&quot;,name=&quot;directs&quot;)</span><br><span class="hljs-meta">            )&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message1 = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(bindings =&#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue(),</span><br><span class="hljs-meta">                    key=&#123;&quot;error&quot;&#125;,</span><br><span class="hljs-meta">                    exchange = @Exchange(type = &quot;direct&quot;,name=&quot;directs&quot;)</span><br><span class="hljs-meta">            )&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="5-5-Topic-订阅模型-动态路由模型"><a href="#5-5-Topic-订阅模型-动态路由模型" class="headerlink" title="5.5 Topic 订阅模型(动态路由模型)"></a>5.5 Topic 订阅模型(动态路由模型)</h3><ol><li><h5 id="开发生产者-4"><a href="#开发生产者-4" class="headerlink" title="开发生产者"></a>开发生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-comment">//topic</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTopic</span><span class="hljs-params">()</span></span>&#123;<br>  rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;topics&quot;</span>,<span class="hljs-string">&quot;user.save.findAll&quot;</span>,<span class="hljs-string">&quot;user.save.findAll 的消息&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="开发消费者-4"><a href="#开发消费者-4" class="headerlink" title="开发消费者"></a>开发消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopCustomer</span> </span>&#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue,</span><br><span class="hljs-meta">                    key = &#123;&quot;user.*&quot;&#125;,</span><br><span class="hljs-meta">                    exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;)</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive1</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message1 = &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener(bindings = &#123;</span><br><span class="hljs-meta">            @QueueBinding(</span><br><span class="hljs-meta">                    value = @Queue,</span><br><span class="hljs-meta">                    key = &#123;&quot;user.#&quot;&#125;,</span><br><span class="hljs-meta">                    exchange = @Exchange(type = &quot;topic&quot;,name = &quot;topics&quot;)</span><br><span class="hljs-meta">            )</span><br><span class="hljs-meta">    &#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;message2 = &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr></li></ol><h2 id="6-MQ的应用场景"><a href="#6-MQ的应用场景" class="headerlink" title="6. MQ的应用场景"></a>6. MQ的应用场景</h2><h3 id="6-1-异步处理"><a href="#6-1-异步处理" class="headerlink" title="6.1 异步处理"></a>6.1 异步处理</h3><p><code>场景说明：用户注册后，需要发注册邮件和注册短信,传统的做法有两种 1.串行的方式 2.并行的方式</code></p><ul><li><code>串行方式:</code> 将注册信息写入数据库后,发送注册邮件,再发送注册短信,以上三个任务全部完成后才返回给客户端。 这有一个问题是,邮件,短信并不是必须的,它只是一个通知,而这种做法让客户端等待没有必要等待的东西. </li></ul><p> <img src="/images/imgRibbitMQ/SouthEast-4860248.png" alt="这里写图片描述"></p><ul><li><code>并行方式: </code>将注册信息写入数据库后,发送邮件的同时,发送短信,以上三个任务完成后,返回给客户端,并行的方式能提高处理的时间。 </li></ul><p> <img src="/images/imgRibbitMQ/SouthEast-20191127211112660.png" alt="这里写图片描述"></p><ul><li><p><code>消息队列:</code>假设三个业务节点分别使用50ms,串行方式使用时间150ms,并行使用时间100ms。虽然并行已经提高的处理时间,但是,前面说过,邮件和短信对我正常的使用网站没有任何影响，客户端没有必要等着其发送完成才显示注册成功,应该是写入数据库后就返回.  <code>消息队列</code>: 引入消息队列后，把发送邮件,短信不是必须的业务逻辑异步处理 </p><p><img src="/images/imgRibbitMQ/592892-20190520220249900-1679743651.jpg" alt="img"></p></li></ul><p>由此可以看出,引入消息队列后，用户的响应时间就等于写入数据库的时间+写入消息队列的时间(可以忽略不计),引入消息队列后处理后,响应时间是串行的3倍,是并行的2倍。</p><h3 id="6-2-应用解耦"><a href="#6-2-应用解耦" class="headerlink" title="6.2 应用解耦"></a>6.2 应用解耦</h3><p><code>场景：双11是购物狂节,用户下单后,订单系统需要通知库存系统,传统的做法就是订单系统调用库存系统的接口. </code></p><p> <img src="/images/imgRibbitMQ/SouthEast-20191127211247287.png" alt="这里写图片描述"></p><p>这种做法有一个缺点:</p><p>当库存系统出现故障时,订单就会失败。 订单系统和库存系统高耦合.  引入消息队列 </p><p> <img src="/images/imgRibbitMQ/SouthEast-20191127211304085.png" alt="这里写图片描述"></p><ul><li><p><code>订单系统:</code>用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功。</p></li><li><p><code>库存系统:</code>订阅下单的消息,获取下单消息,进行库操作。  就算库存系统出现故障,消息队列也能保证消息的可靠投递,不会导致消息丢失.</p></li></ul><h3 id="6-3-流量削峰"><a href="#6-3-流量削峰" class="headerlink" title="6.3 流量削峰"></a>6.3 流量削峰</h3><p> <code>场景:</code> 秒杀活动，一般会因为流量过大，导致应用挂掉,为了解决这个问题，一般在应用前端加入消息队列。  </p><p>  <code>作用:</code> </p><p>​            1.可以控制活动人数，超过此一定阀值的订单直接丢弃(我为什么秒杀一次都没有成功过呢^^) </p><p>​            2.可以缓解短时间的高流量压垮应用(应用程序按自己的最大处理能力获取订单) </p><p> <img src="/images/imgRibbitMQ/SouthEast-20191127211341601.png" alt="这里写图片描述"></p><p>1.用户的请求,服务器收到之后,首先写入消息队列,加入消息队列长度超过最大值,则直接抛弃用户请求或跳转到错误页面.  </p><p>2.秒杀业务根据消息队列中的请求信息，再做后续处理.</p><hr><h2 id="7-RabbitMQ的集群"><a href="#7-RabbitMQ的集群" class="headerlink" title="7. RabbitMQ的集群"></a>7. RabbitMQ的集群</h2><h3 id="7-1-集群架构"><a href="#7-1-集群架构" class="headerlink" title="7.1 集群架构"></a>7.1 集群架构</h3><h4 id="7-1-1-普通集群-副本集群"><a href="#7-1-1-普通集群-副本集群" class="headerlink" title="7.1.1 普通集群(副本集群)"></a>7.1.1 普通集群(副本集群)</h4><blockquote><p>All data/state required for the operation of a RabbitMQ broker is replicated across all nodes. An exception to this are message queues, which by default reside on one node, though they are visible and reachable from all nodes. To replicate queues across nodes in a cluster   –摘自官网</p></blockquote><p><code>默认情况下:RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是消息队列，默认情况下，消息队列位于一个节点上，尽管它们可以从所有节点看到和访问</code></p><ol><li><h5 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h5></li></ol><p><img src="/images/imgRibbitMQ/image-20200320094147471.png" alt="image-20200320094147471"></p><p>​    核心解决问题:  <code>当集群中某一时刻master节点宕机,可以对Quene中信息,进行备份</code></p><ol start="2"><li><h5 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 0.集群规划</span><br><span class="hljs-code">node1: 10.15.0.3  mq1  master 主节点</span><br><span class="hljs-code">node2: 10.15.0.4  mq2  repl1  副本节点</span><br><span class="hljs-code">node3: 10.15.0.5  mq3  repl2  副本节点</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 1.克隆三台机器主机名和ip映射</span><br><span class="hljs-code">vim /etc/hosts加入:</span><br><span class="hljs-code"> 10.15.0.3 mq1</span><br><span class="hljs-code">    10.15.0.4 mq2</span><br><span class="hljs-code">    10.15.0.5 mq3</span><br><span class="hljs-code">node1: vim /etc/hostname 加入:  mq1</span><br><span class="hljs-code">node2: vim /etc/hostname 加入:  mq2</span><br><span class="hljs-code">node3: vim /etc/hostname 加入:  mq3</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 2.三个机器安装rabbitmq,并同步cookie文件,在node1上执行:</span><br><span class="hljs-code">scp /var/lib/rabbitmq/.erlang.cookie root@mq2:/var/lib/rabbitmq/</span><br><span class="hljs-code">scp /var/lib/rabbitmq/.erlang.cookie root@mq3:/var/lib/rabbitmq/</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 3.查看cookie是否一致:</span><br><span class="hljs-code">node1: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="hljs-code">node2: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="hljs-code">node3: cat /var/lib/rabbitmq/.erlang.cookie </span><br><span class="hljs-code"></span><br><span class="hljs-code"># 4.后台启动rabbitmq所有节点执行如下命令,启动成功访问管理界面:</span><br><span class="hljs-code">rabbitmq-server -detached </span><br><span class="hljs-code"></span><br><span class="hljs-code"># 5.在node2和node3执行加入集群命令:</span><br><span class="hljs-code">1.关闭       rabbitmqctl stop_app</span><br><span class="hljs-code">2.加入集群    rabbitmqctl join_cluster rabbit@mq1</span><br><span class="hljs-code">3.启动服务    rabbitmqctl start_app</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 6.查看集群状态,任意节点执行:</span><br><span class="hljs-code">rabbitmqctl cluster_status</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 7.如果出现如下显示,集群搭建成功:</span><br><span class="hljs-code">Cluster status of node rabbit@mq3 ...</span><br><span class="hljs-code">[&#123;nodes,[&#123;disc,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;]&#125;,</span><br><span class="hljs-code">&#123;running_nodes,[rabbit@mq1,rabbit@mq2,rabbit@mq3]&#125;,</span><br><span class="hljs-code">&#123;cluster_name,&lt;&lt;&quot;rabbit@mq1&quot;&gt;&gt;&#125;,</span><br><span class="hljs-code">&#123;partitions,[]&#125;,</span><br><span class="hljs-code">&#123;alarms,[&#123;rabbit@mq1,[]&#125;,&#123;rabbit@mq2,[]&#125;,&#123;rabbit@mq3,[]&#125;]&#125;]</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 8.登录管理界面,展示如下状态:</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRibbitMQ/image-20200320095613586.png" alt="image-20200320095613586"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 9.测试集群在node1上,创建队列</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRibbitMQ/image-20200320095743935.png" alt="image-20200320095743935"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 10.查看node2和node3节点:</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRibbitMQ/image-20200320095827688.png" alt="image-20200320095827688"></p><p><img src="/images/imgRibbitMQ/image-20200320095843370.png" alt="image-20200320095843370"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 11.关闭node1节点,执行如下命令,查看node2和node3:</span><br><span class="hljs-code">rabbitmqctl stop_app</span><br></code></pre></td></tr></table></figure><p><img src="/images/imgRibbitMQ/image-20200320100000347.png" alt="image-20200320100000347"></p><p><img src="/images/imgRibbitMQ/image-20200320100010968.png" alt="image-20200320100010968"></p><hr></li></ol><h4 id="7-1-2-镜像集群"><a href="#7-1-2-镜像集群" class="headerlink" title="7.1.2 镜像集群"></a>7.1.2 镜像集群</h4><blockquote><p>This guide covers mirroring (queue contents replication) of classic queues  –摘自官网</p><p>By default, contents of a queue within a RabbitMQ cluster are located on a single node (the node on which the queue was declared). This is in contrast to exchanges and bindings, which can always be considered to be on all nodes. Queues can optionally be made <em>mirrored</em> across multiple nodes. –摘自官网</p></blockquote><p><code>镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间进行自动同步，且如果其中一个节点不可用，并不会导致消息丢失或服务不可用的情况，提升MQ集群的整体高可用性。</code></p><ol><li><h5 id="集群架构图"><a href="#集群架构图" class="headerlink" title="集群架构图"></a>集群架构图</h5><p><img src="/images/imgRibbitMQ/image-20200320113423235.png" alt="image-20200320113423235"></p></li><li><h5 id="配置集群架构"><a href="#配置集群架构" class="headerlink" title="配置集群架构"></a>配置集群架构</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 0.策略说明</span><br><span class="hljs-code">rabbitmqctl set_policy [-p &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt;  &lt;definition&gt;</span><br><span class="hljs-code">-p Vhost： 可选参数，针对指定vhost下的queue进行设置</span><br><span class="hljs-code">Name:     policy的名称</span><br><span class="hljs-code">Pattern: queue的匹配模式(正则表达式)</span><br><span class="hljs-code">Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode</span><br><span class="hljs-code">           ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes</span><br><span class="hljs-code">                        all：表示在集群中所有的节点上进行镜像</span><br><span class="hljs-code">                        exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定</span><br><span class="hljs-code">                        nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定</span><br><span class="hljs-code">             ha-params：ha-mode模式需要用到的参数</span><br><span class="hljs-code">                ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual</span><br><span class="hljs-code">                priority：可选参数，policy的优先级</span><br><span class="hljs-code">                </span><br><span class="hljs-code">                 </span><br><span class="hljs-code"># 1.查看当前策略</span><br><span class="hljs-code">rabbitmqctl list_policies</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 2.添加策略</span><br><span class="hljs-code">rabbitmqctl set_policy ha-all &#x27;^hello&#x27; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27; </span><br><span class="hljs-code">说明:策略正则表达式为 “^” 表示所有匹配所有队列名称  ^hello:匹配hello开头队列</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 3.删除策略</span><br><span class="hljs-code">rabbitmqctl clear_policy ha-all</span><br><span class="hljs-code"></span><br><span class="hljs-code"># 4.测试集群</span><br></code></pre></td></tr></table></figure><hr></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>消息中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/03/21/hello-world/"/>
    <url>/2021/03/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
